Vim: Warning: Output is not to a terminal
sourcing "$VIM/vimrc"[J
line 1: " Configuration file for vim[J

line 2: set modelines=0^I^I" CVE-2007-2438[J

line 3: [J

line 4: " Normally we use vim-extensions. If you want true vi-compatibility[J

line 5: " remove change the following statements[J

line 6: set nocompatible^I" Use Vim defaults instead of 100% vi compatibility[J

line 7: set backspace=2^I^I" more powerful backspacing[J

line 8: [J

line 9: " Don't write backup file if vim is being called by "crontab -e"[J

line 10: au BufWrite /private/tmp/crontab.* set nowritebackup[J

line 11: " Don't write backup file if vim is being called by "chpass"[J

line 12: au BufWrite /private/etc/pw.* set nowritebackup[J

finished sourcing $VIM/vimrc[J
sourcing "$HOME/.vimrc"[J
line 1: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 2: " => Pathogen[J

line 3: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 4: call pathogen#runtime_append_all_bundles()[J

Searching for "autoload/pathogen.vim" in "/Users/Eric/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim72,/usr/share/vim/vimfiles/after,/Users/Eric/.vim/after"[J
Searching for "/Users/Eric/.vim/autoload/pathogen.vim"[J
line 4: sourcing "/Users/Eric/.vim/autoload/pathogen.vim"[J
line 1: " pathogen.vim - path option manipulation[J

line 2: " Maintainer:   Tim Pope <vimNOSPAM@tpope.org>[J

line 3: " Version:      1.2[J

line 4: [J

line 5: " Install in ~/.vim/autoload (or ~\vimfiles\autoload).[J

line 6: "[J

line 7: " API is documented below.[J

line 8: [J

line 9: if exists("g:loaded_pathogen") || &cp[J

line 10:   finish[J

line 11: endif[J

line 12: let g:loaded_pathogen = 1[J

line 13: [J

line 14: " Split a path into a list.[J

line 15: function! pathogen#split(path) abort " {{{1[J

line 20: [J

line 21: " Convert a list to a path.[J

line 22: function! pathogen#join(...) abort " {{{1[J

line 47: [J

line 48: " Convert a list to a path with escaped spaces for 'path', 'tag', etc.[J

line 49: function! pathogen#legacyjoin(...) abort " {{{1[J

line 52: [J

line 53: " Remove duplicates from a list.[J

line 54: function! pathogen#uniq(list) abort " {{{1[J

line 67: [J

line 68: " \ on Windows unless shellslash is set, / everywhere else.[J

line 69: function! pathogen#separator() abort " {{{1[J

line 72: [J

line 73: " Convenience wrapper around glob() which returns a list.[J

line 74: function! pathogen#glob(pattern) abort " {{{1[J

line 78: [J

line 79: " Like pathogen#glob(), only limit the results to directories.[J

line 80: function! pathogen#glob_directories(pattern) abort " {{{1[J

line 83: [J

line 84: " Prepend all subdirectories of path to the rtp, and append all after[J

line 85: " directories in those subdirectories.[J

line 86: function! pathogen#runtime_prepend_subdirectories(path) " {{{1[J

line 96: [J

line 97: " For each directory in rtp, check for a subdirectory named dir.  If it[J

line 98: " exists, add all subdirectories of that subdirectory to the rtp, immediately[J

line 99: " after the original directory.  If no argument is given, 'bundle' is used.[J

line 100: " Repeated calls with the same arguments are ignored.[J

line 101: function! pathogen#runtime_append_all_bundles(...) " {{{1[J

line 119: [J

line 120: let s:done_bundles = ''[J

line 121: " }}}1[J

line 122: [J

line 123: " Invoke :helptags on all non-$VIM doc directories in runtimepath.[J

line 124: function! pathogen#helptags() " {{{1[J

line 131: [J

line 132: " vim:set ft=vim ts=8 sw=2 sts=2:[J

finished sourcing /Users/Eric/.vim/autoload/pathogen.vim[J
continuing in /Users/Eric/.vimrc[J
calling function pathogen#runtime_append_all_bundles[J()

line 1:   let sep = pathogen#separator()[J

calling function pathogen#runtime_append_all_bundles..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles[J

line 2:   let name = a:0 ? a:1 : 'bundle'[J

line 3:   if "\n".s:done_bundles =~# "\\M\n".name."\n"[J

line 4:     return ""[J

line 5:   endif[J

line 6:   let s:done_bundles .= name . "\n"[J

line 7:   let list = [][J

line 8:   for dir in pathogen#split(&rtp)[J

calling function pathogen#runtime_append_all_bundles..pathogen#split[J('/Users/Eric/.vim,/usr/share/vim/vimf...m/vimfiles/after,/Users/Eric/.vim/after')

line 1:   if type(a:path) == type([]) | return a:path | endif[J

line 1:  return a:path | endif[J

line 1:  endif[J

line 2:   let split = split(a:path,'\\\@<!\%(\\\\\)*\zs,')[J

line 3:   return map(split,'substitute(v:val,''\\\([\\,]\)'',''\1'',"g")')[J

function pathogen#runtime_append_all_bundles..pathogen#split returning ['/Users/Eric/.vim', '/usr/share/vim/...mfiles/after', '/Users/Eric/.vim/after'][J

continuing in function pathogen#runtime_append_all_bundles[J

line 9:     if dir =~# '\<after$'[J

line 10:       let list +=  pathogen#glob_directories(substitute(dir,'after$',name,'').sep.'*[^~]'.sep.'after') + [dir][J

line 11:     else[J

line 12:       let list +=  [dir] + pathogen#glob_directories(dir.sep.name.sep.'*[^~]')[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories[J('/Users/Eric/.vim/bundle/*[^~]')

line 1:   return filter(pathogen#glob(a:pattern),'isdirectory(v:val)')[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J('/Users/Eric/.vim/bundle/*[^~]')

line 1:   let files = split(glob(a:pattern),"\n")[J

Calling shell to execute: "unset nonomatch; vimglob() { while [ $# -ge 1 ]; do echo "$1"; shift; done }; vimglob >/var/folders/56/56Aa05piHl4IwbnSzdyzh++++TI/-Tmp-/v788947/0 /Users/Eric/.vim/bundle/*[^~]"[J

line 2:   return map(files,'substitute(v:val,"[".pathogen#separator()."/]$","","")')[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob returning ['/Users/Eric/.vim/bundle/align', '/U.../Users/Eric/.vim/bundle/vim-unimpaired'][J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories returning ['/Users/Eric/.vim/bundle/align', '/U.../Users/Eric/.vim/bundle/vim-unimpaired'][J

continuing in function pathogen#runtime_append_all_bundles[J

line 13:     endif[J

line 14:   endfor[J

line 8:   for dir in pathogen#split(&rtp)[J

line 9:     if dir =~# '\<after$'[J

line 10:       let list +=  pathogen#glob_directories(substitute(dir,'after$',name,'').sep.'*[^~]'.sep.'after') + [dir][J

line 11:     else[J

line 12:       let list +=  [dir] + pathogen#glob_directories(dir.sep.name.sep.'*[^~]')[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories[J('/usr/share/vim/vimfiles/bundle/*[^~]...)

line 1:   return filter(pathogen#glob(a:pattern),'isdirectory(v:val)')[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J('/usr/share/vim/vimfiles/bundle/*[^~]...)

line 1:   let files = split(glob(a:pattern),"\n")[J

Calling shell to execute: "unset nonomatch; vimglob() { while [ $# -ge 1 ]; do echo "$1"; shift; done }; vimglob >/var/folders/56/56Aa05piHl4IwbnSzdyzh++++TI/-Tmp-/v788947/1 /usr/share/vim/vimfiles/bundle/*[^~]"[J

line 2:   return map(files,'substitute(v:val,"[".pathogen#separator()."/]$","","")')[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob returning [][J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories returning [][J

continuing in function pathogen#runtime_append_all_bundles[J

line 13:     endif[J

line 14:   endfor[J

line 8:   for dir in pathogen#split(&rtp)[J

line 9:     if dir =~# '\<after$'[J

line 10:       let list +=  pathogen#glob_directories(substitute(dir,'after$',name,'').sep.'*[^~]'.sep.'after') + [dir][J

line 11:     else[J

line 12:       let list +=  [dir] + pathogen#glob_directories(dir.sep.name.sep.'*[^~]')[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories[J('/usr/share/vim/vim72/bundle/*[^~]')

line 1:   return filter(pathogen#glob(a:pattern),'isdirectory(v:val)')[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J('/usr/share/vim/vim72/bundle/*[^~]')

line 1:   let files = split(glob(a:pattern),"\n")[J

Calling shell to execute: "unset nonomatch; vimglob() { while [ $# -ge 1 ]; do echo "$1"; shift; done }; vimglob >/var/folders/56/56Aa05piHl4IwbnSzdyzh++++TI/-Tmp-/v788947/2 /usr/share/vim/vim72/bundle/*[^~]"[J

line 2:   return map(files,'substitute(v:val,"[".pathogen#separator()."/]$","","")')[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob returning [][J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories returning [][J

continuing in function pathogen#runtime_append_all_bundles[J

line 13:     endif[J

line 14:   endfor[J

line 8:   for dir in pathogen#split(&rtp)[J

line 9:     if dir =~# '\<after$'[J

line 10:       let list +=  pathogen#glob_directories(substitute(dir,'after$',name,'').sep.'*[^~]'.sep.'after') + [dir][J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories[J('/usr/share/vim/vimfiles/bundle/*[^~]...r/share/vim/vimfiles/bundle/*[^~]/after')

line 1:   return filter(pathogen#glob(a:pattern),'isdirectory(v:val)')[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J('/usr/share/vim/vimfiles/bundle/*[^~]...r/share/vim/vimfiles/bundle/*[^~]/after')

line 1:   let files = split(glob(a:pattern),"\n")[J

Calling shell to execute: "unset nonomatch; vimglob() { while [ $# -ge 1 ]; do echo "$1"; shift; done }; vimglob >/var/folders/56/56Aa05piHl4IwbnSzdyzh++++TI/-Tmp-/v788947/3 /usr/share/vim/vimfiles/bundle/*[^~]/after"[J

line 2:   return map(files,'substitute(v:val,"[".pathogen#separator()."/]$","","")')[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob returning [][J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories returning [][J

continuing in function pathogen#runtime_append_all_bundles[J

line 11:     else[J

line 12:       let list +=  [dir] + pathogen#glob_directories(dir.sep.name.sep.'*[^~]')[J

line 13:     endif[J

line 14:   endfor[J

line 8:   for dir in pathogen#split(&rtp)[J

line 9:     if dir =~# '\<after$'[J

line 10:       let list +=  pathogen#glob_directories(substitute(dir,'after$',name,'').sep.'*[^~]'.sep.'after') + [dir][J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories[J('/Users/Eric/.vim/bundle/*[^~]/after')

line 1:   return filter(pathogen#glob(a:pattern),'isdirectory(v:val)')[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J('/Users/Eric/.vim/bundle/*[^~]/after')

line 1:   let files = split(glob(a:pattern),"\n")[J

Calling shell to execute: "unset nonomatch; vimglob() { while [ $# -ge 1 ]; do echo "$1"; shift; done }; vimglob >/var/folders/56/56Aa05piHl4IwbnSzdyzh++++TI/-Tmp-/v788947/4 /Users/Eric/.vim/bundle/*[^~]/after"[J

line 2:   return map(files,'substitute(v:val,"[".pathogen#separator()."/]$","","")')[J

calling function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob..pathogen#separator returning '/'[J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories..pathogen#glob returning ['/Users/Eric/.vim/bundle/snipmate/af.../Users/Eric/.vim/bundle/snipmate/after'][J

continuing in function pathogen#runtime_append_all_bundles..pathogen#glob_directories[J

function pathogen#runtime_append_all_bundles..pathogen#glob_directories returning ['/Users/Eric/.vim/bundle/snipmate/af.../Users/Eric/.vim/bundle/snipmate/after'][J

continuing in function pathogen#runtime_append_all_bundles[J

line 11:     else[J

line 12:       let list +=  [dir] + pathogen#glob_directories(dir.sep.name.sep.'*[^~]')[J

line 13:     endif[J

line 14:   endfor[J

line 8:   for dir in pathogen#split(&rtp)[J

line 9:     if dir =~# '\<after$'[J

line 10:       let list +=  pathogen#glob_directories(substitute(dir,'after$',name,'').sep.'*[^~]'.sep.'after') + [dir][J

line 11:     else[J

line 12:       let list +=  [dir] + pathogen#glob_directories(dir.sep.name.sep.'*[^~]')[J

line 13:     endif[J

line 14:   endfor[J

line 15:   let &rtp = pathogen#join(pathogen#uniq(list))[J

calling function pathogen#runtime_append_all_bundles..pathogen#uniq[J(['/Users/Eric/.vim', '/Users/Eric/.vi...ipmate/after', '/Users/Eric/.vim/after'])

line 1:   let i = 0[J

line 2:   let seen = {}[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     else[J

line 7:       let seen[a:list[i]] = 1[J

line 8:       let i += 1[J

line 9:     endif[J

line 10:   endwhile[J

line 11:   return a:list[J

function pathogen#runtime_append_all_bundles..pathogen#uniq returning ['/Users/Eric/.vim', '/Users/Eric/.vi...ipmate/after', '/Users/Eric/.vim/after'][J

continuing in function pathogen#runtime_append_all_bundles[J

calling function pathogen#runtime_append_all_bundles..pathogen#join[J(['/Users/Eric/.vim', '/Users/Eric/.vi...ipmate/after', '/Users/Eric/.vim/after'])

line 1:   if type(a:1) == type(1) && a:1[J

line 2:     let i = 1[J

line 3:     let space = ' '[J

line 4:   else[J

line 5:     let i = 0[J

line 6:     let space = ''[J

line 7:   endif[J

line 8:   let path = ""[J

line 9:   while i < a:0[J

line 10:     if type(a:000[i]) == type([])[J

line 11:       let list = a:000[i][J

line 12:       let j = 0[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 18:     else[J

line 19:       let path .= "," . a:000[i][J

line 20:     endif[J

line 21:     let i += 1[J

line 22:   endwhile[J

line 9:   while i < a:0[J

line 10:     if type(a:000[i]) == type([])[J

line 11:       let list = a:000[i][J

line 12:       let j = 0[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 18:     else[J

line 19:       let path .= "," . a:000[i][J

line 20:     endif[J

line 21:     let i += 1[J

line 22:   endwhile[J

line 23:   return substitute(path,'^,','','')[J

function pathogen#runtime_append_all_bundles..pathogen#join returning '/Users/Eric/.vim,/Users/Eric/.vim/bu...e/snipmate/after,/Users/Eric/.vim/after'[J

continuing in function pathogen#runtime_append_all_bundles[J

line 16:   return 1[J

function pathogen#runtime_append_all_bundles returning #1[J

continuing in /Users/Eric/.vimrc[J

line 5: call pathogen#helptags()[J

calling function pathogen#helptags[J()

line 1:   for dir in pathogen#split(&rtp)[J

calling function pathogen#helptags..pathogen#split[J('/Users/Eric/.vim,/Users/Eric/.vim/bu...e/snipmate/after,/Users/Eric/.vim/after')

line 1:   if type(a:path) == type([]) | return a:path | endif[J

line 1:  return a:path | endif[J

line 1:  endif[J

line 2:   let split = split(a:path,'\\\@<!\%(\\\\\)*\zs,')[J

line 3:   return map(split,'substitute(v:val,''\\\([\\,]\)'',''\1'',"g")')[J

function pathogen#helptags..pathogen#split returning ['/Users/Eric/.vim', '/Users/Eric/.vi...ipmate/after', '/Users/Eric/.vim/after'][J

continuing in function pathogen#helptags[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

line 1:   for dir in pathogen#split(&rtp)[J

line 2:     if dir[0 : strlen($VIM)-1] !=# $VIM && isdirectory(dir.'/doc') && (!filereadable(dir.'/doc/tags') || filewritable(dir.'/doc/tags'))[J

line 3:       helptags `=dir.'/doc'`[J

line 4:     endif[J

line 5:   endfor[J

function pathogen#helptags returning #0[J

continuing in /Users/Eric/.vimrc[J

line 6: [J

line 7: filetype plugin indent on[J

Searching for "filetype.vim" in "/Users/Eric/.vim,/Users/Eric/.vim/bundle/align,/Users/Eric/.vim/bundle/command-t,/Users/Eric/.vim/bundle/gist,/Users/Eric/.vim/bundle/nerdcommenter,/Users/Eric/.vim/bundle/nerdtree,/Users/Eric/.vim/bundle/snipmate,/Users/Eric/.vim/bundle/vim-abolish,/Users/Eric/.vim/bundle/vim-cucumber,/Users/Eric/.vim/bundle/vim-endwise,/Users/Eric/.vim/bundle/vim-fugitive,/Users/Eric/.vim/bundle/vim-git,/Users/Eric/.vim/bundle/vim-markdown-preview,/Users/Eric/.vim/bundle/vim-pastie,/Users/Eric/.vim/bundle/vim-rails,/Users/Eric/.vim/bundle/vim-repeat,/Users/Eric/.vim/bundle/vim-rspec,/Users/Eric/.vim/bundle/vim-surround,/Users/Eric/.vim/bundle/vim-unimpaired,/usr/share/vim/vimfiles,/usr/share/vim/vim72,/usr/share/vim/vimfiles/after,/Users/Eric/.vim/bundle/snipmate/after,/Users/Eric/.vim/after"[J
Searching for "/Users/Eric/.vim/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/align/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/command-t/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/gist/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/nerdcommenter/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/nerdtree/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/snipmate/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-abolish/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-cucumber/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-endwise/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-fugitive/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-git/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-markdown-preview/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-pastie/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-rails/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-repeat/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-rspec/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-surround/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-unimpaired/filetype.vim"[J
Searching for "/usr/share/vim/vimfiles/filetype.vim"[J
Searching for "/usr/share/vim/vim72/filetype.vim"[J
line 7: sourcing "/usr/share/vim/vim72/filetype.vim"[J
line 1: " Vim support file to detect file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2008 Aug 03[J

line 5: [J

line 6: " Listen very carefully, I will say this only once[J

line 7: if exists("did_load_filetypes")[J

line 8:   finish[J

line 9: endif[J

line 10: let did_load_filetypes = 1[J

line 11: [J

line 12: " Line continuation is used here, remove 'C' from 'cpoptions'[J

line 13: let s:cpo_save = &cpo[J

line 14: set cpo&vim[J

line 15: [J

line 16: augroup filetypedetect[J

line 17: [J

line 18: " Ignored extensions[J

line 19: if exists("*fnameescape")[J

line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.rpmsave,?\+.rpmnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))[J

line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short[J

line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif[J

line 33: elseif &verbose > 0[J

line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"[J

line 35: endif[J

line 36: [J

line 37: " Pattern used to match file names which should not be inspected.[J

line 38: " Currently finds compressed files.[J

line 39: if !exists("g:ft_ignore_pat")[J

line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'[J

line 41: endif[J

line 42: [J

line 43: " Function used for patterns that end in a star: don't set the filetype if the[J

line 44: " file name matches ft_ignore_pat.[J

line 45: func! s:StarSetf(ft)[J

line 50: [J

line 51: " Abaqus or Trasys[J

line 52: au BufNewFile,BufRead *.inp^I^I^Icall s:Check_inp()[J

line 53: [J

line 54: func! s:Check_inp()[J

line 73: [J

line 74: " A-A-P recipe[J

line 75: au BufNewFile,BufRead *.aap^I^I^Isetf aap[J

line 76: [J

line 77: " A2ps printing utility[J

line 78: au BufNewFile,BufRead etc/a2ps.cfg,etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps[J

line 79: [J

line 80: " ABAB/4[J

line 81: au BufNewFile,BufRead *.abap^I^I^Isetf abap[J

line 82: [J

line 83: " ABC music notation[J

line 84: au BufNewFile,BufRead *.abc^I^I^Isetf abc[J

line 85: [J

line 86: " ABEL[J

line 87: au BufNewFile,BufRead *.abl^I^I^Isetf abel[J

line 88: [J

line 89: " AceDB[J

line 90: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb[J

line 91: [J

line 92: " Ada (83, 9X, 95)[J

line 93: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada[J

line 94: if has("vms")[J

line 95:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada[J

line 96: else[J

line 97:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada[J

line 98: endif[J

line 99: [J

line 100: " AHDL[J

line 101: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl[J

line 102: [J

line 103: " AMPL[J

line 104: au BufNewFile,BufRead *.run^I^I^Isetf ampl[J

line 105: [J

line 106: " Ant[J

line 107: au BufNewFile,BufRead build.xml^I^I^Isetf ant[J

line 108: [J

line 109: " Apache style config file[J

line 110: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')[J

line 111: [J

line 112: " Apache config file[J

line 113: au BufNewFile,BufRead .htaccess^I^I^I setf apache[J

line 114: au BufNewFile,BufRead httpd.conf*,srm.conf*,access.conf*,apache.conf*,apache2.conf*,/etc/apache2/*.conf* call s:StarSetf('apache')[J

line 115: [J

line 116: " XA65 MOS6510 cross assembler[J

line 117: au BufNewFile,BufRead *.a65^I^I^Isetf a65[J

line 118: [J

line 119: " Applix ELF[J

line 121: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif[J

line 122: [J

line 123: " ALSA configuration[J

line 124: au BufNewFile,BufRead ~/.asoundrc,/usr/share/alsa/alsa.conf,/etc/asound.conf^Isetf alsaconf[J

line 125: [J

line 126: " Arc Macro Language[J

line 127: au BufNewFile,BufRead *.aml^I^I^Isetf aml[J

line 128: [J

line 129: " Arch Inventory file[J

line 130: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch[J

line 131: [J

line 132: " ART*Enterprise (formerly ART-IM)[J

line 133: au BufNewFile,BufRead *.art^I^I^Isetf art[J

line 134: [J

line 135: " ASN.1[J

line 136: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn[J

line 137: [J

line 138: " Active Server Pages (with Visual Basic Script)[J

line 144: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif[J

line 145: [J

line 146: " Active Server Pages (with Perl or Visual Basic Script)[J

line 154: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif[J

line 155: [J

line 156: " Grub (must be before catch *.lst)[J

line 157: au BufNewFile,BufRead /boot/grub/menu.lst,/boot/grub/grub.conf,/etc/grub.conf^Isetf grub[J

line 158: [J

line 159: " Assembly (all kinds)[J

line 160: " *.lst is not pure assembly, it has two extra columns (address, byte codes)[J

line 161: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall s:FTasm()[J

line 162: [J

line 163: " This function checks for the kind of assembly that is wanted by the user, or[J

line 164: " can be detected from the first five lines of the file.[J

line 165: func! s:FTasm()[J

line 186: [J

line 187: func! s:FTasmsyntax()[J

line 199: [J

line 200: " Macro (VAX)[J

line 201: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm[J

line 202: [J

line 203: " Atlas[J

line 204: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas[J

line 205: [J

line 206: " Autoit v3[J

line 207: au BufNewFile,BufRead *.au3^I^I^Isetf autoit[J

line 208: [J

line 209: " Autohotkey[J

line 210: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey[J

line 211: [J

line 212: " Automake[J

line 213: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake[J

line 214: [J

line 215: " Autotest .at files are actually m4[J

line 216: au BufNewFile,BufRead *.at^I^I^Isetf m4[J

line 217: [J

line 218: " Avenue[J

line 219: au BufNewFile,BufRead *.ave^I^I^Isetf ave[J

line 220: [J

line 221: " Awk[J

line 222: au BufNewFile,BufRead *.awk^I^I^Isetf awk[J

line 223: [J

line 224: " B[J

line 225: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b[J

line 226: [J

line 227: " BASIC or Visual Basic[J

line 228: au BufNewFile,BufRead *.bas^I^I^Icall s:FTVB("basic")[J

line 229: [J

line 230: " Check if one of the first five lines contains "VB_Name".  In that case it is[J

line 231: " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.[J

line 232: func! s:FTVB(alt)[J

line 239: [J

line 240: " Visual Basic Script (close to Visual Basic)[J

line 241: au BufNewFile,BufRead *.vbs,*.dsm,*.ctl^I^Isetf vb[J

line 242: [J

line 243: " IBasic file (similar to QBasic)[J

line 244: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic[J

line 245: [J

line 246: " FreeBasic file (similar to QBasic)[J

line 247: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic[J

line 248: [J

line 249: " Batch file for MSDOS.[J

line 250: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch[J

line 251: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.[J

line 253: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif[J

line 254: [J

line 255: " Batch file for 4DOS[J

line 256: au BufNewFile,BufRead *.btm^I^I^Icall s:FTbtm()[J

line 257: func! s:FTbtm()[J

line 264: [J

line 265: " BC calculator[J

line 266: au BufNewFile,BufRead *.bc^I^I^Isetf bc[J

line 267: [J

line 268: " BDF font[J

line 269: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf[J

line 270: [J

line 271: " BibTeX bibliography database file[J

line 272: au BufNewFile,BufRead *.bib^I^I^Isetf bib[J

line 273: [J

line 274: " BibTeX Bibliography Style[J

line 275: au BufNewFile,BufRead *.bst^I^I^Isetf bst[J

line 276: [J

line 277: " BIND configuration[J

line 278: au BufNewFile,BufRead named.conf,rndc.conf^Isetf named[J

line 279: [J

line 280: " BIND zone[J

line 281: au BufNewFile,BufRead named.root^I^Isetf bindzone[J

line 282: au BufNewFile,BufRead *.db^I^I^Icall s:BindzoneCheck('')[J

line 283: [J

line 284: func! s:BindzoneCheck(default)[J

line 291: [J

line 292: " Blank[J

line 293: au BufNewFile,BufRead *.bl^I^I^Isetf blank[J

line 294: [J

line 295: " Blkid cache file[J

line 296: au BufNewFile,BufRead /etc/blkid.tab,/etc/blkid.tab.old   setf xml[J

line 297: [J

line 298: " C or lpc[J

line 299: au BufNewFile,BufRead *.c^I^I^Icall s:FTlpc()[J

line 300: [J

line 301: func! s:FTlpc()[J

line 314: [J

line 315: " Calendar[J

line 316: au BufNewFile,BufRead calendar^I^I^Isetf calendar[J

line 319: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')[J

line 320: [J

line 321: " C#[J

line 322: au BufNewFile,BufRead *.cs^I^I^Isetf cs[J

line 323: [J

line 324: " Cdrdao TOC[J

line 325: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc[J

line 326: [J

line 327: " Cdrdao config[J

line 328: au BufNewFile,BufRead etc/cdrdao.conf,etc/defaults/cdrdao,etc/default/cdrdao,~/.cdrdao^I^I^I^I^I^Isetf cdrdaoconf[J

line 329: [J

line 330: " Cfengine[J

line 331: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine[J

line 332: [J

line 333: " Comshare Dimension Definition Language[J

line 334: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl[J

line 335: [J

line 336: " Conary Recipe[J

line 337: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe[J

line 338: [J

line 339: " Controllable Regex Mutilator[J

line 340: au BufNewFile,BufRead *.crm^I^I^Isetf crm[J

line 341: [J

line 342: " Cyn++[J

line 343: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp[J

line 344: [J

line 345: " Cynlib[J

line 346: " .cc and .cpp files can be C++ or Cynlib.[J

line 348: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif[J

line 350: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif[J

line 351: [J

line 352: " C++[J

line 353: if has("fname_case")[J

line 354:   au BufNewFile,BufRead *.cxx,*.c++,*.C,*.H,*.hh,*.hxx,*.hpp,*.moc,*.tcc,*.inl setf cpp[J

line 355: else[J

line 356:   au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.moc,*.tcc,*.inl setf cpp[J

line 357: endif[J

line 358: [J

line 359: " .h files can be C, Ch C++, ObjC or ObjC++.[J

line 360: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is[J

line 361: " detected automatically.[J

line 362: au BufNewFile,BufRead *.h^I^I^Icall s:FTheader()[J

line 363: [J

line 364: func! s:FTheader()[J

line 375: [J

line 376: " Ch (CHscript)[J

line 377: au BufNewFile,BufRead *.chf^I^I^Isetf ch[J

line 378: [J

line 379: " TLH files are C++ headers generated by Visual C++'s #import from typelibs[J

line 380: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp[J

line 381: [J

line 382: " Cascading Style Sheets[J

line 383: au BufNewFile,BufRead *.css^I^I^Isetf css[J

line 384: [J

line 385: " Century Term Command Scripts (*.cmd too)[J

line 386: au BufNewFile,BufRead *.con^I^I^Isetf cterm[J

line 387: [J

line 388: " Changelog[J

line 390: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog[J

line 391: [J

line 397: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif[J

line 398: [J

line 402: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif[J

line 403: [J

line 404: " CHILL[J

line 405: au BufNewFile,BufRead *..ch^I^I^Isetf chill[J

line 406: [J

line 407: " Changes for WEB and CWEB or CHILL[J

line 408: au BufNewFile,BufRead *.ch^I^I^Icall s:FTchange()[J

line 409: [J

line 410: " This function checks if one of the first ten lines start with a '@'.  In[J

line 411: " that case it is probably a change file.[J

line 412: " If the first line starts with # or ! it's probably a ch file.[J

line 413: " If a line has "main", "include", "//" ir "/*" it's probably ch.[J

line 414: " Otherwise CHILL is assumed.[J

line 415: func! s:FTchange()[J

line 438: [J

line 439: " ChordPro[J

line 440: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro[J

line 441: [J

line 442: " Clean[J

line 443: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean[J

line 444: [J

line 445: " Clever[J

line 446: au BufNewFile,BufRead *.eni^I^I^Isetf cl[J

line 447: [J

line 448: " Clever or dtd[J

line 449: au BufNewFile,BufRead *.ent^I^I^Icall s:FTent()[J

line 450: [J

line 451: func! s:FTent()[J

line 470: [J

line 471: " Clipper (or FoxPro; could also be eviews)[J

line 477: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif[J

line 478: [J

line 479: " Cmake[J

line 480: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake[J

line 481: [J

line 482: " Cmusrc[J

line 483: au BufNewFile,BufRead ~/.cmus/{autosave,rc,command-history,*.theme} setf cmusrc[J

line 484: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc[J

line 485: [J

line 486: " Cobol[J

line 487: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol[J

line 488: "   cobol or zope form controller python script? (heuristic)[J

line 494: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif[J

line 495: [J

line 496: " Coco/R[J

line 497: au BufNewFile,BufRead *.atg^I^I^Isetf coco[J

line 498: [J

line 499: " Cold Fusion[J

line 500: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf[J

line 501: [J

line 502: " Configure scripts[J

line 503: au BufNewFile,BufRead configure.in,configure.ac setf config[J

line 504: [J

line 505: " CUDA  Cumpute Unified Device Architecture[J

line 506: au BufNewFile,BufRead *.cu^I^I^Isetf cuda[J

line 507: [J

line 508: " WildPackets EtherPeek Decoder[J

line 509: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd[J

line 510: [J

line 511: " Enlightenment configuration files[J

line 512: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c[J

line 513: [J

line 514: " Eterm[J

line 515: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm[J

line 516: [J

line 517: " Lynx config files[J

line 518: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx[J

line 519: [J

line 520: " Quake[J

line 521: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake[J

line 522: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake[J

line 523: [J

line 524: " Quake C[J

line 525: au BufNewFile,BufRead *.qc^I^I^Isetf c[J

line 526: [J

line 527: " Configure files[J

line 528: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg[J

line 529: [J

line 530: " Communicating Sequential Processes[J

line 531: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp[J

line 532: [J

line 533: " CUPL logic description and simulation[J

line 534: au BufNewFile,BufRead *.pld^I^I^Isetf cupl[J

line 535: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim[J

line 536: [J

line 537: " Debian Control[J

line 538: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol[J

line 542: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif[J

line 543: [J

line 544: " Debian Sources.list[J

line 545: au BufNewFile,BufRead /etc/apt/sources.list^Isetf debsources[J

line 546: [J

line 547: " Deny hosts[J

line 548: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts[J

line 549: [J

line 550: " ROCKLinux package description[J

line 551: au BufNewFile,BufRead *.desc^I^I^Isetf desc[J

line 552: [J

line 553: " the D language or dtrace[J

line 554: au BufNewFile,BufRead *.d^I^I^Icall s:DtraceCheck()[J

line 555: [J

line 556: func! s:DtraceCheck()[J

line 564: [J

line 565: " Desktop files[J

line 566: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop[J

line 567: [J

line 568: " Dict config[J

line 569: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf[J

line 570: [J

line 571: " Dictd config[J

line 572: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf[J

line 573: [J

line 574: " Diff files[J

line 575: au BufNewFile,BufRead *.diff,*.rej,*.patch^Isetf diff[J

line 576: [J

line 577: " Dircolors[J

line 578: au BufNewFile,BufRead .dir_colors,/etc/DIR_COLORS^Isetf dircolors[J

line 579: [J

line 580: " Diva (with Skill) or InstallShield[J

line 586: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif[J

line 587: [J

line 588: " DCL (Digital Command Language - vms) or DNS zone file[J

line 589: au BufNewFile,BufRead *.com^I^I^Icall s:BindzoneCheck('dcl')[J

line 590: [J

line 591: " DOT[J

line 592: au BufNewFile,BufRead *.dot^I^I^Isetf dot[J

line 593: [J

line 594: " Dylan - lid files[J

line 595: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid[J

line 596: [J

line 597: " Dylan - intr files (melange)[J

line 598: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr[J

line 599: [J

line 600: " Dylan[J

line 601: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan[J

line 602: [J

line 603: " Microsoft Module Definition[J

line 604: au BufNewFile,BufRead *.def^I^I^Isetf def[J

line 605: [J

line 606: " Dracula[J

line 607: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula[J

line 608: [J

line 609: " dsl[J

line 610: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl[J

line 611: [J

line 612: " DTD (Document Type Definition for XML)[J

line 613: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd[J

line 614: [J

line 615: " EDIF (*.edf,*.edif,*.edn,*.edo)[J

line 616: au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)^Isetf edif[J

line 617: [J

line 618: " Embedix Component Description[J

line 619: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd[J

line 620: [J

line 621: " Eiffel or Specman[J

line 622: au BufNewFile,BufRead *.e,*.E^I^I^Icall s:FTe()[J

line 623: [J

line 624: " Elinks configuration[J

line 625: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks[J

line 626: [J

line 627: func! s:FTe()[J

line 638: [J

line 639: " ERicsson LANGuage; Yaws is erlang too[J

line 640: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang[J

line 641: [J

line 642: " Elm Filter Rules file[J

line 643: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt[J

line 644: [J

line 645: " ESMTP rc file[J

line 646: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc[J

line 647: [J

line 648: " ESQL-C[J

line 649: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc[J

line 650: [J

line 651: " Esterel[J

line 652: au BufNewFile,BufRead *.strl^I^I^Isetf esterel[J

line 653: [J

line 654: " Essbase script[J

line 655: au BufNewFile,BufRead *.csc^I^I^Isetf csc[J

line 656: [J

line 657: " Exim[J

line 658: au BufNewFile,BufRead exim.conf^I^I^Isetf exim[J

line 659: [J

line 660: " Expect[J

line 661: au BufNewFile,BufRead *.exp^I^I^Isetf expect[J

line 662: [J

line 663: " Exports[J

line 664: au BufNewFile,BufRead exports^I^I^Isetf exports[J

line 665: [J

line 666: " Factor[J

line 667: au BufNewFile,BufRead *.factor^I^I^Isetf factor[J

line 668: [J

line 669: " Fetchmail RC file[J

line 670: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail[J

line 671: [J

line 672: " FlexWiki[J

line 673: au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki[J

line 674: [J

line 675: " Focus Executable[J

line 676: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec[J

line 677: [J

line 678: " Focus Master file (but not for auto.master)[J

line 679: au BufNewFile,BufRead auto.master^I^Isetf conf[J

line 680: au BufNewFile,BufRead *.mas,*.master^I^Isetf master[J

line 681: [J

line 682: " Forth[J

line 683: au BufNewFile,BufRead *.fs,*.ft^I^I^Isetf forth[J

line 684: [J

line 685: " Reva Forth[J

line 686: au BufNewFile,BufRead *.frt^I^I^Isetf reva[J

line 687: [J

line 688: " Fortran[J

line 689: if has("fname_case")[J

line 690:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95^I setf fortran[J

line 691: endif[J

line 692: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95  setf fortran[J

line 693: [J

line 694: " Framescript[J

line 695: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript[J

line 696: [J

line 697: " FStab[J

line 698: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab[J

line 699: [J

line 700: " GDB command files[J

line 701: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb[J

line 702: [J

line 703: " GDMO[J

line 704: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo[J

line 705: [J

line 706: " Gedcom[J

line 707: au BufNewFile,BufRead *.ged^I^I^Isetf gedcom[J

line 708: [J

line 709: " Git[J

line 710: autocmd BufNewFile,BufRead *.git/COMMIT_EDITMSG    setf gitcommit[J

line 711: autocmd BufNewFile,BufRead *.git/config,.gitconfig setf gitconfig[J

line 712: autocmd BufNewFile,BufRead git-rebase-todo         setf gitrebase[J

line 716: autocmd BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif[J

line 720: autocmd BufNewFile,BufRead *.git/** if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif[J

line 721: [J

line 722: " Gkrellmrc[J

line 723: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc[J

line 724: [J

line 725: " GP scripts (2.0 and onward)[J

line 726: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp[J

line 727: [J

line 728: " GPG[J

line 729: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg[J

line 730: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg[J

line 731: au BufNewFile,BufRead /usr/**/gnupg/options.skel setf gpg[J

line 732: [J

line 733: " Gnuplot scripts[J

line 734: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot[J

line 735: [J

line 736: " GrADS scripts[J

line 737: au BufNewFile,BufRead *.gs^I^I^Isetf grads[J

line 738: [J

line 739: " Gretl[J

line 740: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl[J

line 741: [J

line 742: " Groovy[J

line 743: au BufNewFile,BufRead *.groovy^I^I^Isetf groovy[J

line 744: [J

line 745: " GNU Server Pages[J

line 746: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp[J

line 747: [J

line 748: " Group file[J

line 749: au BufNewFile,BufRead /etc/group,/etc/group-,/etc/group.edit,/etc/gshadow,/etc/gshadow-,/etc/gshadow.edit,/var/backups/group.bak,/var/backups/gshadow.bak  setf group[J

line 750: [J

line 751: " GTK RC[J

line 752: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc[J

line 753: [J

line 754: " Haml[J

line 755: au BufNewFile,BufRead *.haml^I^I^Isetf haml[J

line 756: [J

line 757: " Hamster Classic | Playground files[J

line 758: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster[J

line 759: [J

line 760: " Haskell[J

line 761: au BufNewFile,BufRead *.hs^I^I^Isetf haskell[J

line 762: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell[J

line 763: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell[J

line 764: [J

line 765: " Haste[J

line 766: au BufNewFile,BufRead *.ht^I^I^Isetf haste[J

line 767: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc[J

line 768: [J

line 769: " Hercules[J

line 770: au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum^Isetf hercules[J

line 771: [J

line 772: " HEX (Intel)[J

line 773: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex[J

line 774: [J

line 775: " Tilde (must be before HTML)[J

line 776: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde[J

line 777: [J

line 778: " HTML (.shtml and .stm for server side)[J

line 779: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()[J

line 780: [J

line 781: " Distinguish between HTML, XHTML and Django[J

line 782: func! s:FThtml()[J

line 797: [J

line 798: " HTML with Ruby - eRuby[J

line 799: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby[J

line 800: [J

line 801: " HTML with M4[J

line 802: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4[J

line 803: [J

line 804: " HTML Cheetah template[J

line 805: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah[J

line 806: [J

line 807: " Host config[J

line 808: au BufNewFile,BufRead /etc/host.conf^I^Isetf hostconf[J

line 809: [J

line 810: " Hosts access[J

line 811: au BufNewFile,BufRead /etc/hosts.allow,/etc/hosts.deny  setf hostsaccess[J

line 812: [J

line 813: " Hyper Builder[J

line 814: au BufNewFile,BufRead *.hb^I^I^Isetf hb[J

line 815: [J

line 816: " Icon[J

line 817: au BufNewFile,BufRead *.icn^I^I^Isetf icon[J

line 818: [J

line 819: " IDL (Interface Description Language)[J

line 820: au BufNewFile,BufRead *.idl^I^I^Icall s:FTidl()[J

line 821: [J

line 822: " Distinguish between standard IDL and MS-IDL[J

line 823: func! s:FTidl()[J

line 834: [J

line 835: " Microsoft IDL (Interface Description Language)  Also *.idl[J

line 836: " MOF = WMI (Windows Management Instrumentation) Managed Object Format[J

line 837: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl[J

line 838: [J

line 839: " Icewm menu[J

line 840: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu[J

line 841: [J

line 842: " Indent profile (must come before IDL *.pro!)[J

line 843: au BufNewFile,BufRead .indent.pro^I^Isetf indent[J

line 844: au BufNewFile,BufRead indent.pro^I^Icall s:ProtoCheck('indent')[J

line 845: [J

line 846: " IDL (Interactive Data Language)[J

line 847: au BufNewFile,BufRead *.pro^I^I^Icall s:ProtoCheck('idlang')[J

line 848: [J

line 849: " Distinguish between "default" and Cproto prototype file. */[J

line 850: func! s:ProtoCheck(default)[J

line 860: [J

line 861: [J

line 862: " Indent RC[J

line 863: au BufNewFile,BufRead indentrc^I^I^Isetf indent[J

line 864: [J

line 865: " Inform[J

line 866: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform[J

line 867: [J

line 868: " Initng[J

line 869: au BufNewFile,BufRead /etc/initng/**/*.i,*.ii^Isetf initng[J

line 870: [J

line 871: " Ipfilter[J

line 872: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter[J

line 873: [J

line 874: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)[J

line 875: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl[J

line 876: [J

line 877: " .INI file for MSDOS[J

line 878: au BufNewFile,BufRead *.ini^I^I^Isetf dosini[J

line 879: [J

line 880: " SysV Inittab[J

line 881: au BufNewFile,BufRead inittab^I^I^Isetf inittab[J

line 882: [J

line 883: " Inno Setup[J

line 884: au BufNewFile,BufRead *.iss^I^I^Isetf iss[J

line 885: [J

line 886: " JAL[J

line 887: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal[J

line 888: [J

line 889: " Jam[J

line 890: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam[J

line 891: [J

line 892: " Java[J

line 893: au BufNewFile,BufRead *.java,*.jav^I^Isetf java[J

line 894: [J

line 895: " JavaCC[J

line 896: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc[J

line 897: [J

line 898: " JavaScript, ECMAScript[J

line 899: au BufNewFile,BufRead *.js,*.javascript,*.es^Isetf javascript[J

line 900: [J

line 901: " Java Server Pages[J

line 902: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp[J

line 903: [J

line 904: " Java Properties resource file (note: doesn't catch font.properties.pl)[J

line 905: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties[J

line 906: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')[J

line 907: [J

line 908: " Jess[J

line 909: au BufNewFile,BufRead *.clp^I^I^Isetf jess[J

line 910: [J

line 911: " Jgraph[J

line 912: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph[J

line 913: [J

line 914: " Kixtart[J

line 915: au BufNewFile,BufRead *.kix^I^I^Isetf kix[J

line 916: [J

line 917: " Kimwitu[++][J

line 918: au BufNewFile,BufRead *.k^I^I^Isetf kwt[J

line 919: [J

line 920: " KDE script[J

line 921: au BufNewFile,BufRead *.ks^I^I^Isetf kscript[J

line 922: [J

line 923: " Kconfig[J

line 924: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig[J

line 925: [J

line 926: " Lace (ISE)[J

line 927: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace[J

line 928: [J

line 929: " Latte[J

line 930: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte[J

line 931: [J

line 932: " Limits[J

line 933: au BufNewFile,BufRead /etc/limits^I^Isetf limits[J

line 934: [J

line 935: " LambdaProlog (*.mod too, see Modsim)[J

line 936: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog[J

line 937: [J

line 938: " LDAP LDIF[J

line 939: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif[J

line 940: [J

line 941: " Ld loader[J

line 942: au BufNewFile,BufRead *.ld^I^I^Isetf ld[J

line 943: [J

line 944: " Lex[J

line 945: au BufNewFile,BufRead *.lex,*.l^I^I^Isetf lex[J

line 946: [J

line 947: " Libao[J

line 948: au BufNewFile,BufRead /etc/libao.conf,*/.libao^Isetf libao[J

line 949: [J

line 950: " Libsensors[J

line 951: au BufNewFile,BufRead /etc/sensors.conf^I^Isetf sensors[J

line 952: [J

line 953: " LFTP[J

line 954: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp[J

line 955: [J

line 956: " Lifelines (or Lex for C++!)[J

line 957: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines[J

line 958: [J

line 959: " Lilo: Linux loader[J

line 960: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')[J

line 961: [J

line 962: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)[J

line 963: if has("fname_case")[J

line 964:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp[J

line 965: else[J

line 966:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp[J

line 967: endif[J

line 968: [J

line 969: " SBCL implementation of Common Lisp[J

line 970: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp[J

line 971: [J

line 972: " Lite[J

line 973: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite[J

line 974: [J

line 975: " LiteStep RC files[J

line 976: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep[J

line 977: [J

line 978: " Login access[J

line 979: au BufNewFile,BufRead /etc/login.access^I^Isetf loginaccess[J

line 980: [J

line 981: " Login defs[J

line 982: au BufNewFile,BufRead /etc/login.defs^I^Isetf logindefs[J

line 983: [J

line 984: " Logtalk[J

line 985: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk[J

line 986: [J

line 987: " LOTOS[J

line 988: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos[J

line 989: [J

line 990: " Lout (also: *.lt)[J

line 991: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout[J

line 992: [J

line 993: " Lua[J

line 994: au BufNewFile,BufRead *.lua^I^I^Isetf lua[J

line 995: [J

line 996: " Linden Scripting Language (Second Life)[J

line 997: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl[J

line 998: [J

line 999: " Lynx style file (or LotusScript!)[J

line 1000: au BufNewFile,BufRead *.lss^I^I^Isetf lss[J

line 1001: [J

line 1002: " M4[J

line 1004: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif[J

line 1005: [J

line 1006: " MaGic Point[J

line 1007: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp[J

line 1008: [J

line 1009: " Mail (for Elm, trn, mutt, muttng, rn, slrn)[J

line 1010: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail[J

line 1011: [J

line 1012: " Mail aliases[J

line 1013: au BufNewFile,BufRead /etc/mail/aliases,/etc/aliases^Isetf mailaliases[J

line 1014: [J

line 1015: " Mailcap configuration file[J

line 1016: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap[J

line 1017: [J

line 1018: " Makefile[J

line 1019: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make[J

line 1020: [J

line 1021: " MakeIndex[J

line 1022: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist[J

line 1023: [J

line 1024: " Manpage[J

line 1025: au BufNewFile,BufRead *.man^I^I^Isetf man[J

line 1026: [J

line 1027: " Man config[J

line 1028: au BufNewFile,BufRead /etc/man.conf,man.config^Isetf manconf[J

line 1029: [J

line 1030: " Maple V[J

line 1031: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple[J

line 1032: [J

line 1033: " Map (UMN mapserver config file)[J

line 1034: au BufNewFile,BufRead *.map^I^I^Isetf map[J

line 1035: [J

line 1036: " Mason[J

line 1037: au BufNewFile,BufRead *.mason,*.mhtml^I^Isetf mason[J

line 1038: [J

line 1039: " Matlab or Objective C[J

line 1040: au BufNewFile,BufRead *.m^I^I^Icall s:FTm()[J

line 1041: [J

line 1042: func! s:FTm()[J

line 1066: [J

line 1067: " Mathematica notebook[J

line 1068: au BufNewFile,BufRead *.nb^I^I^Isetf mma[J

line 1069: [J

line 1070: " Maya Extension Language[J

line 1071: au BufNewFile,BufRead *.mel^I^I^Isetf mel[J

line 1072: [J

line 1073: " Messages[J

line 1074: au BufNewFile,BufRead /var/log/messages,/var/log/messages.*[0-9]  setf messages[J

line 1075: [J

line 1076: " Metafont[J

line 1077: au BufNewFile,BufRead *.mf^I^I^Isetf mf[J

line 1078: [J

line 1079: " MetaPost[J

line 1080: au BufNewFile,BufRead *.mp^I^I^Isetf mp[J

line 1081: [J

line 1082: " MGL[J

line 1083: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl[J

line 1084: [J

line 1085: " MMIX or VMS makefile[J

line 1086: au BufNewFile,BufRead *.mms^I^I^Icall s:FTmms()[J

line 1087: [J

line 1088: " Symbian meta-makefile definition (MMP)[J

line 1089: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp[J

line 1090: [J

line 1091: func! s:FTmms()[J

line 1107: [J

line 1108: [J

line 1109: " Modsim III (or LambdaProlog)[J

line 1115: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif[J

line 1116: [J

line 1117: " Modula 2[J

line 1118: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.md,*.mi setf modula2[J

line 1119: [J

line 1120: " Modula 3 (.m3, .i3, .mg, .ig)[J

line 1121: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3[J

line 1122: [J

line 1123: " Monk[J

line 1124: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk[J

line 1125: [J

line 1126: " MOO[J

line 1127: au BufNewFile,BufRead *.moo^I^I^Isetf moo[J

line 1128: [J

line 1129: " Modconf[J

line 1130: au BufNewFile,BufRead /etc/modules.conf,/etc/conf.modules^Isetf modconf[J

line 1134: au BufNewFile,BufRead /etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif[J

line 1135: [J

line 1136: " Mplayer config[J

line 1137: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf[J

line 1138: [J

line 1139: " Moterola S record[J

line 1140: au BufNewFile,BufRead *.s19,*.s28,*.s37^I^Isetf srec[J

line 1141: [J

line 1142: " Mrxvtrc[J

line 1143: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc[J

line 1144: [J

line 1145: " Msql[J

line 1146: au BufNewFile,BufRead *.msql^I^I^Isetf msql[J

line 1147: [J

line 1148: " Mysql[J

line 1149: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql[J

line 1150: [J

line 1151: " M$ Resource files[J

line 1152: au BufNewFile,BufRead *.rc^I^I^Isetf rc[J

line 1153: [J

line 1154: " MuPAD source[J

line 1155: au BufRead,BufNewFile *.mu^I^I^Isetf mupad[J

line 1156: [J

line 1157: " Mush[J

line 1158: au BufNewFile,BufRead *.mush^I^I^Isetf mush[J

line 1159: [J

line 1160: " Mutt setup file (also for Muttng)[J

line 1161: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc[J

line 1162: [J

line 1163: " Nano[J

line 1164: au BufNewFile,BufRead /etc/nanorc,.nanorc^Isetf nanorc[J

line 1165: [J

line 1166: " Nastran input/DMAP[J

line 1167: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran[J

line 1168: [J

line 1169: " Natural[J

line 1170: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural[J

line 1171: [J

line 1172: " Netrc[J

line 1173: au BufNewFile,BufRead .netrc^I^I^Isetf netrc[J

line 1174: [J

line 1175: " Novell netware batch files[J

line 1176: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf[J

line 1177: [J

line 1178: " Nroff/Troff (*.ms and *.t are checked below)[J

line 1182: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif[J

line 1183: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff[J

line 1184: au BufNewFile,BufRead *.[1-9]^I^I^Icall s:FTnroff()[J

line 1185: [J

line 1186: " This function checks if one of the first five lines start with a dot.  In[J

line 1187: " that case it is probably an nroff file: 'filetype' is set and 1 is returned.[J

line 1188: func! s:FTnroff()[J

line 1195: [J

line 1196: " Nroff or Objective C++[J

line 1197: au BufNewFile,BufRead *.mm^I^I^Icall s:FTmm()[J

line 1198: [J

line 1199: func! s:FTmm()[J

line 1211: [J

line 1212: " Not Quite C[J

line 1213: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc[J

line 1214: [J

line 1215: " NSIS[J

line 1216: au BufNewFile,BufRead *.nsi^I^I^Isetf nsis[J

line 1217: [J

line 1218: " OCAML[J

line 1219: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly^Isetf ocaml[J

line 1220: [J

line 1221: " Occam[J

line 1222: au BufNewFile,BufRead *.occ^I^I^Isetf occam[J

line 1223: [J

line 1224: " Omnimark[J

line 1225: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark[J

line 1226: [J

line 1227: " OpenROAD[J

line 1228: au BufNewFile,BufRead *.or^I^I^Isetf openroad[J

line 1229: [J

line 1230: " OPL[J

line 1231: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl[J

line 1232: [J

line 1233: " Oracle config file[J

line 1234: au BufNewFile,BufRead *.ora^I^I^Isetf ora[J

line 1235: [J

line 1236: " Packet filter conf[J

line 1237: au BufNewFile,BufRead pf.conf^I^I^Isetf pf[J

line 1238: [J

line 1239: " Pam conf[J

line 1240: au BufNewFile,BufRead /etc/pam.conf^I^Isetf pamconf[J

line 1241: [J

line 1242: " PApp[J

line 1243: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp[J

line 1244: [J

line 1245: " Password file[J

line 1246: au BufNewFile,BufRead /etc/passwd,/etc/passwd-,/etc/passwd.edit,/etc/shadow,/etc/shadow-,/var/backups/passwd.bak,/var/backups/shadow.bak setf passwd[J

line 1247: [J

line 1248: " Pascal (also *.p)[J

line 1249: au BufNewFile,BufRead *.pas^I^I^Isetf pascal[J

line 1250: [J

line 1251: " Delphi project file[J

line 1252: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal[J

line 1253: [J

line 1254: " PDF[J

line 1255: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf[J

line 1256: [J

line 1257: " Perl[J

line 1258: if has("fname_case")[J

line 1259:   au BufNewFile,BufRead *.pl,*.PL^I^Icall s:FTpl()[J

line 1260: else[J

line 1261:   au BufNewFile,BufRead *.pl^I^I^Icall s:FTpl()[J

line 1262: endif[J

line 1263: au BufNewFile,BufRead *.plx^I^I^Isetf perl[J

line 1264: [J

line 1265: func! s:FTpl()[J

line 1279: [J

line 1280: " Perl, XPM or XPM2[J

line 1288: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif[J

line 1289: [J

line 1290: " Perl POD[J

line 1291: au BufNewFile,BufRead *.pod^I^I^Isetf pod[J

line 1292: [J

line 1293: " Php, php3, php4, etc.[J

line 1294: " Also Phtml (was used for PHP 2 in the past)[J

line 1295: " Also .ctp for Cake template file[J

line 1296: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php[J

line 1297: [J

line 1298: " Pike[J

line 1299: au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike[J

line 1300: [J

line 1301: " Pinfo config[J

line 1302: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo[J

line 1303: [J

line 1304: " Palm Resource compiler[J

line 1305: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc[J

line 1306: [J

line 1307: " Pine config[J

line 1308: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine[J

line 1309: [J

line 1310: " PL/M (also: *.inp)[J

line 1311: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm[J

line 1312: [J

line 1313: " PL/SQL[J

line 1314: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql[J

line 1315: [J

line 1316: " PLP[J

line 1317: au BufNewFile,BufRead *.plp^I^I^Isetf plp[J

line 1318: [J

line 1319: " PO and PO template (GNU gettext)[J

line 1320: au BufNewFile,BufRead *.po,*.pot^I^Isetf po[J

line 1321: [J

line 1322: " Postfix main config[J

line 1323: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain[J

line 1324: [J

line 1325: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)[J

line 1326: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr[J

line 1327: [J

line 1328: " PostScript Printer Description[J

line 1329: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd[J

line 1330: [J

line 1331: " Povray[J

line 1332: au BufNewFile,BufRead *.pov^I^I^Isetf pov[J

line 1333: [J

line 1334: " Povray configuration[J

line 1335: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini[J

line 1336: [J

line 1337: " Povray, PHP or assembly[J

line 1338: au BufNewFile,BufRead *.inc^I^I^Icall s:FTinc()[J

line 1339: [J

line 1340: func! s:FTinc()[J

line 1361: [J

line 1362: " Printcap and Termcap[J

line 1364: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap[J

line 1366: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap[J

line 1367: [J

line 1368: " PCCTS / ANTRL[J

line 1369: "au BufNewFile,BufRead *.g^I^I^Isetf antrl[J

line 1370: au BufNewFile,BufRead *.g^I^I^Isetf pccts[J

line 1371: [J

line 1372: " PPWizard[J

line 1373: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz[J

line 1374: [J

line 1375: " Oracle Pro*C/C++[J

line 1376: au BufNewFile,BufRead *.pc^I^I^Isetf proc[J

line 1377: [J

line 1378: " Privoxy actions file[J

line 1379: au BufNewFile,BufRead *.action^I^I^Isetf privoxy[J

line 1380: [J

line 1381: " Procmail[J

line 1382: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail[J

line 1383: [J

line 1384: " Progress or CWEB[J

line 1385: au BufNewFile,BufRead *.w^I^I^Icall s:FTprogress_cweb()[J

line 1386: [J

line 1387: func! s:FTprogress_cweb()[J

line 1398: [J

line 1399: " Progress or assembly[J

line 1400: au BufNewFile,BufRead *.i^I^I^Icall s:FTprogress_asm()[J

line 1401: [J

line 1402: func! s:FTprogress_asm()[J

line 1424: [J

line 1425: " Progress or Pascal[J

line 1426: au BufNewFile,BufRead *.p^I^I^Icall s:FTprogress_pascal()[J

line 1427: [J

line 1428: func! s:FTprogress_pascal()[J

line 1452: [J

line 1453: [J

line 1454: " Software Distributor Product Specification File (POSIX 1387.2-1995)[J

line 1455: au BufNewFile,BufRead *.psf^I^I^Isetf psf[J

line 1459: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif[J

line 1460: [J

line 1461: " Prolog[J

line 1462: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog[J

line 1463: [J

line 1464: " Promela[J

line 1465: au BufNewFile,BufRead *.pml^I^I^Isetf promela[J

line 1466: [J

line 1467: " Protocols[J

line 1468: au BufNewFile,BufRead /etc/protocols^I^Isetf protocols[J

line 1469: [J

line 1470: " Pyrex[J

line 1471: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex[J

line 1472: [J

line 1473: " Python[J

line 1474: au BufNewFile,BufRead *.py,*.pyw^I^Isetf python[J

line 1475: [J

line 1476: " Quixote (Python-based web framework)[J

line 1477: au BufNewFile,BufRead *.ptl^I^I^Isetf python[J

line 1478: [J

line 1479: " Radiance[J

line 1480: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance[J

line 1481: [J

line 1482: " Ratpoison config/command files[J

line 1483: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison[J

line 1484: [J

line 1485: " RCS file[J

line 1486: au BufNewFile,BufRead *\,v^I^I^Isetf rcs[J

line 1487: [J

line 1488: " Readline[J

line 1489: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline[J

line 1490: [J

line 1491: " Registry for MS-Windows[J

line 1493: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif[J

line 1494: [J

line 1495: " Renderman Interface Bytestream[J

line 1496: au BufNewFile,BufRead *.rib^I^I^Isetf rib[J

line 1497: [J

line 1498: " Rexx[J

line 1499: au BufNewFile,BufRead *.rexx,*.rex,*.jrexx,*.rxj,*.orx^Isetf rexx[J

line 1500: [J

line 1501: " R (Splus)[J

line 1502: if has("fname_case")[J

line 1503:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r[J

line 1504: else[J

line 1505:   au BufNewFile,BufRead *.s^I^I^Isetf r[J

line 1506: endif[J

line 1507: [J

line 1508: " R Help file[J

line 1509: if has("fname_case")[J

line 1510:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp[J

line 1511: else[J

line 1512:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp[J

line 1513: endif[J

line 1514: [J

line 1515: " R noweb file[J

line 1516: if has("fname_case")[J

line 1517:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb[J

line 1518: else[J

line 1519:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb[J

line 1520: endif[J

line 1521: [J

line 1522: " Rexx, Rebol or R[J

line 1523: au BufNewFile,BufRead *.r,*.R^I^I^Icall s:FTr()[J

line 1524: [J

line 1525: func! s:FTr()[J

line 1552: [J

line 1553: " Remind[J

line 1554: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')[J

line 1555: [J

line 1556: " Resolv.conf[J

line 1557: au BufNewFile,BufRead resolv.conf^I^Isetf resolv[J

line 1558: [J

line 1559: " Relax NG Compact[J

line 1560: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc[J

line 1561: [J

line 1562: " RPL/2[J

line 1563: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl[J

line 1564: [J

line 1565: " Robots.txt[J

line 1566: au BufNewFile,BufRead robots.txt^I^Isetf robots[J

line 1567: [J

line 1568: " Rpcgen[J

line 1569: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen[J

line 1570: [J

line 1571: " reStructuredText Documentation Format[J

line 1572: au BufNewFile,BufRead *.rst^I^I^Isetf rst[J

line 1573: [J

line 1574: " RTF[J

line 1575: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf[J

line 1576: [J

line 1577: " Interactive Ruby shell[J

line 1578: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby[J

line 1579: [J

line 1580: " Ruby[J

line 1581: au BufNewFile,BufRead *.rb,*.rbw,*.gem,*.gemspec^Isetf ruby[J

line 1582: [J

line 1583: " Ruby on Rails[J

line 1584: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby[J

line 1585: [J

line 1586: " Rantfile and Rakefile is like Ruby[J

line 1587: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby[J

line 1588: [J

line 1589: " S-lang (or shader language!)[J

line 1590: au BufNewFile,BufRead *.sl^I^I^Isetf slang[J

line 1591: [J

line 1592: " Samba config[J

line 1593: au BufNewFile,BufRead smb.conf^I^I^Isetf samba[J

line 1594: [J

line 1595: " SAS script[J

line 1596: au BufNewFile,BufRead *.sas^I^I^Isetf sas[J

line 1597: [J

line 1598: " Sass[J

line 1599: au BufNewFile,BufRead *.sass^I^I^Isetf sass[J

line 1600: [J

line 1601: " Sather[J

line 1602: au BufNewFile,BufRead *.sa^I^I^Isetf sather[J

line 1603: [J

line 1604: " Scilab[J

line 1605: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab[J

line 1606: [J

line 1607: " SD: Streaming Descriptors[J

line 1608: au BufNewFile,BufRead *.sd^I^I^Isetf sd[J

line 1609: [J

line 1610: " SDL[J

line 1611: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl[J

line 1612: [J

line 1613: " sed[J

line 1614: au BufNewFile,BufRead *.sed^I^I^Isetf sed[J

line 1615: [J

line 1616: " Sieve (RFC 3028)[J

line 1617: au BufNewFile,BufRead *.siv^I^I^Isetf sieve[J

line 1618: [J

line 1619: " Sendmail[J

line 1620: au BufNewFile,BufRead sendmail.cf^I^Isetf sm[J

line 1621: [J

line 1622: " Sendmail .mc files are actually m4.  Could also be MS Message text file.[J

line 1623: au BufNewFile,BufRead *.mc^I^I^Icall s:McSetf()[J

line 1624: [J

line 1625: func! s:McSetf()[J

line 1640: [J

line 1641: " Services[J

line 1642: au BufNewFile,BufRead /etc/services^I^Isetf services[J

line 1643: [J

line 1644: " Service Location config[J

line 1645: au BufNewFile,BufRead /etc/slp.conf^I^Isetf slpconf[J

line 1646: [J

line 1647: " Service Location registration[J

line 1648: au BufNewFile,BufRead /etc/slp.reg^I^Isetf slpreg[J

line 1649: [J

line 1650: " Service Location SPI[J

line 1651: au BufNewFile,BufRead /etc/slp.spi^I^Isetf slpspi[J

line 1652: [J

line 1653: " Setserial config[J

line 1654: au BufNewFile,BufRead /etc/serial.conf^I^Isetf setserial[J

line 1655: [J

line 1656: " SGML[J

line 1665: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type="sgml" |   setf docbk | else |   setf sgml | endif[J

line 1666: [J

line 1667: " SGMLDECL[J

line 1671: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif[J

line 1672: [J

line 1673: " SGML catalog file[J

line 1674: au BufNewFile,BufRead catalog^I^I^Isetf catalog[J

line 1675: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')[J

line 1676: [J

line 1677: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.[J

line 1678: " Gentoo ebuilds are actually bash scripts[J

line 1679: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash_profile*,.bash_logout*,*.bash,*.ebuild call SetFileTypeSH("bash")[J

line 1680: au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")[J

line 1681: au BufNewFile,BufRead /etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))[J

line 1682: [J

line 1683: " Also called from scripts.vim.[J

line 1684: func! SetFileTypeSH(name)[J

line 1715: [J

line 1716: " For shell-like file types, check for an "exec" command hidden in a comment,[J

line 1717: " as used for Tcl.[J

line 1718: " Also called from scripts.vim, thus can't be local to this script.[J

line 1719: func! SetFileTypeShell(name)[J

line 1738: [J

line 1739: " tcsh scripts[J

line 1740: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall SetFileTypeShell("tcsh")[J

line 1741: [J

line 1742: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)[J

line 1743: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()[J

line 1744: [J

line 1745: func! s:CSH()[J

line 1754: [J

line 1755: " Z-Shell script[J

line 1756: au BufNewFile,BufRead .zprofile,/etc/zprofile,.zfbfmarks  setf zsh[J

line 1757: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')[J

line 1758: au BufNewFile,BufRead *.zsh ^I^I^Isetf zsh[J

line 1759: [J

line 1760: " Scheme[J

line 1761: au BufNewFile,BufRead *.scm,*.ss^I^Isetf scheme[J

line 1762: [J

line 1763: " Screen RC[J

line 1764: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen[J

line 1765: [J

line 1766: " Simula[J

line 1767: au BufNewFile,BufRead *.sim^I^I^Isetf simula[J

line 1768: [J

line 1769: " SINDA[J

line 1770: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda[J

line 1771: [J

line 1772: " SiSU[J

line 1773: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu[J

line 1774: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu[J

line 1775: [J

line 1776: " SKILL[J

line 1777: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill[J

line 1778: [J

line 1779: " SLRN[J

line 1780: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc[J

line 1781: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc[J

line 1782: [J

line 1783: " Smalltalk (and TeX)[J

line 1784: au BufNewFile,BufRead *.st^I^I^Isetf st[J

line 1790: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | else |  setf st | endif[J

line 1791: [J

line 1792: " Smarty templates[J

line 1793: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty[J

line 1794: [J

line 1795: " SMIL or XML[J

line 1801: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif[J

line 1802: [J

line 1803: " SMIL or SNMP MIB file[J

line 1809: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif[J

line 1810: [J

line 1811: " SMITH[J

line 1812: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith[J

line 1813: [J

line 1814: " Snobol4 and spitbol[J

line 1815: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4[J

line 1816: [J

line 1817: " SNMP MIB files[J

line 1818: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib[J

line 1819: [J

line 1820: " Snort Configuration[J

line 1821: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog[J

line 1822: au BufNewFile,BufRead *.rules^I^I^Icall s:FTRules()[J

line 1823: [J

line 1824: let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'[J

line 1825: func! s:FTRules()[J

line 1848: [J

line 1849: [J

line 1850: " Spec (Linux RPM)[J

line 1851: au BufNewFile,BufRead *.spec^I^I^Isetf spec[J

line 1852: [J

line 1853: " Speedup (AspenTech plant simulator)[J

line 1854: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup[J

line 1855: [J

line 1856: " Slice[J

line 1857: au BufNewFile,BufRead *.ice^I^I^Isetf slice[J

line 1858: [J

line 1859: " Spice[J

line 1860: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice[J

line 1861: [J

line 1862: " Spyce[J

line 1863: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce[J

line 1864: [J

line 1865: " Squid[J

line 1866: au BufNewFile,BufRead squid.conf^I^Isetf squid[J

line 1867: [J

line 1868: " SQL for Oracle Designer[J

line 1869: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql[J

line 1870: [J

line 1871: " SQL[J

line 1872: au BufNewFile,BufRead *.sql^I^I^Icall s:SQL()[J

line 1873: [J

line 1874: func! s:SQL()[J

line 1881: [J

line 1882: " SQLJ[J

line 1883: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj[J

line 1884: [J

line 1885: " SQR[J

line 1886: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr[J

line 1887: [J

line 1888: " OpenSSH configuration[J

line 1889: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig[J

line 1890: [J

line 1891: " OpenSSH server configuration[J

line 1892: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig[J

line 1893: [J

line 1894: " Stata[J

line 1895: au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata[J

line 1896: [J

line 1897: " SMCL[J

line 1898: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl[J

line 1899: [J

line 1900: " Stored Procedures[J

line 1901: au BufNewFile,BufRead *.stp^I^I^Isetf stp[J

line 1902: [J

line 1903: " Standard ML[J

line 1904: au BufNewFile,BufRead *.sml^I^I^Isetf sml[J

line 1905: [J

line 1906: " Sratus VOS command macro[J

line 1907: au BufNewFile,BufRead *.cm^I^I^Isetf voscm[J

line 1908: [J

line 1909: " Sysctl[J

line 1910: au BufNewFile,BufRead /etc/sysctl.conf^I^Isetf sysctl[J

line 1911: [J

line 1912: " Sudoers[J

line 1913: au BufNewFile,BufRead /etc/sudoers,sudoers.tmp^Isetf sudoers[J

line 1914: [J

line 1915: " If the file has an extension of 't' and is in a directory 't' then it is[J

line 1916: " almost certainly a Perl test file.[J

line 1917: " If the first line starts with '#' and contains 'perl' it's probably a Perl[J

line 1918: " file.[J

line 1919: " (Slow test) If a file contains a 'use' statement then it is almost certainly[J

line 1920: " a Perl file.[J

line 1921: func! s:FTperl()[J

line 1936: [J

line 1937: " Tads (or Nroff or Perl test file)[J

line 1939: au BufNewFile,BufRead *.t if !s:FTnroff() && !s:FTperl() | setf tads | endif[J

line 1940: [J

line 1941: " Tags[J

line 1942: au BufNewFile,BufRead tags^I^I^Isetf tags[J

line 1943: [J

line 1944: " TAK[J

line 1945: au BufNewFile,BufRead *.tak^I^I^Isetf tak[J

line 1946: [J

line 1947: " Tcl (JACL too)[J

line 1948: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl[J

line 1949: [J

line 1950: " TealInfo[J

line 1951: au BufNewFile,BufRead *.tli^I^I^Isetf tli[J

line 1952: [J

line 1953: " Telix Salt[J

line 1954: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt[J

line 1955: [J

line 1956: " Terminfo[J

line 1957: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo[J

line 1958: [J

line 1959: " TeX[J

line 1960: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex[J

line 1961: au BufNewFile,BufRead *.tex^I^I^Icall s:FTtex()[J

line 1962: [J

line 1963: " Choose context, plaintex, or tex (LaTeX) based on these rules:[J

line 1964: " 1. Check the first line of the file for "%&<format>".[J

line 1965: " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.[J

line 1966: " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.[J

line 1967: func! s:FTtex()[J

line 2014: [J

line 2015: " ConTeXt[J

line 2016: au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context[J

line 2017: [J

line 2018: " Texinfo[J

line 2019: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo[J

line 2020: [J

line 2021: " TeX configuration[J

line 2022: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf[J

line 2023: [J

line 2024: " Tidy config[J

line 2025: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy[J

line 2026: [J

line 2027: " TF mud client[J

line 2028: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf[J

line 2029: [J

line 2030: " TPP - Text Presentation Program[J

line 2031: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp[J

line 2032: [J

line 2033: " Trustees[J

line 2034: au BufNewFile,BufRead trustees.conf^I^Isetf trustees[J

line 2035: [J

line 2036: " TSS - Geometry[J

line 2037: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm[J

line 2038: [J

line 2039: " TSS - Optics[J

line 2040: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop[J

line 2041: [J

line 2042: " TSS - Command Line (temporary)[J

line 2043: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl[J

line 2044: [J

line 2045: " Motif UIT/UIL files[J

line 2046: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil[J

line 2047: [J

line 2048: " Udev conf[J

line 2049: au BufNewFile,BufRead /etc/udev/udev.conf^Isetf udevconf[J

line 2050: [J

line 2051: " Udev permissions[J

line 2052: au BufNewFile,BufRead /etc/udev/permissions.d/*.permissions setf udevperm[J

line 2053: "[J

line 2054: " Udev symlinks config[J

line 2055: au BufNewFile,BufRead /etc/udev/cdsymlinks.conf^Isetf sh[J

line 2056: [J

line 2057: " UnrealScript[J

line 2058: au BufNewFile,BufRead *.uc^I^I^Isetf uc[J

line 2059: [J

line 2060: " Updatedb[J

line 2061: au BufNewFile,BufRead /etc/updatedb.conf^Isetf updatedb[J

line 2062: [J

line 2063: " Vera[J

line 2064: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera[J

line 2065: [J

line 2066: " Verilog HDL[J

line 2067: au BufNewFile,BufRead *.v^I^I^Isetf verilog[J

line 2068: [J

line 2069: " Verilog-AMS HDL[J

line 2070: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams[J

line 2071: [J

line 2072: " VHDL[J

line 2073: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl[J

line 2074: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')[J

line 2075: [J

line 2076: " Vim script[J

line 2077: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim[J

line 2078: [J

line 2079: " Viminfo file[J

line 2080: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo[J

line 2081: [J

line 2082: " Virata Config Script File[J

line 2083: au BufRead,BufNewFile *.hw,*.module,*.pkg^Isetf virata[J

line 2084: [J

line 2085: " Visual Basic (also uses *.bas) or FORM[J

line 2086: au BufNewFile,BufRead *.frm^I^I^Icall s:FTVB("form")[J

line 2087: [J

line 2088: " SaxBasic is close to Visual Basic[J

line 2089: au BufNewFile,BufRead *.sba^I^I^Isetf vb[J

line 2090: [J

line 2091: " Vgrindefs file[J

line 2092: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs[J

line 2093: [J

line 2094: " VRML V1.0c[J

line 2095: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml[J

line 2096: [J

line 2097: " Webmacro[J

line 2098: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro[J

line 2099: [J

line 2100: " Wget config[J

line 2101: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget[J

line 2102: [J

line 2103: " Website MetaLanguage[J

line 2104: au BufNewFile,BufRead *.wml^I^I^Isetf wml[J

line 2105: [J

line 2106: " Winbatch[J

line 2107: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch[J

line 2108: [J

line 2109: " WSML[J

line 2110: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml[J

line 2111: [J

line 2112: " WvDial[J

line 2113: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial[J

line 2114: [J

line 2115: " CVS RC file[J

line 2116: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc[J

line 2117: [J

line 2118: " CVS commit file[J

line 2119: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs[J

line 2120: [J

line 2121: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment[J

line 2122: " lines in a WEB file).[J

line 2128: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif[J

line 2129: [J

line 2130: " Windows Scripting Host and Windows Script Component[J

line 2131: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh[J

line 2132: [J

line 2133: " XHTML[J

line 2134: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml[J

line 2135: [J

line 2136: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)[J

line 2142: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif[J

line 2143: au BufEnter *.xpm2^I^I^I^Isetf xpm2[J

line 2144: [J

line 2145: " XFree86 config[J

line 2150: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86c_xfree86_version = 3 | endif | setf xf86conf[J

line 2151: [J

line 2152: " Xorg config[J

line 2153: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86c_xfree86_version = 4 | setf xf86conf[J

line 2154: [J

line 2155: " Xinetd conf[J

line 2156: au BufNewFile,BufRead /etc/xinetd.conf^I^Isetf xinetd[J

line 2157: [J

line 2158: " XS Perl extension interface language[J

line 2159: au BufNewFile,BufRead *.xs^I^I^Isetf xs[J

line 2160: [J

line 2161: " X resources file[J

line 2162: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults[J

line 2163: [J

line 2164: " Xmath[J

line 2165: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath[J

line 2167: au BufNewFile,BufRead *.ms if !s:FTnroff() | setf xmath | endif[J

line 2168: [J

line 2169: " XML  specific variants: docbk and xbl[J

line 2170: au BufNewFile,BufRead *.xml^I^I^Icall s:FTxml()[J

line 2171: [J

line 2172: func! s:FTxml()[J

line 2189: [J

line 2190: " XMI (holding UML models) is also XML[J

line 2191: au BufNewFile,BufRead *.xmi^I^I^Isetf xml[J

line 2192: [J

line 2193: " CSPROJ files are Visual Studio.NET's XML-based project config files[J

line 2194: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml[J

line 2195: [J

line 2196: " Qt Linguist translation source and Qt User Interface Files are XML[J

line 2197: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml[J

line 2198: [J

line 2199: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)[J

line 2200: au BufNewFile,BufRead *.tpm^I^I^Isetf xml[J

line 2201: [J

line 2202: " Xdg menus[J

line 2203: au BufNewFile,BufRead /etc/xdg/menus/*.menu^Isetf xml[J

line 2204: [J

line 2205: " ATI graphics driver configuration[J

line 2206: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml[J

line 2207: [J

line 2208: " XLIFF (XML Localisation Interchange File Format) is also XML[J

line 2209: au BufNewFile,BufRead *.xlf^I^I^Isetf xml[J

line 2210: au BufNewFile,BufRead *.xliff^I^I^Isetf xml[J

line 2211: [J

line 2212: " X11 xmodmap (also see below)[J

line 2213: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap[J

line 2214: [J

line 2215: " Xquery[J

line 2216: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery[J

line 2217: [J

line 2218: " XSD[J

line 2219: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd[J

line 2220: [J

line 2221: " Xslt[J

line 2222: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt[J

line 2223: [J

line 2224: " Yacc[J

line 2225: au BufNewFile,BufRead *.yy^I^I^Isetf yacc[J

line 2226: [J

line 2227: " Yacc or racc[J

line 2228: au BufNewFile,BufRead *.y^I^I^Icall s:FTy()[J

line 2229: [J

line 2230: func! s:FTy()[J

line 2246: [J

line 2247: [J

line 2248: " Yaml[J

line 2249: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml[J

line 2250: [J

line 2251: " Zope[J

line 2252: "   dtml (zope dynamic template markup language), pt (zope page template),[J

line 2253: "   cpt (zope form controller page template)[J

line 2254: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall s:FThtml()[J

line 2255: "   zsql (zope sql method)[J

line 2256: au BufNewFile,BufRead *.zsql^I^I^Icall s:SQL()[J

line 2257: [J

line 2258: " Z80 assembler asz80[J

line 2259: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a[J

line 2260: [J

line 2261: augroup END[J

line 2262: [J

line 2263: [J

line 2264: " Source the user-specified filetype file, for backwards compatibility with[J

line 2265: " Vim 5.x.[J

line 2266: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))[J

line 2267:   execute "source " . myfiletypefile[J

line 2268: endif[J

line 2269: [J

line 2270: [J

line 2271: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used[J

line 2272: " when there are no matching file name extensions.[J

line 2273: " Don't do this for compressed files.[J

line 2274: augroup filetypedetect[J

line 2277: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif[J

line 2278: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif[J

line 2279: [J

line 2280: [J

line 2281: " Extra checks for when no filetype has been detected now.  Mostly used for[J

line 2282: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim[J

line 2283: " script file.[J

line 2284: " Most of these should call s:StarSetf() to avoid names ending in .gz and the[J

line 2285: " like are used.[J

line 2286: [J

line 2287: " More Apache files.[J

line 2288: au BufNewFile,BufRead /etc/apache2/conf.*/*,/etc/apache2/sites-*/*,/etc/apache2/mods-*/*^I^Icall s:StarSetf('apache')[J

line 2289: [J

line 2290: " Asterisk config file[J

line 2291: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')[J

line 2292: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')[J

line 2293: [J

line 2294: " Bazaar version control[J

line 2295: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr[J

line 2296: [J

line 2297: " BIND zone[J

line 2298: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')[J

line 2299: [J

line 2300: " Changelog[J

line 2306: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif[J

line 2307: [J

line 2308: " Crontab[J

line 2309: au BufNewFile,BufRead crontab,crontab.*,/etc/cron.d/*^I^Icall s:StarSetf('crontab')[J

line 2310: [J

line 2311: " Debian Sources.list[J

line 2312: au BufNewFile,BufRead /etc/apt/sources.list.d/*^Icall s:StarSetf('debsources')[J

line 2313: [J

line 2314: " Dracula[J

line 2315: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')[J

line 2316: [J

line 2317: " Fvwm[J

line 2318: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')[J

line 2320: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')[J

line 2326: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif[J

line 2327: [J

line 2328: " GTK RC[J

line 2329: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')[J

line 2330: [J

line 2331: " Jam[J

line 2332: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')[J

line 2333: [J

line 2334: " Jargon[J

line 2338: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif[J

line 2339: [J

line 2340: " Kconfig[J

line 2341: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')[J

line 2342: [J

line 2343: " Makefile[J

line 2344: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')[J

line 2345: [J

line 2346: " Ruby Makefile[J

line 2347: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')[J

line 2348: [J

line 2349: " Mail (also matches muttrc.vim, so this is below the other checks)[J

line 2350: au BufNewFile,BufRead mutt[[:alnum:]._-]\{6\}^Isetf mail[J

line 2351: [J

line 2352: " Modconf[J

line 2353: au BufNewFile,BufRead /etc/modprobe.*^I^Icall s:StarSetf('modconf')[J

line 2354: [J

line 2355: " Mutt setup file[J

line 2356: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')[J

line 2357: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')[J

line 2358: [J

line 2359: " Nroff macros[J

line 2360: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')[J

line 2361: [J

line 2362: " Pam conf[J

line 2363: au BufNewFile,BufRead /etc/pam.d/*^I^Icall s:StarSetf('pamconf')[J

line 2364: [J

line 2365: " Printcap and Termcap[J

line 2369: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif[J

line 2373: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif[J

line 2374: [J

line 2375: " Vim script[J

line 2376: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')[J

line 2377: [J

line 2378: " Subversion commit file[J

line 2379: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn[J

line 2380: [J

line 2381: " X resources file[J

line 2382: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')[J

line 2383: [J

line 2384: " XFree86 config[J

line 2386: au BufNewFile,BufRead XF86Config-4* let b:xf86c_xfree86_version = 4 | call s:StarSetf('xf86conf')[J

line 2391: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86c_xfree86_version = 3|endif|call s:StarSetf('xf86conf')[J

line 2392: [J

line 2393: " X11 xmodmap[J

line 2394: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')[J

line 2395: [J

line 2396: " Xinetd conf[J

line 2397: au BufNewFile,BufRead /etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')[J

line 2398: [J

line 2399: " Z-Shell script[J

line 2400: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')[J

line 2401: [J

line 2402: [J

line 2403: " Generic configuration file (check this last, it's just guessing!)[J

line 2409: au BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf conf | endif[J

line 2410: [J

line 2411: " Use the plugin-filetype checks last, they may overrule any of the previously[J

line 2412: " detected filetypes.[J

line 2413: runtime! ftdetect/*.vim[J

Searching for "ftdetect/*.vim" in "/Users/Eric/.vim,/Users/Eric/.vim/bundle/align,/Users/Eric/.vim/bundle/command-t,/Users/Eric/.vim/bundle/gist,/Users/Eric/.vim/bundle/nerdcommenter,/Users/Eric/.vim/bundle/nerdtree,/Users/Eric/.vim/bundle/snipmate,/Users/Eric/.vim/bundle/vim-abolish,/Users/Eric/.vim/bundle/vim-cucumber,/Users/Eric/.vim/bundle/vim-endwise,/Users/Eric/.vim/bundle/vim-fugitive,/Users/Eric/.vim/bundle/vim-git,/Users/Eric/.vim/bundle/vim-markdown-preview,/Users/Eric/.vim/bundle/vim-pastie,/Users/Eric/.vim/bundle/vim-rails,/Users/Eric/.vim/bundle/vim-repeat,/Users/Eric/.vim/bundle/vim-rspec,/Users/Eric/.vim/bundle/vim-surround,/Users/Eric/.vim/bundle/vim-unimpaired,/usr/share/vim/vimfiles,/usr/share/vim/vim72,/usr/share/vim/vimfiles/after,/Users/Eric/.vim/bundle/snipmate/after,/Users/Eric/.vim/after"[J
Searching for "/Users/Eric/.vim/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/align/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/command-t/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/gist/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/nerdcommenter/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/nerdtree/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/snipmate/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-abolish/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-cucumber/ftdetect/*.vim"[J
line 2413: sourcing "/Users/Eric/.vim/bundle/vim-cucumber/ftdetect/cucumber.vim"[J
line 1: " Cucumber[J

line 2: autocmd BufNewFile,BufReadPost *.feature,*.story set filetype=cucumber[J

finished sourcing /Users/Eric/.vim/bundle/vim-cucumber/ftdetect/cucumber.vim[J
continuing in /usr/share/vim/vim72/filetype.vim[J
Searching for "/Users/Eric/.vim/bundle/vim-endwise/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-fugitive/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-git/ftdetect/*.vim"[J
line 2413: sourcing "/Users/Eric/.vim/bundle/vim-git/ftdetect/git.vim"[J
line 1: " Git[J

line 2: autocmd BufNewFile,BufRead *.git/COMMIT_EDITMSG                set ft=gitcommit[J

line 3: autocmd BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules set ft=gitconfig[J

line 4: autocmd BufNewFile,BufRead git-rebase-todo                     set ft=gitrebase[J

line 8: autocmd BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   set ft=gitsendemail | endif[J

line 12: autocmd BufNewFile,BufRead *.git/** if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   set ft=git | endif[J

line 13: [J

line 14: " This logic really belongs in scripts.vim[J

line 18: autocmd BufNewFile,BufRead,StdinReadPost * if getline(1) =~ '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$' |   set ft=git | endif[J

finished sourcing /Users/Eric/.vim/bundle/vim-git/ftdetect/git.vim[J
continuing in /usr/share/vim/vim72/filetype.vim[J
Searching for "/Users/Eric/.vim/bundle/vim-markdown-preview/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-pastie/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-rails/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-repeat/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-rspec/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-surround/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-unimpaired/ftdetect/*.vim"[J
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"[J
Searching for "/usr/share/vim/vim72/ftdetect/*.vim"[J
Searching for "/usr/share/vim/vimfiles/after/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/snipmate/after/ftdetect/*.vim"[J
Searching for "/Users/Eric/.vim/after/ftdetect/*.vim"[J
line 2414: [J

line 2415: augroup END[J

line 2416: [J

line 2417: [J

line 2418: " If the GUI is already running, may still need to install the Syntax menu.[J

line 2419: " Don't do it when the 'M' flag is included in 'guioptions'.[J

line 2421: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"[J

line 2422:   source <sfile>:p:h/menu.vim[J

line 2423: endif[J

line 2424: [J

line 2425: " Function called for testing all functions defined here.  These are[J

line 2426: " script-local, thus need to be executed here.[J

line 2427: " Returns a string with error messages (hopefully empty).[J

line 2428: func! TestFiletypeFuncs(testlist)[J

line 2439: [J

line 2440: " Restore 'cpoptions'[J

line 2441: let &cpo = s:cpo_save[J

line 2442: unlet s:cpo_save[J

finished sourcing /usr/share/vim/vim72/filetype.vim[J
continuing in /Users/Eric/.vimrc[J
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"[J
Searching for "/Users/Eric/.vim/bundle/snipmate/after/filetype.vim"[J
Searching for "/Users/Eric/.vim/after/filetype.vim"[J
Searching for "ftplugin.vim" in "/Users/Eric/.vim,/Users/Eric/.vim/bundle/align,/Users/Eric/.vim/bundle/command-t,/Users/Eric/.vim/bundle/gist,/Users/Eric/.vim/bundle/nerdcommenter,/Users/Eric/.vim/bundle/nerdtree,/Users/Eric/.vim/bundle/snipmate,/Users/Eric/.vim/bundle/vim-abolish,/Users/Eric/.vim/bundle/vim-cucumber,/Users/Eric/.vim/bundle/vim-endwise,/Users/Eric/.vim/bundle/vim-fugitive,/Users/Eric/.vim/bundle/vim-git,/Users/Eric/.vim/bundle/vim-markdown-preview,/Users/Eric/.vim/bundle/vim-pastie,/Users/Eric/.vim/bundle/vim-rails,/Users/Eric/.vim/bundle/vim-repeat,/Users/Eric/.vim/bundle/vim-rspec,/Users/Eric/.vim/bundle/vim-surround,/Users/Eric/.vim/bundle/vim-unimpaired,/usr/share/vim/vimfiles,/usr/share/vim/vim72,/usr/share/vim/vimfiles/after,/Users/Eric/.vim/bundle/snipmate/after,/Users/Eric/.vim/after"[J
Searching for "/Users/Eric/.vim/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/align/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/command-t/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/gist/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/nerdcommenter/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/nerdtree/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/snipmate/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-abolish/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-cucumber/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-endwise/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-fugitive/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-git/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-markdown-preview/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-pastie/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-rails/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-repeat/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-rspec/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-surround/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-unimpaired/ftplugin.vim"[J
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"[J
Searching for "/usr/share/vim/vim72/ftplugin.vim"[J
line 7: sourcing "/usr/share/vim/vim72/ftplugin.vim"[J
line 1: " Vim support file to switch on loading plugins for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last change:^I2006 Apr 30[J

line 5: [J

line 6: if exists("did_load_ftplugin")[J

line 7:   finish[J

line 8: endif[J

line 9: let did_load_ftplugin = 1[J

line 10: [J

line 11: augroup filetypeplugin[J

line 12:   au FileType * call s:LoadFTPlugin()[J

line 13: [J

line 14:   func! s:LoadFTPlugin()[J

line 35: augroup END[J

finished sourcing /usr/share/vim/vim72/ftplugin.vim[J
continuing in /Users/Eric/.vimrc[J
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/bundle/snipmate/after/ftplugin.vim"[J
Searching for "/Users/Eric/.vim/after/ftplugin.vim"[J
Searching for "indent.vim" in "/Users/Eric/.vim,/Users/Eric/.vim/bundle/align,/Users/Eric/.vim/bundle/command-t,/Users/Eric/.vim/bundle/gist,/Users/Eric/.vim/bundle/nerdcommenter,/Users/Eric/.vim/bundle/nerdtree,/Users/Eric/.vim/bundle/snipmate,/Users/Eric/.vim/bundle/vim-abolish,/Users/Eric/.vim/bundle/vim-cucumber,/Users/Eric/.vim/bundle/vim-endwise,/Users/Eric/.vim/bundle/vim-fugitive,/Users/Eric/.vim/bundle/vim-git,/Users/Eric/.vim/bundle/vim-markdown-preview,/Users/Eric/.vim/bundle/vim-pastie,/Users/Eric/.vim/bundle/vim-rails,/Users/Eric/.vim/bundle/vim-repeat,/Users/Eric/.vim/bundle/vim-rspec,/Users/Eric/.vim/bundle/vim-surround,/Users/Eric/.vim/bundle/vim-unimpaired,/usr/share/vim/vimfiles,/usr/share/vim/vim72,/usr/share/vim/vimfiles/after,/Users/Eric/.vim/bundle/snipmate/after,/Users/Eric/.vim/after"[J
Searching for "/Users/Eric/.vim/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/align/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/command-t/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/gist/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/nerdcommenter/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/nerdtree/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/snipmate/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-abolish/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-cucumber/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-endwise/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-fugitive/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-git/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-markdown-preview/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-pastie/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-rails/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-repeat/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-rspec/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-surround/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-unimpaired/indent.vim"[J
Searching for "/usr/share/vim/vimfiles/indent.vim"[J
Searching for "/usr/share/vim/vim72/indent.vim"[J
line 7: sourcing "/usr/share/vim/vim72/indent.vim"[J
line 1: " Vim support file to switch on loading indent files for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2008 Feb 22[J

line 5: [J

line 6: if exists("did_indent_on")[J

line 7:   finish[J

line 8: endif[J

line 9: let did_indent_on = 1[J

line 10: [J

line 11: augroup filetypeindent[J

line 12:   au FileType * call s:LoadIndent()[J

line 13:   func! s:LoadIndent()[J

line 31: augroup END[J

finished sourcing /usr/share/vim/vim72/indent.vim[J
continuing in /Users/Eric/.vimrc[J
Searching for "/usr/share/vim/vimfiles/after/indent.vim"[J
Searching for "/Users/Eric/.vim/bundle/snipmate/after/indent.vim"[J
Searching for "/Users/Eric/.vim/after/indent.vim"[J
line 8: [J

line 9: [J

line 10: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 11: " => General[J

line 12: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 13: let mapleader = ","[J

line 14: "let g:mapleader = ","[J

line 15: [J

line 16: set nocompatible[J

line 17: "color made_of_code[J

line 18: syntax on[J

line 18: so $VIMRUNTIME/syntax/syntax.vim[J

line 18: sourcing "/usr/share/vim/vim72/syntax/syntax.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 04[J

line 4: [J

line 5: " This file is used for ":syntax on".[J

line 6: " It installs the autocommands and starts highlighting for all buffers.[J

line 7: [J

line 8: if !has("syntax")[J

line 9:   finish[J

line 10: endif[J

line 11: [J

line 12: " If Syntax highlighting appears to be on already, turn it off first, so that[J

line 13: " any leftovers are cleared.[J

line 14: if exists("syntax_on") || exists("syntax_manual")[J

line 15:   so <sfile>:p:h/nosyntax.vim[J

line 16: endif[J

line 17: [J

line 18: " Load the Syntax autocommands and set the default methods for highlighting.[J

line 19: runtime syntax/synload.vim[J

Searching for "syntax/synload.vim" in "/Users/Eric/.vim,/Users/Eric/.vim/bundle/align,/Users/Eric/.vim/bundle/command-t,/Users/Eric/.vim/bundle/gist,/Users/Eric/.vim/bundle/nerdcommenter,/Users/Eric/.vim/bundle/nerdtree,/Users/Eric/.vim/bundle/snipmate,/Users/Eric/.vim/bundle/vim-abolish,/Users/Eric/.vim/bundle/vim-cucumber,/Users/Eric/.vim/bundle/vim-endwise,/Users/Eric/.vim/bundle/vim-fugitive,/Users/Eric/.vim/bundle/vim-git,/Users/Eric/.vim/bundle/vim-markdown-preview,/Users/Eric/.vim/bundle/vim-pastie,/Users/Eric/.vim/bundle/vim-rails,/Users/Eric/.vim/bundle/vim-repeat,/Users/Eric/.vim/bundle/vim-rspec,/Users/Eric/.vim/bundle/vim-surround,/Users/Eric/.vim/bundle/vim-unimpaired,/usr/share/vim/vimfiles,/usr/share/vim/vim72,/usr/share/vim/vimfiles/after,/Users/Eric/.vim/bundle/snipmate/after,/Users/Eric/.vim/after"[J
Searching for "/Users/Eric/.vim/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/align/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/command-t/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/gist/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/nerdcommenter/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/nerdtree/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/snipmate/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-abolish/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-cucumber/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-endwise/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-fugitive/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-git/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-markdown-preview/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-pastie/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-rails/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-repeat/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-rspec/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-surround/syntax/synload.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-unimpaired/syntax/synload.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"[J
Searching for "/usr/share/vim/vim72/syntax/synload.vim"[J
line 19: sourcing "/usr/share/vim/vim72/syntax/synload.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2006 Apr 30[J

line 4: [J

line 5: " This file sets up for syntax highlighting.[J

line 6: " It is loaded from "syntax.vim" and "manual.vim".[J

line 7: " 1. Set the default highlight groups.[J

line 8: " 2. Install Syntax autocommands for all the available syntax files.[J

line 9: [J

line 10: if !has("syntax")[J

line 11:   finish[J

line 12: endif[J

line 13: [J

line 14: " let others know that syntax has been switched on[J

line 15: let syntax_on = 1[J

line 16: [J

line 17: " Set the default highlighting colors.  Use a color scheme if specified.[J

line 18: if exists("colors_name")[J

line 19:   exe "colors " . colors_name[J

line 20: else[J

line 21:   runtime! syntax/syncolor.vim[J

Searching for "syntax/syncolor.vim" in "/Users/Eric/.vim,/Users/Eric/.vim/bundle/align,/Users/Eric/.vim/bundle/command-t,/Users/Eric/.vim/bundle/gist,/Users/Eric/.vim/bundle/nerdcommenter,/Users/Eric/.vim/bundle/nerdtree,/Users/Eric/.vim/bundle/snipmate,/Users/Eric/.vim/bundle/vim-abolish,/Users/Eric/.vim/bundle/vim-cucumber,/Users/Eric/.vim/bundle/vim-endwise,/Users/Eric/.vim/bundle/vim-fugitive,/Users/Eric/.vim/bundle/vim-git,/Users/Eric/.vim/bundle/vim-markdown-preview,/Users/Eric/.vim/bundle/vim-pastie,/Users/Eric/.vim/bundle/vim-rails,/Users/Eric/.vim/bundle/vim-repeat,/Users/Eric/.vim/bundle/vim-rspec,/Users/Eric/.vim/bundle/vim-surround,/Users/Eric/.vim/bundle/vim-unimpaired,/usr/share/vim/vimfiles,/usr/share/vim/vim72,/usr/share/vim/vimfiles/after,/Users/Eric/.vim/bundle/snipmate/after,/Users/Eric/.vim/after"[J
Searching for "/Users/Eric/.vim/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/align/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/command-t/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/gist/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/nerdcommenter/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/nerdtree/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/snipmate/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-abolish/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-cucumber/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-endwise/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-fugitive/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-git/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-markdown-preview/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-pastie/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-rails/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-repeat/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-rspec/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-surround/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-unimpaired/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim72/syntax/syncolor.vim"[J
line 21: sourcing "/usr/share/vim/vim72/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim72/syntax/syncolor.vim[J
continuing in /usr/share/vim/vim72/syntax/synload.vim[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/bundle/snipmate/after/syntax/syncolor.vim"[J
Searching for "/Users/Eric/.vim/after/syntax/syncolor.vim"[J
line 22: endif[J

line 23: [J

line 24: " Line continuation is used here, remove 'C' from 'cpoptions'[J

line 25: let s:cpo_save = &cpo[J

line 26: set cpo&vim[J

line 27: [J

line 28: " First remove all old syntax autocommands.[J

line 29: au! Syntax[J

line 30: [J

line 31: au Syntax *^I^Icall s:SynSet()[J

line 32: [J

line 33: fun! s:SynSet()[J

line 59: [J

line 60: [J

line 61: " Handle adding doxygen to other languages (C, C++, IDL)[J

line 66: au Syntax cpp,c,idl if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif[J

line 67: [J

line 68: [J

line 69: " Source the user-specified syntax highlighting file[J

line 70: if exists("mysyntaxfile") && filereadable(expand(mysyntaxfile))[J

line 71:   execute "source " . mysyntaxfile[J

line 72: endif[J

line 73: [J

line 74: " Restore 'cpoptions'[J

line 75: let &cpo = s:cpo_save[J

line 76: unlet s:cpo_save[J

finished sourcing /usr/share/vim/vim72/syntax/synload.vim[J
continuing in /usr/share/vim/vim72/syntax/syntax.vim[J
line 20: [J

line 21: " Load the FileType autocommands if not done yet.[J

line 22: if exists("did_load_filetypes")[J

line 23:   let s:did_ft = 1[J

line 24: else[J

line 25:   filetype on[J

line 26:   let s:did_ft = 0[J

line 27: endif[J

line 28: [J

line 29: " Set up the connection between FileType and Syntax autocommands.[J

line 30: " This makes the syntax automatically set when the file type is detected.[J

line 31: augroup syntaxset[J

line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")[J

line 33: augroup END[J

line 34: [J

line 35: [J

line 36: " Execute the syntax autocommands for the each buffer.[J

line 37: " If the filetype wasn't detected yet, do that now.[J

line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'[J

line 39: " already was set manually (e.g., help buffers).[J

line 40: doautoall syntaxset FileType[J

line 41: if !s:did_ft[J

line 42:   doautoall filetypedetect BufRead[J

line 43: endif[J

finished sourcing /usr/share/vim/vim72/syntax/syntax.vim[J
continuing in /Users/Eric/.vimrc[J
line 19: [J

line 20: nnoremap <Left>  :echoe "Use h"<CR>[J

line 21: nnoremap <Right> :echoe "Use l"<CR>[J

line 22: nnoremap <Up>    :echoe "Use k"<CR>[J

line 23: nnoremap <Down>  :echoe "Use j"<CR>[J

line 24: [J

line 25: set ruler[J

line 26: set number[J

line 27: set cmdheight=2[J

line 28: set guioptions-=T[J

line 29: set nowrap[J

line 30: set tabstop=2[J

line 31: set shiftwidth=2[J

line 32: set expandtab[J

line 33: set guifont=Bitstream\ Vera\ Sans\ Mono:h11[J

line 34: set linebreak[J

line 35: set autoindent[J

line 36: set backspace=eol,start,indent[J

line 37: set whichwrap+=<,>,h,l[J

line 38: set ignorecase[J

line 39: set smartcase[J

line 40: set hlsearch[J

line 41: set incsearch[J

line 42: set showmatch[J

line 43: [J

line 44: " Marks end with $ for clarity[J

line 45: set cpoptions=ces$[J

line 46: [J

line 47: " Disable backups[J

line 48: set nobackup[J

line 49: set nowb[J

line 50: set noswapfile[J

line 51: [J

line 52: " Tab completion[J

line 53: set wildmode=list:longest,list:full[J

line 54: set wildignore+=*.o,*.obj,.git,*.rbc[J

line 55: set laststatus=2[J

line 56: [J

line 57: [J

line 58: " Auto reload ~/.vimrc on save[J

line 59: autocmd! bufwritepost ~/.vimrc source ~/.vimrc[J

line 60: [J

line 61: [J

line 62: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 63: " => Shortcuts[J

line 64: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 65: function! CmdLine(str)[J

line 70: [J

line 71: function! VisualSearch(direction) range[J

line 89: [J

line 90: " Fast saving[J

line 91: nmap <leader>w :w!<cr>[J

line 92: [J

line 93: " Fast editing of the .vimrc[J

line 94: map <leader>e :e! ~/.vimrc<CR>[J

line 95: [J

line 96: " Cmd+J/K to move line down/up[J

line 97: nmap <D-j> mz:m+<cr>`z[J

line 98: nmap <D-k> mz:m-2<cr>`z[J

line 99: vmap <D-j> :m'>+<cr>`<my`>mzgv`yo`z[J

line 100: vmap <D-k> :m'<-2<cr>`>my`<mzgv`yo`z[J

line 101: [J

line 102: "  In visual mode when you press * or # to search for the current selection[J

line 103: vnoremap <silent> * :call VisualSearch('f')<CR>[J

line 104: vnoremap <silent> # :call VisualSearch('b')<CR>[J

line 105: [J

line 106: " When you press gv you vimgrep after the selected text[J

line 107: vnoremap <silent> gv :call VisualSearch('gv')<CR>[J

line 108: map <leader>g :vimgrep // **/*.<left><left><left><left><left><left><left>[J

line 109: [J

line 110: [J

line 111: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 112: " => Navigation[J

line 113: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 114: " Window navigation shortcuts[J

line 115: nmap <C-J> <C-W><C-J>[J

line 116: nmap <C-K> <C-W><C-K>[J

line 117: nmap <C-H> <C-W><C-H>[J

line 118: nmap <C-L> <C-W><C-L>[J

line 119: [J

line 120: " Command line navigation shortcuts[J

line 121: cno $h e ~/[J

line 122: cno $d e ~/Desktop/[J

line 123: cno $j e ./[J

line 124: cno $c e <C-\>eCurrentFileDir("e")<cr>[J

line 125: [J

line 126: " Maps to make handling windows a bit easier[J

line 127: noremap <silent> ,h :wincmd h<CR>[J

line 128: noremap <silent> ,j :wincmd j<CR>[J

line 129: noremap <silent> ,k :wincmd k<CR>[J

line 130: noremap <silent> ,l :wincmd l<CR>[J

line 131: noremap <silent> ,sb :wincmd p<CR>[J

line 132: noremap <silent> <C-F9>  :vertical resize -10<CR>[J

line 133: noremap <silent> <C-F10> :resize +10<CR>[J

line 134: noremap <silent> <C-F11> :resize -10<CR>[J

line 135: noremap <silent> <C-F12> :vertical resize +10<CR>[J

line 136: noremap <silent> ,s8 :vertical resize 83<CR>[J

line 137: noremap <silent> ,cj :wincmd j<CR>:close<CR>[J

line 138: noremap <silent> ,ck :wincmd k<CR>:close<CR>[J

line 139: noremap <silent> ,ch :wincmd h<CR>:close<CR>[J

line 140: noremap <silent> ,cl :wincmd l<CR>:close<CR>[J

line 141: noremap <silent> ,cc :close<CR>[J

line 142: noremap <silent> ,cw :cclose<CR>[J

line 143: noremap <silent> ,ml <C-W>L[J

line 144: noremap <silent> ,mk <C-W>K[J

line 145: noremap <silent> ,mh <C-W>H[J

line 146: noremap <silent> ,mj <C-W>J[J

line 147: noremap <silent> <C-7> <C-W>>[J

line 148: noremap <silent> <C-8> <C-W>+[J

line 149: noremap <silent> <C-9> <C-W>+[J

line 150: noremap <silent> <C-0> <C-W>>[J

line 151: [J

line 152: " Bash like keys for the command line[J

line 153: cnoremap <C-A> <Home>[J

line 154: cnoremap <C-E> <End>[J

line 155: cnoremap <C-K> <C-U>[J

line 156: cnoremap <C-P> <Up>[J

line 157: cnoremap <C-N> <Down>[J

line 158: [J

line 159: " When pressing <leader>cd switch to the directory of the open buffer[J

line 160: map <leader>cd :cd %:p:h<cr>[J

line 161: [J

line 162: " Use left/right arrow keys to navigate buffers[J

line 163: map <right> :bn<cr>[J

line 164: map <left>  :bp<cr>[J

line 165: [J

line 166: [J

line 167: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 168: " => Rails[J

line 169: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 170: autocmd User Rails Rnavcommand step features/step_definitions -glob=**/* -suffix=_steps.rb[J

line 171: autocmd User Rails Rnavcommand config config -glob=**/* -suffix=.rb -default=routes[J

line 172: autocmd User Rails map <Leader>p :Rstep [J

line 173: autocmd User Rails map <Leader>sp :RSstep [J

line 174: autocmd User Rails map <Leader>tp :RTstep [J

line 175: [J

line 176: autocmd User Rails map <Leader>m :Rmodel [J

line 177: autocmd User Rails map <Leader>c :Rcontroller [J

line 178: autocmd User Rails map <Leader>v :Rview [J

line 179: autocmd User Rails map <Leader>u :Runittest [J

line 180: autocmd User Rails map <Leader>f :Rfunctionaltest [J

line 181: autocmd User Rails map <Leader>i :Rintegrationtest [J

line 182: autocmd User Rails map <Leader>h :Rhelper [J

line 183: autocmd User Rails map <Leader>r :Rconfig<CR>[J

line 184: [J

line 185: autocmd User Rails map <Leader>mt :RTmodel [J

line 186: autocmd User Rails map <Leader>ct :RTcontroller [J

line 187: autocmd User Rails map <Leader>vt :RTview [J

line 188: autocmd User Rails map <Leader>ut :RTunittest [J

line 189: autocmd User Rails map <Leader>ft :RTfunctionaltest [J

line 190: autocmd User Rails map <Leader>it :RTintegrationtest [J

line 191: autocmd User Rails map <Leader>ht :RThelper [J

line 192: autocmd User Rails map <Leader>rt :RTconfig<CR>[J

line 193: [J

line 194: autocmd User Rails map <Leader>ms :RSmodel [J

line 195: autocmd User Rails map <Leader>cs :RScontroller [J

line 196: autocmd User Rails map <Leader>vs :RSview [J

line 197: autocmd User Rails map <Leader>us :RSunittest [J

line 198: autocmd User Rails map <Leader>fs :RSfunctionaltest [J

line 199: autocmd User Rails map <Leader>is :RSintegrationtest [J

line 200: autocmd User Rails map <Leader>hs :RShelper [J

line 201: autocmd User Rails map <Leader>rs :RSconfig<CR>[J

line 202: [J

line 203: autocmd User Rails map <Leader>mv :RVmodel [J

line 204: autocmd User Rails map <Leader>cv :RVcontroller [J

line 205: autocmd User Rails map <Leader>vv :RVview [J

line 206: autocmd User Rails map <Leader>uv :RVunittest [J

line 207: autocmd User Rails map <Leader>fv :RVfunctionaltest [J

line 208: autocmd User Rails map <Leader>iv :RVintegrationtest [J

line 209: autocmd User Rails map <Leader>hv :RVhelper [J

line 210: autocmd User Rails map <Leader>rv :RVconfig<CR>[J

line 211: [J

line 212: [J

line 213: [J

line 214: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 215: " => Git/Github[J

line 216: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 217: let g:github_user='emilford'[J

line 218: let g:github_token='d57ce4942bd71a99d8a3b8bcaa1065ca'[J

line 219: [J

line 220: map <Leader>gs :Gstatus<CR>[J

line 221: map <Leader>gc :Gcommit[J

line 222: map <Leader>gl :Glog[J

line 223: map <Leader>gd :Gdiff[J

line 224: [J

line 225: let g:gist_clip_command = 'pbcopy'[J

line 226: let g:gist_detect_filetype = 1[J

line 227: let g:gist_open_browser_after_post = 0[J

line 228: [J

line 229: [J

line 230: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 231: " => Spell checking[J

line 232: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 233: " Toggle spellcheck[J

line 234: map <leader>ss :setlocal spell!<cr>[J

line 235: [J

line 236: " Navigate spellcheck[J

line 237: map <leader>sn ]s[J

line 238: map <leader>sp [s[J

line 239: map <leader>sa zg[J

line 240: map <leader>s? z=[J

line 241: [J

line 242: [J

line 243: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 244: " => Nerd Tree[J

line 245: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 246: map <Leader>n :NERDTreeToggle<CR>[J

line 247: [J

line 248: [J

line 249: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 250: " => Command-T[J

line 251: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 252: let g:CommandTMaxHeight=20[J

line 253: [J

line 254: [J

line 255: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 256: " => File Types[J

line 257: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 258: "function s:setupWrapping()[J

line 259: "  set wrap[J

line 260: "  set wm=2[J

line 261: "  set textwidth=72[J

line 262: "endfunction[J

line 263: "[J

line 264: "function s:setupMarkup()[J

line 265: "  call s:setupWrapping()[J

line 266: "  map <buffer> <Leader>p :Mm <CR>[J

line 267: "endfunction[J

line 268: [J

line 269: [J

line 270: au FileType make   set noexpandtab[J

line 271: au FileType python set noexpandtab[J

line 272: au BufRead,BufNewFile {Gemfile,Rakefile,Thorfile,config.ru} set ft=ruby[J

line 273: au BufRead,BufNewFile *.{md,markdown,mdown,mkd,mkdn} call s:setupMarkup()[J

line 274: au BufRead,BufNewFile *.txt call s:setupWrapping()[J

finished sourcing $HOME/.vimrc[J
Searching for "plugin/**/*.vim" in "/Users/Eric/.vim,/Users/Eric/.vim/bundle/align,/Users/Eric/.vim/bundle/command-t,/Users/Eric/.vim/bundle/gist,/Users/Eric/.vim/bundle/nerdcommenter,/Users/Eric/.vim/bundle/nerdtree,/Users/Eric/.vim/bundle/snipmate,/Users/Eric/.vim/bundle/vim-abolish,/Users/Eric/.vim/bundle/vim-cucumber,/Users/Eric/.vim/bundle/vim-endwise,/Users/Eric/.vim/bundle/vim-fugitive,/Users/Eric/.vim/bundle/vim-git,/Users/Eric/.vim/bundle/vim-markdown-preview,/Users/Eric/.vim/bundle/vim-pastie,/Users/Eric/.vim/bundle/vim-rails,/Users/Eric/.vim/bundle/vim-repeat,/Users/Eric/.vim/bundle/vim-rspec,/Users/Eric/.vim/bundle/vim-surround,/Users/Eric/.vim/bundle/vim-unimpaired,/usr/share/vim/vimfiles,/usr/share/vim/vim72,/usr/share/vim/vimfiles/after,/Users/Eric/.vim/bundle/snipmate/after,/Users/Eric/.vim/after"[J
Searching for "/Users/Eric/.vim/plugin/**/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/align/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/align/plugin/AlignMapsPlugin.vim"[J
line 1: " AlignMapsPlugin:   Alignment maps based upon <Align.vim> and <AlignMaps.vim>[J

line 2: " Maintainer:        Dr. Charles E. Campbell, Jr. <NdrOchipS@PcampbellAfamily.Mbiz>[J

line 3: " Date:              Mar 03, 2009[J

line 4: "[J

line 5: " NOTE: the code herein needs vim 6.0 or later[J

line 6: "                       needs <Align.vim> v6 or later[J

line 7: "                       needs <cecutil.vim> v5 or later[J

line 8: " Copyright:    Copyright (C) 1999-2008 Charles E. Campbell, Jr. {{{1[J

line 9: "               Permission is hereby granted to use and distribute this code,[J

line 10: "               with or without modifications, provided that this copyright[J

line 11: "               notice is copied with it. Like anything else that's free,[J

line 12: "               AlignMaps.vim is provided *as is* and comes with no warranty[J

line 13: "               of any kind, either expressed or implied. By using this[J

line 14: "               plugin, you agree that in no event will the copyright[J

line 15: "               holder be liable for any damages resulting from the use[J

line 16: "               of this software.[J

line 17: "[J

line 18: " Usage: {{{1[J

line 19: " Use 'a to mark beginning of to-be-aligned region,   Alternative:  use V[J

line 20: " move cursor to end of region, and execute map.      (linewise visual mode) to[J

line 21: " The maps also set up marks 'y and 'z, and retain    mark region, execute same[J

line 22: " 'a at the beginning of region.                      map.  Uses 'a, 'y, and 'z.[J

line 23: "[J

line 24: " The start/end wrappers save and restore marks 'y and 'z.[J

line 25: "[J

line 26: " Although the comments indicate the maps use a leading backslash,[J

line 27: " actually they use <Leader> (:he mapleader), so the user can[J

line 28: " specify that the maps start how he or she prefers.[J

line 29: "[J

line 30: " Note: these maps all use <Align.vim>.[J

line 31: "[J

line 32: " Romans 1:20 For the invisible things of Him since the creation of the {{{1[J

line 33: " world are clearly seen, being perceived through the things that are[J

line 34: " made, even His everlasting power and divinity; that they may be[J

line 35: " without excuse.[J

line 36: [J

line 37: " ---------------------------------------------------------------------[J

line 38: " Load Once: {{{1[J

line 39: if &cp || exists("g:loaded_AlignMapsPlugin")[J

line 40:  finish[J

line 41: endif[J

line 42: let s:keepcpo                = &cpo[J

line 43: let g:loaded_AlignMapsPlugin = "v41"[J

line 44: set cpo&vim[J

line 45: [J

line 46: " =====================================================================[J

line 47: "  Maps: {{{1[J

line 48: [J

line 49: " ---------------------------------------------------------------------[J

line 50: " WS: wrapper start map (internal)  {{{2[J

line 51: " Produces a blank line above and below, marks with 'y and 'z[J

line 52: if !hasmapto('<Plug>WrapperStart')[J

line 53:  map <unique> <SID>WS^I<Plug>AlignMapsWrapperStart[J

line 54: endif[J

line 55: nmap <silent> <script> <Plug>AlignMapsWrapperStart^I:set lz<CR>:call AlignMaps#WrapperStart(0)<CR>[J

line 56: vmap <silent> <script> <Plug>AlignMapsWrapperStart^I:<c-u>set lz<CR>:call AlignMaps#WrapperStart(1)<CR>[J

line 57: [J

line 58: " ---------------------------------------------------------------------[J

line 59: " WE: wrapper end (internal)   {{{2[J

line 60: " Removes guard lines, restores marks y and z, and restores search pattern[J

line 61: if !hasmapto('<Plug>WrapperEnd')[J

line 62:  nmap <unique> <SID>WE^I<Plug>AlignMapsWrapperEnd[J

line 63: endif[J

line 64: nmap <silent> <script> <Plug>AlignMapsWrapperEnd^I:call AlignMaps#WrapperEnd()<CR>:set nolz<CR>[J

line 65: [J

line 66: " ---------------------------------------------------------------------[J

line 67: " Complex C-code alignment maps: {{{2[J

line 68: if !hasmapto('<Plug>AM_a?')   |map <unique> <Leader>a?^I^I<Plug>AM_a?|endif[J

line 68: map <unique> <Leader>a?^I^I<Plug>AM_a?|endif[J

line 68: endif[J

line 69: if !hasmapto('<Plug>AM_a,')   |map <unique> <Leader>a,^I^I<Plug>AM_a,|endif[J

line 69: map <unique> <Leader>a,^I^I<Plug>AM_a,|endif[J

line 69: endif[J

line 70: if !hasmapto('<Plug>AM_a<')   |map <unique> <Leader>a<^I^I<Plug>AM_a<|endif[J

line 70: map <unique> <Leader>a<^I^I<Plug>AM_a<|endif[J

line 70: endif[J

line 71: if !hasmapto('<Plug>AM_a=')   |map <unique> <Leader>a=^I^I<Plug>AM_a=|endif[J

line 71: map <unique> <Leader>a=^I^I<Plug>AM_a=|endif[J

line 71: endif[J

line 72: if !hasmapto('<Plug>AM_a(')   |map <unique> <Leader>a(^I^I<Plug>AM_a(|endif[J

line 72: map <unique> <Leader>a(^I^I<Plug>AM_a(|endif[J

line 72: endif[J

line 73: if !hasmapto('<Plug>AM_abox') |map <unique> <Leader>abox^I<Plug>AM_abox|endif[J

line 73: map <unique> <Leader>abox^I<Plug>AM_abox|endif[J

line 73: endif[J

line 74: if !hasmapto('<Plug>AM_acom') |map <unique> <Leader>acom^I<Plug>AM_acom|endif[J

line 74: map <unique> <Leader>acom^I<Plug>AM_acom|endif[J

line 74: endif[J

line 75: if !hasmapto('<Plug>AM_adcom')|map <unique> <Leader>adcom^I<Plug>AM_adcom|endif[J

line 75: map <unique> <Leader>adcom^I<Plug>AM_adcom|endif[J

line 75: endif[J

line 76: if !hasmapto('<Plug>AM_aocom')|map <unique> <Leader>aocom^I<Plug>AM_aocom|endif[J

line 76: map <unique> <Leader>aocom^I<Plug>AM_aocom|endif[J

line 76: endif[J

line 77: if !hasmapto('<Plug>AM_ascom')|map <unique> <Leader>ascom^I<Plug>AM_ascom|endif[J

line 77: map <unique> <Leader>ascom^I<Plug>AM_ascom|endif[J

line 77: endif[J

line 78: if !hasmapto('<Plug>AM_adec') |map <unique> <Leader>adec^I<Plug>AM_adec|endif[J

line 78: map <unique> <Leader>adec^I<Plug>AM_adec|endif[J

line 78: endif[J

line 79: if !hasmapto('<Plug>AM_adef') |map <unique> <Leader>adef^I<Plug>AM_adef|endif[J

line 79: map <unique> <Leader>adef^I<Plug>AM_adef|endif[J

line 79: endif[J

line 80: if !hasmapto('<Plug>AM_afnc') |map <unique> <Leader>afnc^I<Plug>AM_afnc|endif[J

line 80: map <unique> <Leader>afnc^I<Plug>AM_afnc|endif[J

line 80: endif[J

line 81: if !hasmapto('<Plug>AM_afnc') |map <unique> <Leader>afnc^I<Plug>AM_afnc|endif[J

line 81: map <unique> <Leader>afnc^I<Plug>AM_afnc|endif[J

line 81: endif[J

line 82: if !hasmapto('<Plug>AM_aunum')|map <unique> <Leader>aunum^I<Plug>AM_aenum|endif[J

line 82: map <unique> <Leader>aunum^I<Plug>AM_aenum|endif[J

line 82: endif[J

line 83: if !hasmapto('<Plug>AM_aenum')|map <unique> <Leader>aenum^I<Plug>AM_aunum|endif[J

line 83: map <unique> <Leader>aenum^I<Plug>AM_aunum|endif[J

line 83: endif[J

line 84: if exists("g:alignmaps_euronumber") && !exists("g:alignmaps_usanumber")[J

line 85:  if !hasmapto('<Plug>AM_anum')|map <unique> <Leader>anum^I<Plug>AM_aenum|endif[J

line 85: map <unique> <Leader>anum^I<Plug>AM_aenum|endif[J

line 85: endif[J

line 86: else[J

line 87:  if !hasmapto('<Plug>AM_anum')|map <unique> <Leader>anum^I<Plug>AM_aunum|endif[J

line 87: map <unique> <Leader>anum^I<Plug>AM_aunum|endif[J

line 87: endif[J

line 88: endif[J

line 89: [J

line 90: map <silent> <script> <Plug>AM_a?^I^I<SID>WS:AlignCtrl mIp1P1lC ? : : : : <CR>:'a,.Align<CR>:'a,'z-1s/\(\s\+\)? /?\1/e<CR><SID>WE[J

line 91: map <silent> <script> <Plug>AM_a,^I^I<SID>WS:'y,'zs/\(\S\)\s\+/\1 /ge<CR>'yjma'zk:call AlignMaps#CharJoiner(",")<cr>:silent 'y,'zg/,/call AlignMaps#FixMultiDec()<CR>'z:exe "norm \<Plug>AM_adec"<cr><SID>WE[J

line 92: map <silent> <script> <Plug>AM_a<^I^I<SID>WS:AlignCtrl mIp1P1=l << >><CR>:'a,.Align<CR><SID>WE[J

line 93: map <silent> <script> <Plug>AM_a(       <SID>WS:AlignCtrl mIp0P1=l<CR>:'a,.Align [(,]<CR>:sil 'y+1,'z-1s/\(\s\+\),/,\1/ge<CR><SID>WE[J

line 94: map <silent> <script> <Plug>AM_a=^I^I<SID>WS:AlignCtrl mIp1P1=l<CR>:AlignCtrl g :=<CR>:'a,'zAlign :\==<CR><SID>WE[J

line 95: map <silent> <script> <Plug>AM_abox^I^I<SID>WS:let g:alignmaps_iws=substitute(getline("'a"),'^\(\s*\).*$','\1','e')<CR>:'a,'z-1s/^\s\+//e<CR>:'a,'z-1s/^.*$/@&@/<CR>:AlignCtrl m=p01P0w @<CR>:'a,.Align<CR>:'a,'z-1s/@/ * /<CR>:'a,'z-1s/@$/*/<CR>'aYP:s/./*/g<CR>0r/'zkYp:s/./*/g<CR>0r A/<Esc>:exe "'a-1,'z-1s/^/".g:alignmaps_iws."/e"<CR><SID>WE[J

line 96: map <silent> <script> <Plug>AM_acom^I^I<SID>WS:'a,.s/\/[*/]\/\=/@&@/e<CR>:'a,.s/\*\//@&/e<CR>:'y,'zs/^\( *\) @/\1@/e<CR>'zk:call AlignMaps#StdAlign(2)<CR>:'y,'zs/^\(\s*\) @/\1/e<CR>:'y,'zs/ @//eg<CR><SID>WE[J

line 97: map <silent> <script> <Plug>AM_adcom^I<SID>WS:'a,.v/^\s*\/[/*]/s/\/[*/]\*\=/@&@/e<CR>:'a,.v/^\s*\/[/*]/s/\*\//@&/e<CR>:'y,'zv/^\s*\/[/*]/s/^\( *\) @/\1@/e<CR>'zk:call AlignMaps#StdAlign(3)<cr>:'y,'zv/^\s*\/[/*]/s/^\(\s*\) @/\1/e<CR>:'y,'zs/ @//eg<CR><SID>WE[J

line 98: map <silent> <script> <Plug>AM_aocom^I<SID>WS:AlignPush<CR>:AlignCtrl g /[*/]<CR>:exe "norm \<Plug>AM_acom"<cr>:AlignPop<CR><SID>WE[J

line 99: map <silent> <script> <Plug>AM_ascom^I<SID>WS:'a,.s/\/[*/]/@&@/e<CR>:'a,.s/\*\//@&/e<CR>:silent! 'a,.g/^\s*@\/[*/]/s/@//ge<CR>:AlignCtrl v ^\s*\/[*/]<CR>:AlignCtrl g \/[*/]<CR>'zk:call AlignMaps#StdAlign(2)<cr>:'y,'zs/^\(\s*\) @/\1/e<CR>:'y,'zs/ @//eg<CR><SID>WE[J

line 100: map <silent> <script> <Plug>AM_adec^I^I<SID>WS:'a,'zs/\([^ \t/(]\)\([*&]\)/\1 \2/e<CR>:'y,'zv/^\//s/\([^ \t]\)\s\+/\1 /ge<CR>:'y,'zv/^\s*[*/]/s/\([^/][*&]\)\s\+/\1/ge<CR>:'y,'zv/^\s*[*/]/s/^\(\s*\%(\K\k*\s\+\%([a-zA-Z_*(&]\)\@=\)\+\)\([*(&]*\)\s*\([a-zA-Z0-9_()]\+\)\s*\(\(\[.\{-}]\)*\)\s*\(=\)\=\s*\(.\{-}\)\=\s*;/\1@\2#@\3\4@\6@\7;@/e<CR>:'y,'zv/^\s*[*/]/s/\*\/\s*$/@*\//e<CR>:'y,'zv/^\s*[*/]/s/^\s\+\*/@@@@@* /e<CR>:'y,'zv/^\s*[*/]/s/^@@@@@\*\(.*[^*/]\)$/&@*/e<CR>'yjma'zk:AlignCtrl v ^\s*[*/#]<CR>:call AlignMaps#StdAlign(1)<cr>:'y,'zv/^\s*[*/]/s/@ //ge<CR>:'y,'zv/^\s*[*/]/s/\(\s*\);/;\1/e<CR>:'y,'zv/^#/s/# //e<CR>:'y,'zv/^\s\+[*/#]/s/\([^/*]\)\(\*\+\)\( \+\)/\1\3\2/e<CR>:'y,'zv/^\s\+[*/#]/s/\((\+\)\( \+\)\*/\2\1*/e<CR>:'y,'zv/^\s\+[*/#]/s/^\(\s\+\) \*/\1*/e<CR>:'y,'zv/^\s\+[*/#]/s/[ \t@]*$//e<CR>:'y,'zs/^[*]/ */e<CR><SID>WE[J

line 101: map <silent> <script> <Plug>AM_adef^I^I<SID>WS:AlignPush<CR>:AlignCtrl v ^\s*\(\/\*\<bar>\/\/\)<CR>:'a,.v/^\s*\(\/\*\<bar>\/\/\)/s/^\(\s*\)#\(\s\)*define\s*\(\I[a-zA-Z_0-9(),]*\)\s*\(.\{-}\)\($\<Bar>\/\*\)/#\1\2define @\3@\4@\5/e<CR>:'a,.v/^\s*\(\/\*\<bar>\/\/\)/s/\($\<Bar>\*\/\)/@&/e<CR>'zk:call AlignMaps#StdAlign(1)<cr>'yjma'zk:'a,.v/^\s*\(\/\*\<bar>\/\/\)/s/ @//g<CR><SID>WE[J

line 102: map <silent> <script> <Plug>AM_afnc^I^I:<c-u>set lz<CR>:silent call AlignMaps#Afnc()<CR>:set nolz<CR>[J

line 103: map <silent> <script> <Plug>AM_aunum^I<SID>WS:'a,'zs/\%([0-9.]\)\s\+\zs\([-+.]\=\d\)/@\1/ge<CR>:'a,'zs/\(\(^\|\s\)\d\+\)\(\s\+\)@/\1@\3@/ge<CR>:'a,'zs/\.@/\.0@/ge<CR>:AlignCtrl wmp0P0r<CR>:'a,'zAlign [.@]<CR>:'a,'zs/@/ /ge<CR>:'a,'zs/\(\.\)\(\s\+\)\([0-9.,eE+]\+\)/\1\3\2/ge<CR>:'a,'zs/\([eE]\)\(\s\+\)\([0-9+\-+]\+\)/\1\3\2/ge<CR><SID>WE[J

line 104: map <silent> <script> <Plug>AM_aenum^I<SID>WS:'a,'zs/\%([0-9.]\)\s\+\([-+]\=\d\)/\1@\2/ge<CR>:'a,'zs/\.@/\.0@/ge<CR>:AlignCtrl wmp0P0r<CR>:'a,'zAlign [,@]<CR>:'a,'zs/@/ /ge<CR>:'a,'zs/\(,\)\(\s\+\)\([-0-9.,eE+]\+\)/\1\3\2/ge<CR>:'a,'zs/\([eE]\)\(\s\+\)\([0-9+\-+]\+\)/\1\3\2/ge<CR><SID>WE[J

line 105: [J

line 106: " ---------------------------------------------------------------------[J

line 107: " html table alignment^I{{{2[J

line 108: if !hasmapto('<Plug>AM_Htd')|map <unique> <Leader>Htd^I<Plug>AM_Htd|endif[J

line 108: map <unique> <Leader>Htd^I<Plug>AM_Htd|endif[J

line 108: endif[J

line 109: map <silent> <script> <Plug>AM_Htd <SID>WS:'y,'zs%<[tT][rR]><[tT][dD][^>]\{-}>\<Bar></[tT][dD]><[tT][dD][^>]\{-}>\<Bar></[tT][dD]></[tT][rR]>%@&@%g<CR>'yjma'zk:AlignCtrl m=Ilp1P0 @<CR>:'a,.Align<CR>:'y,'zs/ @/@/<CR>:'y,'zs/@ <[tT][rR]>/<[tT][rR]>/ge<CR>:'y,'zs/@//ge<CR><SID>WE[J

line 110: [J

line 111: " ---------------------------------------------------------------------[J

line 112: " character-based right-justified alignment maps {{{2[J

line 113: if !hasmapto('<Plug>AM_T^V|')|map <unique> <Leader>T^V|^I^I<Plug>AM_T^V||endif[J

line 113: map <unique> <Leader>T^V|^I^I<Plug>AM_T^V||endif[J

line 113: endif[J

line 114: if !hasmapto('<Plug>AM_T#')^I |map <unique> <Leader>T#^I^I<Plug>AM_T#|endif[J

line 114: map <unique> <Leader>T#^I^I<Plug>AM_T#|endif[J

line 114: endif[J

line 115: if !hasmapto('<Plug>AM_T,')^I |map <unique> <Leader>T,^I^I<Plug>AM_T,o|endif[J

line 115: map <unique> <Leader>T,^I^I<Plug>AM_T,o|endif[J

line 115: endif[J

line 116: if !hasmapto('<Plug>AM_Ts,') |map <unique> <Leader>Ts,^I^I<Plug>AM_Ts,|endif[J

line 116: map <unique> <Leader>Ts,^I^I<Plug>AM_Ts,|endif[J

line 116: endif[J

line 117: if !hasmapto('<Plug>AM_T:')^I |map <unique> <Leader>T:^I^I<Plug>AM_T:|endif[J

line 117: map <unique> <Leader>T:^I^I<Plug>AM_T:|endif[J

line 117: endif[J

line 118: if !hasmapto('<Plug>AM_T;')^I |map <unique> <Leader>T;^I^I<Plug>AM_T;|endif[J

line 118: map <unique> <Leader>T;^I^I<Plug>AM_T;|endif[J

line 118: endif[J

line 119: if !hasmapto('<Plug>AM_T<')^I |map <unique> <Leader>T<^I^I<Plug>AM_T<|endif[J

line 119: map <unique> <Leader>T<^I^I<Plug>AM_T<|endif[J

line 119: endif[J

line 120: if !hasmapto('<Plug>AM_T=')^I |map <unique> <Leader>T=^I^I<Plug>AM_T=|endif[J

line 120: map <unique> <Leader>T=^I^I<Plug>AM_T=|endif[J

line 120: endif[J

line 121: if !hasmapto('<Plug>AM_T?')^I |map <unique> <Leader>T?^I^I<Plug>AM_T?|endif[J

line 121: map <unique> <Leader>T?^I^I<Plug>AM_T?|endif[J

line 121: endif[J

line 122: if !hasmapto('<Plug>AM_T@')^I |map <unique> <Leader>T@^I^I<Plug>AM_T@|endif[J

line 122: map <unique> <Leader>T@^I^I<Plug>AM_T@|endif[J

line 122: endif[J

line 123: if !hasmapto('<Plug>AM_Tab') |map <unique> <Leader>Tab^I^I<Plug>AM_Tab|endif[J

line 123: map <unique> <Leader>Tab^I^I<Plug>AM_Tab|endif[J

line 123: endif[J

line 124: if !hasmapto('<Plug>AM_Tsp') |map <unique> <Leader>Tsp^I^I<Plug>AM_Tsp|endif[J

line 124: map <unique> <Leader>Tsp^I^I<Plug>AM_Tsp|endif[J

line 124: endif[J

line 125: if !hasmapto('<Plug>AM_T~')^I |map <unique> <Leader>T~^I^I<Plug>AM_T~|endif[J

line 125: map <unique> <Leader>T~^I^I<Plug>AM_T~|endif[J

line 125: endif[J

line 126: [J

line 127: map <silent> <script> <Plug>AM_T^V| <SID>WS:AlignCtrl mIp0P0=r <Bar><CR>:'a,.Align<CR><SID>WE[J

line 128: map <silent> <script> <Plug>AM_T#   <SID>WS:AlignCtrl mIp0P0=r #<CR>:'a,.Align<CR><SID>WE[J

line 129: map <silent> <script> <Plug>AM_T,   <SID>WS:AlignCtrl mIp0P1=r ,<CR>:'a,.Align<CR><SID>WE[J

line 130: map <silent> <script> <Plug>AM_Ts,  <SID>WS:AlignCtrl mIp0P1=r ,<CR>:'a,.Align<CR>:'a,.s/\(\s*\),/,\1/ge<CR><SID>WE[J

line 131: map <silent> <script> <Plug>AM_T:   <SID>WS:AlignCtrl mIp1P1=r :<CR>:'a,.Align<CR><SID>WE[J

line 132: map <silent> <script> <Plug>AM_T;   <SID>WS:AlignCtrl mIp0P0=r ;<CR>:'a,.Align<CR><SID>WE[J

line 133: map <silent> <script> <Plug>AM_T<   <SID>WS:AlignCtrl mIp0P0=r <<CR>:'a,.Align<CR><SID>WE[J

line 134: map <silent> <script> <Plug>AM_T=   <SID>WS:'a,'z-1s/\s\+\([*/+\-%<Bar>&\~^]\==\)/ \1/e<CR>:'a,'z-1s@ \+\([*/+\-%<Bar>&\~^]\)=@\1=@ge<CR>:'a,'z-1s/; */;@/e<CR>:'a,'z-1s/==/\="\<Char-0x0f>\<Char-0x0f>"/ge<CR>:'a,'z-1s/!=/\x="!\<Char-0x0f>"/ge<CR>:AlignCtrl mIp1P1=r = @<CR>:AlignCtrl g =<CR>:'a,'z-1Align<CR>:'a,'z-1s/; *@/;/e<CR>:'a,'z-1s/; *$/;/e<CR>:'a,'z-1s@\([*/+\-%<Bar>&\~^]\)\( \+\)=@\2\1=@ge<CR>:'a,'z-1s/\( \+\);/;\1/ge<CR>:'a,'z-1s/\xff/=/ge<CR><SID>WE:exe "norm <Plug>acom"[J

line 135: map <silent> <script> <Plug>AM_T?   <SID>WS:AlignCtrl mIp0P0=r ?<CR>:'a,.Align<CR>:'y,'zs/ \( *\);/;\1/ge<CR><SID>WE[J

line 136: map <silent> <script> <Plug>AM_T@   <SID>WS:AlignCtrl mIp0P0=r @<CR>:'a,.Align<CR><SID>WE[J

line 137: map <silent> <script> <Plug>AM_Tab  <SID>WS:'a,.s/^\(\t*\)\(.*\)/\=submatch(1).escape(substitute(submatch(2),'\t','@','g'),'\')/<CR>:AlignCtrl mI=r @<CR>:'a,.Align<CR>:'y+1,'z-1s/@/ /g<CR><SID>WE[J

line 138: map <silent> <script> <Plug>AM_Tsp  <SID>WS:'a,.s/^\(\s*\)\(.*\)/\=submatch(1).escape(substitute(submatch(2),'\s\+','@','g'),'\')/<CR>:AlignCtrl mI=r @<CR>:'a,.Align<CR>:'y+1,'z-1s/@/ /g<CR><SID>WE[J

line 139: map <silent> <script> <Plug>AM_T~   <SID>WS:AlignCtrl mIp0P0=r ~<CR>:'a,.Align<CR>:'y,'zs/ \( *\);/;\1/ge<CR><SID>WE[J

line 140: [J

line 141: " ---------------------------------------------------------------------[J

line 142: " character-based left-justified alignment maps {{{2[J

line 143: if !hasmapto('<Plug>AM_t^V|')^I|map <unique> <Leader>t^V|^I<Plug>AM_t^V||endif[J

line 143: map <unique> <Leader>t^V|^I<Plug>AM_t^V||endif[J

line 143: endif[J

line 144: if !hasmapto('<Plug>AM_t#')^I^I|map <unique> <Leader>t#^I<Plug>AM_t#|endif[J

line 144: map <unique> <Leader>t#^I<Plug>AM_t#|endif[J

line 144: endif[J

line 145: if !hasmapto('<Plug>AM_t,')^I^I|map <unique> <Leader>t,^I<Plug>AM_t,|endif[J

line 145: map <unique> <Leader>t,^I<Plug>AM_t,|endif[J

line 145: endif[J

line 146: if !hasmapto('<Plug>AM_t:')^I^I|map <unique> <Leader>t:^I<Plug>AM_t:|endif[J

line 146: map <unique> <Leader>t:^I<Plug>AM_t:|endif[J

line 146: endif[J

line 147: if !hasmapto('<Plug>AM_t;')^I^I|map <unique> <Leader>t;^I<Plug>AM_t;|endif[J

line 147: map <unique> <Leader>t;^I<Plug>AM_t;|endif[J

line 147: endif[J

line 148: if !hasmapto('<Plug>AM_t<')^I^I|map <unique> <Leader>t<^I<Plug>AM_t<|endif[J

line 148: map <unique> <Leader>t<^I<Plug>AM_t<|endif[J

line 148: endif[J

line 149: if !hasmapto('<Plug>AM_t=')^I^I|map <unique> <Leader>t=^I<Plug>AM_t=|endif[J

line 149: map <unique> <Leader>t=^I<Plug>AM_t=|endif[J

line 149: endif[J

line 150: if !hasmapto('<Plug>AM_ts,')^I|map <unique> <Leader>ts,^I<Plug>AM_ts,|endif[J

line 150: map <unique> <Leader>ts,^I<Plug>AM_ts,|endif[J

line 150: endif[J

line 151: if !hasmapto('<Plug>AM_ts:')^I|map <unique> <Leader>ts:^I<Plug>AM_ts:|endif[J

line 151: map <unique> <Leader>ts:^I<Plug>AM_ts:|endif[J

line 151: endif[J

line 152: if !hasmapto('<Plug>AM_ts;')^I|map <unique> <Leader>ts;^I<Plug>AM_ts;|endif[J

line 152: map <unique> <Leader>ts;^I<Plug>AM_ts;|endif[J

line 152: endif[J

line 153: if !hasmapto('<Plug>AM_ts<')^I|map <unique> <Leader>ts<^I<Plug>AM_ts<|endif[J

line 153: map <unique> <Leader>ts<^I<Plug>AM_ts<|endif[J

line 153: endif[J

line 154: if !hasmapto('<Plug>AM_ts=')^I|map <unique> <Leader>ts=^I<Plug>AM_ts=|endif[J

line 154: map <unique> <Leader>ts=^I<Plug>AM_ts=|endif[J

line 154: endif[J

line 155: if !hasmapto('<Plug>AM_w=')^I^I|map <unique> <Leader>w=^I<Plug>AM_w=|endif[J

line 155: map <unique> <Leader>w=^I<Plug>AM_w=|endif[J

line 155: endif[J

line 156: if !hasmapto('<Plug>AM_t?')^I^I|map <unique> <Leader>t?^I<Plug>AM_t?|endif[J

line 156: map <unique> <Leader>t?^I<Plug>AM_t?|endif[J

line 156: endif[J

line 157: if !hasmapto('<Plug>AM_t~')^I^I|map <unique> <Leader>t~^I<Plug>AM_t~|endif[J

line 157: map <unique> <Leader>t~^I<Plug>AM_t~|endif[J

line 157: endif[J

line 158: if !hasmapto('<Plug>AM_t@')^I^I|map <unique> <Leader>t@^I<Plug>AM_t@|endif[J

line 158: map <unique> <Leader>t@^I<Plug>AM_t@|endif[J

line 158: endif[J

line 159: if !hasmapto('<Plug>AM_m=')^I^I|map <unique> <Leader>m=^I<Plug>AM_m=|endif[J

line 159: map <unique> <Leader>m=^I<Plug>AM_m=|endif[J

line 159: endif[J

line 160: if !hasmapto('<Plug>AM_tab')^I|map <unique> <Leader>tab^I<Plug>AM_tab|endif[J

line 160: map <unique> <Leader>tab^I<Plug>AM_tab|endif[J

line 160: endif[J

line 161: if !hasmapto('<Plug>AM_tml')^I|map <unique> <Leader>tml^I<Plug>AM_tml|endif[J

line 161: map <unique> <Leader>tml^I<Plug>AM_tml|endif[J

line 161: endif[J

line 162: if !hasmapto('<Plug>AM_tsp')^I|map <unique> <Leader>tsp^I<Plug>AM_tsp|endif[J

line 162: map <unique> <Leader>tsp^I<Plug>AM_tsp|endif[J

line 162: endif[J

line 163: if !hasmapto('<Plug>AM_tsq')^I|map <unique> <Leader>tsq^I<Plug>AM_tsq|endif[J

line 163: map <unique> <Leader>tsq^I<Plug>AM_tsq|endif[J

line 163: endif[J

line 164: if !hasmapto('<Plug>AM_tt')^I^I|map <unique> <Leader>tt^I<Plug>AM_tt|endif[J

line 164: map <unique> <Leader>tt^I<Plug>AM_tt|endif[J

line 164: endif[J

line 165: [J

line 166: map <silent> <script> <Plug>AM_t^V|^I^I<SID>WS:AlignCtrl mIp0P0=l <Bar><CR>:'a,.Align<CR><SID>WE[J

line 167: map <silent> <script> <Plug>AM_t#^I^I<SID>WS:AlignCtrl mIp0P0=l #<CR>:'a,.Align<CR><SID>WE[J

line 168: map <silent> <script> <Plug>AM_t,^I^I<SID>WS:AlignCtrl mIp0P1=l ,<CR>:'a,.Align<CR><SID>WE[J

line 169: map <silent> <script> <Plug>AM_t:^I^I<SID>WS:AlignCtrl mIp1P1=l :<CR>:'a,.Align<CR><SID>WE[J

line 170: map <silent> <script> <Plug>AM_t;^I^I<SID>WS:AlignCtrl mIp0P1=l ;<CR>:'a,.Align<CR>:sil 'y,'zs/\( *\);/;\1/ge<CR><SID>WE[J

line 171: map <silent> <script> <Plug>AM_t<^I^I<SID>WS:AlignCtrl mIp0P0=l <<CR>:'a,.Align<CR><SID>WE[J

line 172: map <silent> <script> <Plug>AM_t=^I^I<SID>WS:call AlignMaps#Equals()<CR><SID>WE[J

line 173: map <silent> <script> <Plug>AM_ts,^I^I<SID>WS:AlignCtrl mIp0P1=l #<CR>:'a,.Align<CR>:sil 'y+1,'z-1s/\(\s*\)#/,\1/ge<CR><SID>WE[J

line 174: map <silent> <script> <Plug>AM_ts,^I^I<SID>WS:AlignCtrl mIp0P1=l ,<CR>:'a,.Align<CR>:sil 'y+1,'z-1s/\(\s*\),/,\1/ge<CR><SID>WE[J

line 175: map <silent> <script> <Plug>AM_ts:^I^I<SID>WS:AlignCtrl mIp1P1=l :<CR>:'a,.Align<CR>:sil 'y+1,'z-1s/\(\s*\):/:\1/ge<CR><SID>WE[J

line 176: map <silent> <script> <Plug>AM_ts;^I^I<SID>WS:AlignCtrl mIp1P1=l ;<CR>:'a,.Align<CR>:sil 'y+1,'z-1s/\(\s*\);/;\1/ge<CR><SID>WE[J

line 177: map <silent> <script> <Plug>AM_ts<^I^I<SID>WS:AlignCtrl mIp1P1=l <<CR>:'a,.Align<CR>:sil 'y+1,'z-1s/\(\s*\)</<\1/ge<CR><SID>WE[J

line 178: map <silent> <script> <Plug>AM_ts=^I^I<SID>WS:AlignCtrl mIp1P1=l =<CR>:'a,.Align<CR>:sil 'y+1,'z-1s/\(\s*\)=/=\1/ge<CR><SID>WE[J

line 179: map <silent> <script> <Plug>AM_w=^I^I<SID>WS:'a,'zg/=/s/\s\+\([*/+\-%<Bar>&\~^]\==\)/ \1/e<CR>:'a,'zg/=/s@ \+\([*/+\-%<Bar>&\~^]\)=@\1=@ge<CR>:'a,'zg/=/s/==/\="\<Char-0x0f>\<Char-0x0f>"/ge<CR>:'a,'zg/=/s/!=/\="!\<Char-0x0f>"/ge<CR>'zk:AlignCtrl mWp1P1=l =<CR>:AlignCtrl g =<CR>:'a,'z-1g/=/Align<CR>:'a,'z-1g/=/s@\([*/+\-%<Bar>&\~^!=]\)\( \+\)=@\2\1=@ge<CR>:'a,'z-1g/=/s/\( \+\);/;\1/ge<CR>:'a,'z-1v/^\s*\/[*/]/s/\/[*/]/@&@/e<CR>:'a,'z-1v/^\s*\/[*/]/s/\*\//@&/e<CR>'zk:call AlignMaps#StdAlign(1)<cr>:'y,'zs/^\(\s*\) @/\1/e<CR>:'a,'z-1g/=/s/\xff/=/ge<CR>:'y,'zg/=/s/ @//eg<CR><SID>WE[J

line 180: map <silent> <script> <Plug>AM_t?^I^I<SID>WS:AlignCtrl mIp0P0=l ?<CR>:'a,.Align<CR>:.,'zs/ \( *\);/;\1/ge<CR><SID>WE[J

line 181: map <silent> <script> <Plug>AM_t~^I^I<SID>WS:AlignCtrl mIp0P0=l ~<CR>:'a,.Align<CR>:'y,'zs/ \( *\);/;\1/ge<CR><SID>WE[J

line 182: map <silent> <script> <Plug>AM_t@^I^I<SID>WS::call AlignMaps#StdAlign(1)<cr>:<SID>WE[J

line 183: map <silent> <script> <Plug>AM_m=^I^I<SID>WS:'a,'zs/\s\+\([*/+\-%<Bar>&\~^]\==\)/ \1/e<CR>:'a,'zs@ \+\([*/+\-%<Bar>&\~^]\)=@\1=@ge<CR>:'a,'zs/==/\="\<Char-0x0f>\<Char-0x0f>"/ge<CR>:'a,'zs/!=/\="!\<Char-0x0f>"/ge<CR>'zk:AlignCtrl mIp1P1=l =<CR>:AlignCtrl g =<CR>:'a,'z-1Align<CR>:'a,'z-1s@\([*/+\-%<Bar>&\~^!=]\)\( \+\)=@\2\1=@ge<CR>:'a,'z-1s/\( \+\);/;\1/ge<CR>:'a,'z-s/%\ze[^=]/ @%@ /e<CR>'zk:call AlignMaps#StdAlign(1)<cr>:'y,'zs/^\(\s*\) @/\1/e<CR>:'a,'z-1s/\xff/=/ge<CR>:'y,'zs/ @//eg<CR><SID>WE[J

line 184: map <silent> <script> <Plug>AM_tab^I^I<SID>WS:'a,.s/^\(\t*\)\(.*\)$/\=submatch(1).escape(substitute(submatch(2),'\t',"\<Char-0x0f>",'g'),'\')/<CR>:if &ts == 1<bar>exe "AlignCtrl mI=lp0P0 \<Char-0x0f>"<bar>else<bar>exe "AlignCtrl mI=l \<Char-0x0f>"<bar>endif<CR>:'a,.Align<CR>:exe "'y+1,'z-1s/\<Char-0x0f>/".((&ts == 1)? '\t' : ' ')."/g"<CR><SID>WE[J

line 185: map <silent> <script> <Plug>AM_tml^I^I<SID>WS:AlignCtrl mWp1P0=l \\\@<!\\\s*$<CR>:'a,.Align<CR><SID>WE[J

line 186: map <silent> <script> <Plug>AM_tsp^I^I<SID>WS:'a,.s/^\(\s*\)\(.*\)/\=submatch(1).escape(substitute(submatch(2),'\s\+','@','g'),'\')/<CR>:AlignCtrl mI=lp0P0 @<CR>:'a,.Align<CR>:'y+1,'z-1s/@/ /g<CR><SID>WE[J

line 187: map <silent> <script> <Plug>AM_tsq^I^I<SID>WS:'a,.AlignReplaceQuotedSpaces<CR>:'a,.s/^\(\s*\)\(.*\)/\=submatch(1).substitute(submatch(2),'\s\+','@','g')/<CR>:AlignCtrl mIp0P0=l @<CR>:'a,.Align<CR>:'y+1,'z-1s/[%@]/ /g<CR><SID>WE[J

line 188: map <silent> <script> <Plug>AM_tt^I^I<SID>WS:AlignCtrl mIp1P1=l \\\@<!& \\\\<CR>:'a,.Align<CR><SID>WE[J

line 189: [J

line 190: " =====================================================================[J

line 191: " Menu Support: {{{1[J

line 192: "   ma ..move.. use menu[J

line 193: "   v V or ctrl-v ..move.. use menu[J

line 194: if has("menu") && has("gui_running") && &go =~ 'm' && !exists("s:firstmenu")[J

line 195:  let s:firstmenu= 1[J

line 196:  if !exists("g:DrChipTopLvlMenu")[J

line 197:   let g:DrChipTopLvlMenu= "DrChip."[J

line 198:  endif[J

line 199:  if g:DrChipTopLvlMenu != ""[J

line 200:   let s:mapleader = exists("g:mapleader")? g:mapleader : '\'[J

line 201:   let s:emapleader= escape(s:mapleader,'\ ')[J

line 202:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.<<\ and\ >><tab>'.s:emapleader.'a<^I'.s:mapleader.'a<'[J

line 203:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Assignment\ =<tab>'.s:emapleader.'t=^I'.s:mapleader.'t='[J

line 204:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Assignment\ :=<tab>'.s:emapleader.'a=^I'.s:mapleader.'a='[J

line 205:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Backslashes<tab>'.s:emapleader.'tml^I'.s:mapleader.'tml'[J

line 206:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Breakup\ Comma\ Declarations<tab>'.s:emapleader.'a,^I'.s:mapleader.'a,'[J

line 207:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.C\ Comment\ Box<tab>'.s:emapleader.'abox^I'.s:mapleader.'abox'[J

line 208:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Commas<tab>'.s:emapleader.'t,^I'.s:mapleader.'t,'[J

line 209:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Commas<tab>'.s:emapleader.'ts,^I'.s:mapleader.'ts,'[J

line 210:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Commas\ With\ Strings<tab>'.s:emapleader.'tsq^I'.s:mapleader.'tsq'[J

line 211:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Comments<tab>'.s:emapleader.'acom^I'.s:mapleader.'acom'[J

line 212:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Comments\ Only<tab>'.s:emapleader.'aocom^I'.s:mapleader.'aocom'[J

line 213:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Declaration\ Comments<tab>'.s:emapleader.'adcom^I'.s:mapleader.'adcom'[J

line 214:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Declarations<tab>'.s:emapleader.'adec^I'.s:mapleader.'adec'[J

line 215:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Definitions<tab>'.s:emapleader.'adef^I'.s:mapleader.'adef'[J

line 216:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Function\ Header<tab>'.s:emapleader.'afnc^I'.s:mapleader.'afnc'[J

line 217:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Html\ Tables<tab>'.s:emapleader.'Htd^I'.s:mapleader.'Htd'[J

line 218:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.(\.\.\.)?\.\.\.\ :\ \.\.\.<tab>'.s:emapleader.'a?^I'.s:mapleader.'a?'[J

line 219:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Numbers<tab>'.s:emapleader.'anum^I'.s:mapleader.'anum'[J

line 220:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Numbers\ (American-Style)<tab>'.s:emapleader.'aunum^I<Leader>aunum^I'.s:mapleader.'aunum^I<Leader>aunum'[J

line 221:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Numbers\ (Euro-Style)<tab>'.s:emapleader.'aenum^I'.s:mapleader.'aenum'[J

line 222:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Spaces\ (Left\ Justified)<tab>'.s:emapleader.'tsp^I'.s:mapleader.'tsp'[J

line 223:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Spaces\ (Right\ Justified)<tab>'.s:emapleader.'Tsp^I'.s:mapleader.'Tsp'[J

line 224:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Statements\ With\ Percent\ Style\ Comments<tab>'.s:emapleader.'m=^I'.s:mapleader.'m='[J

line 225:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Symbol\ <<tab>'.s:emapleader.'t<^I'.s:mapleader.'t<'[J

line 226:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Symbol\ \|<tab>'.s:emapleader.'t\|^I'.s:mapleader.'t|'[J

line 227:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Symbol\ @<tab>'.s:emapleader.'t@^I'.s:mapleader.'t@'[J

line 228:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Symbol\ #<tab>'.s:emapleader.'t#^I'.s:mapleader.'t#'[J

line 229:   exe 'menu '.g:DrChipTopLvlMenu.'AlignMaps.Tabs<tab>'.s:emapleader.'tab^I'.s:mapleader.'tab'[J

line 230:   unlet s:mapleader[J

line 231:   unlet s:emapleader[J

line 232:  endif[J

line 233: endif[J

line 234: [J

line 235: " =====================================================================[J

line 236: "  Restore: {{{1[J

line 237: let &cpo= s:keepcpo[J

line 238: unlet s:keepcpo[J

line 239: [J

line 240: " ==============================================================================[J

line 241: "  Modelines: {{{1[J

line 242: " vim: ts=4 nowrap fdm=marker[J

finished sourcing /Users/Eric/.vim/bundle/align/plugin/AlignMapsPlugin.vim[J
sourcing "/Users/Eric/.vim/bundle/align/plugin/AlignPlugin.vim"[J
line 1: " AlignPlugin: tool to align multiple fields based on one or more separators[J

line 2: "   Author:^I Charles E. Campbell, Jr.[J

line 3: "   Date:    Nov 02, 2008[J

line 4: " GetLatestVimScripts: 294 1 :AutoInstall: Align.vim[J

line 5: " GetLatestVimScripts: 1066 1 :AutoInstall: cecutil.vim[J

line 6: " Copyright:    Copyright (C) 1999-2007 Charles E. Campbell, Jr. {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like anything else that's free,[J

line 10: "               Align.vim is provided *as is* and comes with no warranty[J

line 11: "               of any kind, either expressed or implied. By using this[J

line 12: "               plugin, you agree that in no event will the copyright[J

line 13: "               holder be liable for any damages resulting from the use[J

line 14: "               of this software.[J

line 15: "[J

line 16: " Romans 1:16,17a : For I am not ashamed of the gospel of Christ, for it is {{{1[J

line 17: " the power of God for salvation for everyone who believes; for the Jew first,[J

line 18: " and also for the Greek.  For in it is revealed God's righteousness from[J

line 19: " faith to faith.[J

line 20: " ---------------------------------------------------------------------[J

line 21: " Load Once: {{{1[J

line 22: if &cp || exists("g:loaded_AlignPlugin")[J

line 23:  finish[J

line 24: endif[J

line 25: let g:loaded_AlignPlugin = "v35"[J

line 26: let s:keepcpo            = &cpo[J

line 27: set cpo&vim[J

line 28: [J

line 29: " ---------------------------------------------------------------------[J

line 30: " Public Interface: {{{1[J

line 31: com! -bang -range -nargs=* Align <line1>,<line2>call Align#Align(<bang>0,<q-args>)[J

line 32: com!       -range -nargs=0 AlignReplaceQuotedSpaces <line1>,<line2>call Align#AlignReplaceQuotedSpaces()[J

line 33: com!              -nargs=* AlignCtrl call Align#AlignCtrl(<q-args>)[J

line 34: com!              -nargs=0 AlignPush call Align#AlignPush()[J

line 35: com!              -nargs=0 AlignPop  call Align#AlignPop()[J

line 36: [J

line 37: " ---------------------------------------------------------------------[J

line 38: "  Restore: {{{1[J

line 39: let &cpo= s:keepcpo[J

line 40: unlet s:keepcpo[J

line 41: " vim: ts=4 fdm=marker[J

finished sourcing /Users/Eric/.vim/bundle/align/plugin/AlignPlugin.vim[J
sourcing "/Users/Eric/.vim/bundle/align/plugin/cecutil.vim"[J
line 1: " cecutil.vim : save/restore window position[J

line 2: "               save/restore mark position[J

line 3: "               save/restore selected user maps[J

line 4: "  Author:^ICharles E. Campbell, Jr.[J

line 5: "  Version:^I18b^IASTRO-ONLY[J

line 6: "  Date:^IAug 27, 2008[J

line 7: "[J

line 8: "  Saving Restoring Destroying Marks: {{{1[J

line 9: "       call SaveMark(markname)       let savemark= SaveMark(markname)[J

line 10: "       call RestoreMark(markname)    call RestoreMark(savemark)[J

line 11: "       call DestroyMark(markname)[J

line 12: "       commands: SM RM DM[J

line 13: "[J

line 14: "  Saving Restoring Destroying Window Position: {{{1[J

line 15: "       call SaveWinPosn()        let winposn= SaveWinPosn()[J

line 16: "       call RestoreWinPosn()     call RestoreWinPosn(winposn)[J

line 17: "^I^I\swp : save current window/buffer's position[J

line 18: "^I^I\rwp : restore current window/buffer's previous position[J

line 19: "       commands: SWP RWP[J

line 20: "[J

line 21: "  Saving And Restoring User Maps: {{{1[J

line 22: "       call SaveUserMaps(mapmode,maplead,mapchx,suffix)[J

line 23: "       call RestoreUserMaps(suffix)[J

line 24: "[J

line 25: " GetLatestVimScripts: 1066 1 :AutoInstall: cecutil.vim[J

line 26: "[J

line 27: " You believe that God is one. You do well. The demons also {{{1[J

line 28: " believe, and shudder. But do you want to know, vain man, that[J

line 29: " faith apart from works is dead?  (James 2:19,20 WEB)[J

line 30: [J

line 31: " ---------------------------------------------------------------------[J

line 32: " Load Once: {{{1[J

line 33: if &cp || exists("g:loaded_cecutil")[J

line 34:  finish[J

line 35: endif[J

line 36: let g:loaded_cecutil = "v18b"[J

line 37: let s:keepcpo        = &cpo[J

line 38: set cpo&vim[J

line 39: "DechoTabOn[J

line 40: [J

line 41: " =======================[J

line 42: "  Public Interface: {{{1[J

line 43: " =======================[J

line 44: [J

line 45: " ---------------------------------------------------------------------[J

line 46: "  Map Interface: {{{2[J

line 47: if !hasmapto('<Plug>SaveWinPosn')[J

line 48:  map <unique> <Leader>swp <Plug>SaveWinPosn[J

line 49: endif[J

line 50: if !hasmapto('<Plug>RestoreWinPosn')[J

line 51:  map <unique> <Leader>rwp <Plug>RestoreWinPosn[J

line 52: endif[J

line 53: nmap <silent> <Plug>SaveWinPosn^I^I:call SaveWinPosn()<CR>[J

line 54: nmap <silent> <Plug>RestoreWinPosn^I:call RestoreWinPosn()<CR>[J

line 55: [J

line 56: " ---------------------------------------------------------------------[J

line 57: " Command Interface: {{{2[J

line 58: com! -bar -nargs=0 SWP^Icall SaveWinPosn()[J

line 59: com! -bar -nargs=0 RWP^Icall RestoreWinPosn()[J

line 60: com! -bar -nargs=1 SM^Icall SaveMark(<q-args>)[J

line 61: com! -bar -nargs=1 RM^Icall RestoreMark(<q-args>)[J

line 62: com! -bar -nargs=1 DM^Icall DestroyMark(<q-args>)[J

line 63: [J

line 64: if v:version < 630[J

line 65:  let s:modifier= "sil "[J

line 66: else[J

line 67:  let s:modifier= "sil keepj "[J

line 68: endif[J

line 69: [J

line 70: " ===============[J

line 71: " Functions: {{{1[J

line 72: " ===============[J

line 73: [J

line 74: " ---------------------------------------------------------------------[J

line 75: " SaveWinPosn: {{{2[J

line 76: "    let winposn= SaveWinPosn()  will save window position in winposn variable[J

line 77: "    call SaveWinPosn()          will save window position in b:cecutil_winposn{b:cecutil_iwinposn}[J

line 78: "    let winposn= SaveWinPosn(0) will *only* save window position in winposn variable (no stacking done)[J

line 79: fun! SaveWinPosn(...)[J

line 129: [J

line 130: " ---------------------------------------------------------------------[J

line 131: " RestoreWinPosn: {{{2[J

line 132: "      call RestoreWinPosn()[J

line 133: "      call RestoreWinPosn(winposn)[J

line 134: fun! RestoreWinPosn(...)[J

line 212: [J

line 213: " ---------------------------------------------------------------------[J

line 214: " GoWinbufnr: go to window holding given buffer (by number) {{{2[J

line 215: "   Prefers current window; if its buffer number doesn't match,[J

line 216: "   then will try from topleft to bottom right[J

line 217: fun! GoWinbufnr(bufnum)[J

line 231: [J

line 232: " ---------------------------------------------------------------------[J

line 233: " SaveMark: sets up a string saving a mark position. {{{2[J

line 234: "           For example, SaveMark("a")[J

line 235: "           Also sets up a global variable, g:savemark_{markname}[J

line 236: fun! SaveMark(markname)[J

line 264: [J

line 265: " ---------------------------------------------------------------------[J

line 266: " RestoreMark: {{{2[J

line 267: "   call RestoreMark("a")  -or- call RestoreMark(savemark)[J

line 268: fun! RestoreMark(markname)[J

line 306: [J

line 307: " ---------------------------------------------------------------------[J

line 308: " DestroyMark: {{{2[J

line 309: "   call DestroyMark("a")  -- destroys mark[J

line 310: fun! DestroyMark(markname)[J

line 341: [J

line 342: " ---------------------------------------------------------------------[J

line 343: " QArgSplitter: to avoid \ processing by <f-args>, <q-args> is needed. {{{2[J

line 344: " However, <q-args> doesn't split at all, so this one returns a list[J

line 345: " with splits at all whitespace (only!), plus a leading length-of-list.[J

line 346: " The resulting list:  qarglist[0] corresponds to a:0[J

line 347: "                      qarglist[i] corresponds to a:{i}[J

line 348: fun! QArgSplitter(qarg)[J

line 356: [J

line 357: " ---------------------------------------------------------------------[J

line 358: " ListWinPosn: {{{2[J

line 359: "fun! ListWinPosn()                                                        " Decho [J

line 360: "  if !exists("b:cecutil_iwinposn") || b:cecutil_iwinposn == 0             " Decho [J

line 361: "   call Decho("nothing on SWP stack")                                     " Decho[J

line 362: "  else                                                                    " Decho[J

line 363: "   let jwinposn= b:cecutil_iwinposn                                       " Decho [J

line 364: "   while jwinposn >= 1                                                    " Decho [J

line 365: "    if exists("b:cecutil_winposn{jwinposn}")                              " Decho [J

line 366: "     call Decho("winposn{".jwinposn."}<".b:cecutil_winposn{jwinposn}.">") " Decho [J

line 367: "    else                                                                  " Decho [J

line 368: "     call Decho("winposn{".jwinposn."} -- doesn't exist")                 " Decho [J

line 369: "    endif                                                                 " Decho [J

line 370: "    let jwinposn= jwinposn - 1                                            " Decho [J

line 371: "   endwhile                                                               " Decho [J

line 372: "  endif                                                                   " Decho[J

line 373: "endfun                                                                    " Decho [J

line 374: "com! -nargs=0 LWP^Icall ListWinPosn()                                    " Decho [J

line 375: [J

line 376: " ---------------------------------------------------------------------[J

line 377: " SaveUserMaps: this function sets up a script-variable (s:restoremap) {{{2[J

line 378: "          which can be used to restore user maps later with[J

line 379: "          call RestoreUserMaps()[J

line 380: "[J

line 381: "          mapmode - see :help maparg for details (n v o i c l "")[J

line 382: "                    ex. "n" = Normal[J

line 383: "                    The letters "b" and "u" are optional prefixes;[J

line 384: "                    The "u" means that the map will also be unmapped[J

line 385: "                    The "b" means that the map has a <buffer> qualifier[J

line 386: "                    ex. "un"  = Normal + unmapping[J

line 387: "                    ex. "bn"  = Normal + <buffer>[J

line 388: "                    ex. "bun" = Normal + <buffer> + unmapping[J

line 389: "                    ex. "ubn" = Normal + <buffer> + unmapping[J

line 390: "          maplead - see mapchx[J

line 391: "          mapchx  - "<something>" handled as a single map item.[J

line 392: "                    ex. "<left>"[J

line 393: "                  - "string" a string of single letters which are actually[J

line 394: "                    multiple two-letter maps (using the maplead:[J

line 395: "                    maplead . each_character_in_string)[J

line 396: "                    ex. maplead="\" and mapchx="abc" saves user mappings for[J

line 397: "                        \a, \b, and \c[J

line 398: "                    Of course, if maplead is "", then for mapchx="abc",[J

line 399: "                    mappings for a, b, and c are saved.[J

line 400: "                  - :something  handled as a single map item, w/o the ":"[J

line 401: "                    ex.  mapchx= ":abc" will save a mapping for "abc"[J

line 402: "          suffix  - a string unique to your plugin[J

line 403: "                    ex.  suffix= "DrawIt"[J

line 404: fun! SaveUserMaps(mapmode,maplead,mapchx,suffix)[J

line 484: [J

line 485: " ---------------------------------------------------------------------[J

line 486: " RestoreUserMaps: {{{2[J

line 487: "   Used to restore user maps saved by SaveUserMaps()[J

line 488: fun! RestoreUserMaps(suffix)[J

line 500: [J

line 501: " ==============[J

line 502: "  Restore: {{{1[J

line 503: " ==============[J

line 504: let &cpo= s:keepcpo[J

line 505: unlet s:keepcpo[J

line 506: [J

line 507: " ================[J

line 508: "  Modelines: {{{1[J

line 509: " ================[J

line 510: " vim: ts=4 fdm=marker[J

finished sourcing /Users/Eric/.vim/bundle/align/plugin/cecutil.vim[J
Searching for "/Users/Eric/.vim/bundle/command-t/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/command-t/plugin/command-t.vim"[J
line 1: " command-t.vim[J

line 2: " Copyright 2010 Wincent Colaiuta. All rights reserved.[J

line 3: "[J

line 4: " Redistribution and use in source and binary forms, with or without[J

line 5: " modification, are permitted provided that the following conditions are met:[J

line 6: "[J

line 7: " 1. Redistributions of source code must retain the above copyright notice,[J

line 8: "    this list of conditions and the following disclaimer.[J

line 9: " 2. Redistributions in binary form must reproduce the above copyright notice,[J

line 10: "    this list of conditions and the following disclaimer in the documentation[J

line 11: "    and/or other materials provided with the distribution.[J

line 12: "[J

line 13: " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"[J

line 14: " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE[J

line 15: " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE[J

line 16: " ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE[J

line 17: " LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR[J

line 18: " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF[J

line 19: " SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS[J

line 20: " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN[J

line 21: " CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)[J

line 22: " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE[J

line 23: " POSSIBILITY OF SUCH DAMAGE.[J

line 24: [J

line 25: if exists("g:command_t_loaded")[J

line 26:   finish[J

line 27: endif[J

line 28: let g:command_t_loaded = 1[J

line 29: [J

line 30: command -nargs=? -complete=dir CommandT call <SID>CommandTShow(<q-args>)[J

line 31: command CommandTFlush call <SID>CommandTFlush()[J

line 32: [J

line 33: if !hasmapto('CommandT')[J

line 34:   silent! nmap <unique> <silent> <Leader>t :CommandT<CR>[J

line 35: endif[J

line 36: [J

line 37: function s:CommandTRubyWarning()[J

line 43: [J

line 44: function s:CommandTShow(arg)[J

line 51: [J

line 52: function s:CommandTFlush()[J

line 59: [J

line 60: if !has('ruby')[J

line 61:   finish[J

finished sourcing /Users/Eric/.vim/bundle/command-t/plugin/command-t.vim[J
Searching for "/Users/Eric/.vim/bundle/gist/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/gist/plugin/gist.vim"[J
line 1: "=============================================================================[J

line 2: " File: gist.vim[J

line 3: " Author: Yasuhiro Matsumoto <mattn.jp@gmail.com>[J

line 4: " Last Change: 08-Nov-2010.[J

line 5: " Version: 4.5[J

line 6: " WebPage: http://github.com/mattn/gist-vim[J

line 7: " License: BSD[J

line 8: " Usage:[J

line 9: "[J

line 10: "   :Gist[J

line 11: "     post whole text to gist.[J

line 12: "[J

line 13: "   :'<,'>Gist[J

line 14: "     post selected text to gist.[J

line 15: "[J

line 16: "   :Gist -p[J

line 17: "     post whole text to gist with private.[J

line 18: "     if you got empty gist list, try :Gist --abandon[J

line 19: "[J

line 20: "   :Gist -a[J

line 21: "     post whole text to gist with anonymous.[J

line 22: "[J

line 23: "   :Gist -m[J

line 24: "     post multi buffer to gist.[J

line 25: "[J

line 26: "   :Gist -e[J

line 27: "     edit the gist. (shoud be work on gist buffer)[J

line 28: "     you can update the gist with :w command on gist buffer.[J

line 29: "[J

line 30: "   :Gist -d[J

line 31: "     delete the gist. (should be work on gist buffer)[J

line 32: "     password authentication is needed.[J

line 33: "[J

line 34: "   :Gist -f[J

line 35: "     fork the gist. (should be work on gist buffer)[J

line 36: "     password authentication is needed.[J

line 37: "[J

line 38: "   :Gist -e foo.js[J

line 39: "     edit the gist with name 'foo.js'. (shoud be work on gist buffer)[J

line 40: "[J

line 41: "   :Gist XXXXX[J

line 42: "     edit gist XXXXX.[J

line 43: "[J

line 44: "   :Gist -c XXXXX.[J

line 45: "     get gist XXXXX and put to clipboard.[J

line 46: "[J

line 47: "   :Gist -l[J

line 48: "     list gists from mine.[J

line 49: "[J

line 50: "   :Gist -l mattn[J

line 51: "     list gists from mattn.[J

line 52: "[J

line 53: "   :Gist -la[J

line 54: "     list gists from all.[J

line 55: "[J

line 56: " Tips:[J

line 57: "   * if set g:gist_clip_command, gist.vim will copy the gist code[J

line 58: "       with option '-c'.[J

line 59: "[J

line 60: "     # mac[J

line 61: "     let g:gist_clip_command = 'pbcopy'[J

line 62: "[J

line 63: "     # linux[J

line 64: "     let g:gist_clip_command = 'xclip -selection clipboard'[J

line 65: "[J

line 66: "     # others(cygwin?)[J

line 67: "     let g:gist_clip_command = 'putclip'[J

line 68: "[J

line 69: "   * if you want to detect filetype from gist's filename...[J

line 70: "[J

line 71: "     # detect filetype if vim failed auto-detection.[J

line 72: "     let g:gist_detect_filetype = 1[J

line 73: "[J

line 74: "     # detect filetype always.[J

line 75: "     let g:gist_detect_filetype = 2[J

line 76: "[J

line 77: "   * if you want to open browser after the post...[J

line 78: "[J

line 79: "     let g:gist_open_browser_after_post = 1[J

line 80: "[J

line 81: "   * if you want to change the browser...[J

line 82: "[J

line 83: "     let g:gist_browser_command = 'w3m %URL%'[J

line 84: "[J

line 85: "       or[J

line 86: "[J

line 87: "     let g:gist_browser_command = 'opera %URL% &'[J

line 88: "[J

line 89: "     on windows, should work with original setting.[J

line 90: "[J

line 91: "   * if you want to show your private gists with ':Gist -l'[J

line 92: "[J

line 93: "     let g:gist_show_privates = 1[J

line 94: "[J

line 95: " Thanks:[J

line 96: "   MATSUU Takuto:[J

line 97: "     removed carriage return[J

line 98: "     gist_browser_command enhancement[J

line 99: "     edit support[J

line 100: "[J

line 101: " GetLatestVimScripts: 2423 1 :AutoInstall: gist.vim[J

line 102: " script type: plugin[J

line 103: [J

line 104: if &cp || (exists('g:loaded_gist_vim') && g:loaded_gist_vim)[J

line 105:   finish[J

line 106: endif[J

line 107: let g:loaded_gist_vim = 1[J

line 108: [J

line 109: if (!exists('g:github_user') || !exists('g:github_token')) && !executable('git')[J

line 110:   echoerr "Gist: require 'git' command"[J

line 111:   finish[J

line 112: endif[J

line 113: [J

line 114: if !executable('curl')[J

line 115:   echoerr "Gist: require 'curl' command"[J

line 116:   finish[J

line 117: endif[J

line 118: [J

line 119: if !exists('g:gist_open_browser_after_post')[J

line 120:   let g:gist_open_browser_after_post = 0[J

line 121: endif[J

line 122: [J

line 123: if !exists('g:gist_put_url_to_clipboard_after_post')[J

line 124:   let g:gist_put_url_to_clipboard_after_post = 1[J

line 125: endif[J

line 126: [J

line 127: if !exists('g:gist_browser_command')[J

line 128:   if has('win32')[J

line 129:     let g:gist_browser_command = "!start rundll32 url.dll,FileProtocolHandler %URL%"[J

line 130:   elseif has('mac')[J

line 131:     let g:gist_browser_command = "open %URL%"[J

line 132:   elseif executable('xdg-open')[J

line 133:     let g:gist_browser_command = "xdg-open %URL%"[J

line 134:   else[J

line 135:     let g:gist_browser_command = "firefox %URL% &"[J

line 136:   endif[J

line 137: endif[J

line 138: [J

line 139: if !exists('g:gist_detect_filetype')[J

line 140:   let g:gist_detect_filetype = 0[J

line 141: endif[J

line 142: [J

line 143: if !exists('g:gist_show_privates')[J

line 144:   let g:gist_show_privates = 0[J

line 145: endif[J

line 146: [J

line 147: function! s:nr2hex(nr)[J

line 156: [J

line 157: function! s:encodeURIComponent(instr)[J

line 175: [J

line 176: function! s:GistList(user, token, gistls, page)[J

line 247: [J

line 248: function! s:GistGetFileName(gistid)[J

line 258: [J

line 259: function! s:GistDetectFiletype(gistid)[J

line 281: [J

line 282: function! s:GistWrite(fname)[J

line 289: [J

line 290: function! s:GistGet(user, token, gistid, clipboard)[J

line 321: [J

line 322: function! s:GistListAction()[J

line 336: [J

line 337: function! s:GistUpdate(user, token, content, gistid, gistnm)[J

line 381: [J

line 382: function! s:GistGetPage(url, user, param, opt)[J

line 453: [J

line 454: function! s:GistDelete(user, token, gistid)[J

line 470: [J

line 471: [J

line 472: " GistPost function:[J

line 473: "   Post new gist to github[J

line 474: "[J

line 475: "   if there is an embedded gist url or gist id in your file,[J

line 476: "   it will just update it.[J

line 477: "                                                   -- by c9s[J

line 478: "[J

line 479: "   embedded gist url format:[J

line 480: "[J

line 481: "       Gist: https://gist.github.com/123123[J

line 482: "[J

line 483: "   embedded gist id format:[J

line 484: "[J

line 485: "       GistID: 123123[J

line 486: "[J

line 487: function! s:GistPost(user, token, content, private)[J

line 560: [J

line 561: function! s:GistPostBuffers(user, token, private)[J

line 620: [J

line 621: function! Gist(line1, line2, ...)[J

line 763: [J

line 764: command! -nargs=? -range=% Gist :call Gist(<line1>, <line2>, <f-args>)[J

line 765: " vim:set et:[J

finished sourcing /Users/Eric/.vim/bundle/gist/plugin/gist.vim[J
Searching for "/Users/Eric/.vim/bundle/nerdcommenter/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim"[J
line 1: " ============================================================================[J

line 2: " File:        NERD_commenter.vim[J

line 3: " Description: vim global plugin that provides easy code commenting[J

line 4: " Maintainer:  Martin Grenfell <martin_grenfell at msn dot com>[J

line 5: " Version:     2.2.2[J

line 6: " Last Change: 09th October, 2010[J

line 7: " License:     This program is free software. It comes without any warranty,[J

line 8: "              to the extent permitted by applicable law. You can redistribute[J

line 9: "              it and/or modify it under the terms of the Do What The Fuck You[J

line 10: "              Want To Public License, Version 2, as published by Sam Hocevar.[J

line 11: "              See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 12: "[J

line 13: " ============================================================================[J

line 14: [J

line 15: " Section: script init stuff {{{1[J

line 16: if exists("loaded_nerd_comments")[J

line 17:     finish[J

line 18: endif[J

line 19: if v:version < 700[J

line 20:     echoerr "NERDCommenter: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"[J

line 21:     finish[J

line 22: endif[J

line 23: let loaded_nerd_comments = 1[J

line 24: [J

line 25: " Function: s:InitVariable() function {{{2[J

line 26: " This function is used to initialise a given variable to a given value. The[J

line 27: " variable is only initialised if it does not exist prior[J

line 28: "[J

line 29: " Args:[J

line 30: "   -var: the name of the var to be initialised[J

line 31: "   -value: the value to initialise var to[J

line 32: "[J

line 33: " Returns:[J

line 34: "   1 if the var is set, 0 otherwise[J

line 35: function s:InitVariable(var, value)[J

line 42: [J

line 43: " Section: space string init{{{2[J

line 44: " When putting spaces after the left delim and before the right we use[J

line 45: " s:spaceStr for the space char. This way we can make it add anything after[J

line 46: " the left and before the right by modifying this variable[J

line 47: let s:spaceStr = ' '[J

line 48: let s:lenSpaceStr = strlen(s:spaceStr)[J

line 49: [J

line 50: " Section: variable init calls {{{2[J

line 51: call s:InitVariable("g:NERDAllowAnyVisualDelims", 1)[J

calling function <SNR>17_InitVariable[J('g:NERDAllowAnyVisualDelims', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDAllowAnyVisualDelims = '1'[J

line 3:         return 1[J

function <SNR>17_InitVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 52: call s:InitVariable("g:NERDBlockComIgnoreEmpty", 0)[J

calling function <SNR>17_InitVariable[J('g:NERDBlockComIgnoreEmpty', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDBlockComIgnoreEmpty = '0'[J

line 3:         return 1[J

function <SNR>17_InitVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 53: call s:InitVariable("g:NERDCommentWholeLinesInVMode", 0)[J

calling function <SNR>17_InitVariable[J('g:NERDCommentWholeLinesInVMode', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDCommentWholeLinesInVMode = '0'[J

line 3:         return 1[J

function <SNR>17_InitVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 54: call s:InitVariable("g:NERDCompactSexyComs", 0)[J

calling function <SNR>17_InitVariable[J('g:NERDCompactSexyComs', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDCompactSexyComs = '0'[J

line 3:         return 1[J

function <SNR>17_InitVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 55: call s:InitVariable("g:NERDCreateDefaultMappings", 1)[J

calling function <SNR>17_InitVariable[J('g:NERDCreateDefaultMappings', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDCreateDefaultMappings = '1'[J

line 3:         return 1[J

function <SNR>17_InitVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 56: call s:InitVariable("g:NERDDefaultNesting", 1)[J

calling function <SNR>17_InitVariable[J('g:NERDDefaultNesting', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDDefaultNesting = '1'[J

line 3:         return 1[J

function <SNR>17_InitVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 57: call s:InitVariable("g:NERDMenuMode", 3)[J

calling function <SNR>17_InitVariable[J('g:NERDMenuMode', 3)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDMenuMode = '3'[J

line 3:         return 1[J

function <SNR>17_InitVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 58: call s:InitVariable("g:NERDLPlace", "[>")[J

calling function <SNR>17_InitVariable[J('g:NERDLPlace', '[>')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDLPlace = '[>'[J

line 3:         return 1[J

function <SNR>17_InitVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 59: call s:InitVariable("g:NERDUsePlaceHolders", 1)[J

calling function <SNR>17_InitVariable[J('g:NERDUsePlaceHolders', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDUsePlaceHolders = '1'[J

line 3:         return 1[J

function <SNR>17_InitVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 60: call s:InitVariable("g:NERDRemoveAltComs", 1)[J

calling function <SNR>17_InitVariable[J('g:NERDRemoveAltComs', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDRemoveAltComs = '1'[J

line 3:         return 1[J

function <SNR>17_InitVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 61: call s:InitVariable("g:NERDRemoveExtraSpaces", 1)[J

calling function <SNR>17_InitVariable[J('g:NERDRemoveExtraSpaces', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDRemoveExtraSpaces = '1'[J

line 3:         return 1[J

function <SNR>17_InitVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 62: call s:InitVariable("g:NERDRPlace", "<]")[J

calling function <SNR>17_InitVariable[J('g:NERDRPlace', '<]')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDRPlace = '<]'[J

line 3:         return 1[J

function <SNR>17_InitVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 63: call s:InitVariable("g:NERDSpaceDelims", 0)[J

calling function <SNR>17_InitVariable[J('g:NERDSpaceDelims', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDSpaceDelims = '0'[J

line 3:         return 1[J

function <SNR>17_InitVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 64: call s:InitVariable("g:NERDDelimiterRequests", 1)[J

calling function <SNR>17_InitVariable[J('g:NERDDelimiterRequests', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDDelimiterRequests = '1'[J

line 3:         return 1[J

function <SNR>17_InitVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 65: [J

line 66: let s:NERDFileNameEscape="[]#*$%'\" ?`!&();<>\\"[J

line 67: "vf ;;dA:^[hcs"'A {^[j^f(lyi(k$p0f{a ^[A }^[0f{a 'left':^[jdd^[J

line 68: [J

line 377: let s:delimiterMap = { 'aap': { 'left': '#' }, 'abc': { 'left': '%' }, 'acedb': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' }, 'actionscript': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' }, 'ada': { 'left': '--', 'leftAlt': '--  ' }, 'ahdl': { 'left': '--' }, 'ahk': { 'left': ';', 'leftAlt': '/*', 'rightAlt': '*/' }, 'amiga': { 'left': ';' }, 'aml': { 'left': '/*' }, 'ampl': { 'left': '#' }, 'apache': { 'left': '#' }, 'apachestyle': { 'left': '#' }, 'asciidoc': { 'left': '//' }, 'applescript': { 'left': '--', 'leftAlt': '(*', 'rightAlt': '*)' }, 'asm68k': { 'left': ';' }, 'asm': { 'left': ';', 'leftAlt': '#' }, 'asn': { 'left': '--' }, 'aspvbs': { 'left': '''' }, 'asterisk': { 'left': ';' }, 'asy': { 'left': '//' }, 'atlas': { 'left': 'C', 'right': '$' }, 'autohotkey': { 'left': ';' }, 'autoit': { 'left': ';' }, 'ave': { 'left': "'" }, 'awk': { 'left': '#' }, 'basic': { 'left': "'", 'leftAlt': 'REM ' }, 'bbx': { 'left': '%' }, 'bc': { 'left': '#' }, 'bib': { 'left': '%' }, 'bindzone': { [J

line 378: [J

line 379: " Section: Comment mapping functions, autocommands and commands {{{1[J

line 380: " ============================================================================[J

line 381: " Section: Comment enabler autocommands {{{2[J

line 382: " ============================================================================[J

line 383: [J

line 384: augroup commentEnablers[J

line 385: [J

line 386:     "if the user enters a buffer or reads a buffer then we gotta set up[J

line 387:     "the comment delimiters for that new filetype[J

line 388:     autocmd BufEnter,BufRead * :call s:SetUpForNewFiletype(&filetype, 0)[J

line 389: [J

line 390:     "if the filetype of a buffer changes, force the script to reset the[J

line 391:     "delims for the buffer[J

line 392:     autocmd Filetype * :call s:SetUpForNewFiletype(&filetype, 1)[J

line 393: augroup END[J

line 394: [J

line 395: [J

line 396: " Function: s:SetUpForNewFiletype(filetype) function {{{2[J

line 397: " This function is responsible for setting up buffer scoped variables for the[J

line 398: " given filetype.[J

line 399: "[J

line 400: " Args:[J

line 401: "   -filetype: the filetype to set delimiters for[J

line 402: "   -forceReset: 1 if the delimiters should be reset if they have already be[J

line 403: "    set for this buffer.[J

line 404: "[J

line 405: function s:SetUpForNewFiletype(filetype, forceReset)[J

line 420: [J

line 421: function s:CreateDelimMapFromCms()[J

line 428: [J

line 429: " Function: s:SwitchToAlternativeDelimiters(printMsgs) function {{{2[J

line 430: " This function is used to swap the delimiters that are being used to the[J

line 431: " alternative delimiters for that filetype. For example, if a c++ file is[J

line 432: " being edited and // comments are being used, after this function is called[J

line 433: " /**/ comments will be used.[J

line 434: "[J

line 435: " Args:[J

line 436: "   -printMsgs: if this is 1 then a message is echoed to the user telling them[J

line 437: "    if this function changed the delimiters or not[J

line 438: function s:SwitchToAlternativeDelimiters(printMsgs)[J

line 467: [J

line 468: " Section: Comment delimiter add/removal functions {{{1[J

line 469: " ============================================================================[J

line 470: " Function: s:AppendCommentToLine(){{{2[J

line 471: " This function appends comment delimiters at the EOL and places the cursor in[J

line 472: " position to start typing the comment[J

line 473: function s:AppendCommentToLine()[J

line 495: [J

line 496: " Function: s:CommentBlock(top, bottom, lSide, rSide, forceNested ) {{{2[J

line 497: " This function is used to comment out a region of code. This region is[J

line 498: " specified as a bounding box by arguments to the function.[J

line 499: "[J

line 500: " Args:[J

line 501: "   -top: the line number for the top line of code in the region[J

line 502: "   -bottom: the line number for the bottom line of code in the region[J

line 503: "   -lSide: the column number for the left most column in the region[J

line 504: "   -rSide: the column number for the right most column in the region[J

line 505: "   -forceNested: a flag indicating whether comments should be nested[J

line 506: function s:CommentBlock(top, bottom, lSide, rSide, forceNested )[J

line 625: [J

line 626: " Function: s:CommentLines(forceNested, alignLeft, alignRight, firstLine, lastLine) {{{2[J

line 627: " This function comments a range of lines.[J

line 628: "[J

line 629: " Args:[J

line 630: "   -forceNested: a flag indicating whether the called is requesting the comment[J

line 631: "    to be nested if need be[J

line 632: "   -align: should be "left" or "both" or "none"[J

line 633: "   -firstLine/lastLine: the top and bottom lines to comment[J

line 634: function s:CommentLines(forceNested, align, firstLine, lastLine)[J

line 690: [J

line 691: " Function: s:CommentLinesMinimal(firstLine, lastLine) {{{2[J

line 692: " This function comments a range of lines in a minimal style. I[J

line 693: "[J

line 694: " Args:[J

line 695: "   -firstLine/lastLine: the top and bottom lines to comment[J

line 696: function s:CommentLinesMinimal(firstLine, lastLine)[J

line 742: [J

line 743: " Function: s:CommentLinesSexy(topline, bottomline) function {{{2[J

line 744: " This function is used to comment lines in the 'Sexy' style. eg in c:[J

line 745: " /*[J

line 746: "  * This is a sexy comment[J

line 747: "  */[J

line 748: " Args:[J

line 749: "   -topline: the line num of the top line in the sexy comment[J

line 750: "   -bottomline: the line num of the bottom line in the sexy comment[J

line 751: function s:CommentLinesSexy(topline, bottomline)[J

line 860: [J

line 861: " Function: s:CommentLinesToggle(forceNested, firstLine, lastLine) {{{2[J

line 862: " Applies "toggle" commenting to the given range of lines[J

line 863: "[J

line 864: " Args:[J

line 865: "   -forceNested: a flag indicating whether the called is requesting the comment[J

line 866: "    to be nested if need be[J

line 867: "   -firstLine/lastLine: the top and bottom lines to comment[J

line 868: function s:CommentLinesToggle(forceNested, firstLine, lastLine)[J

line 899: [J

line 900: " Function: s:CommentRegion(topline, topCol, bottomLine, bottomCol) function {{{2[J

line 901: " This function comments chunks of text selected in visual mode.[J

line 902: " It will comment exactly the text that they have selected.[J

line 903: " Args:[J

line 904: "   -topLine: the line num of the top line in the sexy comment[J

line 905: "   -topCol: top left col for this comment[J

line 906: "   -bottomline: the line num of the bottom line in the sexy comment[J

line 907: "   -bottomCol: the bottom right col for this comment[J

line 908: "   -forceNested: whether the caller wants comments to be nested if the[J

line 909: "    line(s) are already commented[J

line 910: function s:CommentRegion(topLine, topCol, bottomLine, bottomCol, forceNested)[J

line 951: [J

line 952: " Function: s:InvertComment(firstLine, lastLine) function {{{2[J

line 953: " Inverts the comments on the lines between and including the given line[J

line 954: " numbers i.e all commented lines are uncommented and vice versa[J

line 955: " Args:[J

line 956: "   -firstLine: the top of the range of lines to be inverted[J

line 957: "   -lastLine: the bottom of the range of lines to be inverted[J

line 958: function s:InvertComment(firstLine, lastLine)[J

line 989: [J

line 990: " Function: NERDComment(isVisual, type) function {{{2[J

line 991: " This function is a Wrapper for the main commenting functions[J

line 992: "[J

line 993: " Args:[J

line 994: "   -isVisual: a flag indicating whether the comment is requested in visual[J

line 995: "    mode or not[J

line 996: "   -type: the type of commenting requested. Can be 'sexy', 'invert',[J

line 997: "    'minimal', 'toggle', 'alignLeft', 'alignBoth', 'norm',[J

line 998: "    'nested', 'toEOL', 'append', 'insert', 'uncomment', 'yank'[J

line 999: function! NERDComment(isVisual, type) range[J

line 1093: [J

line 1094: " Function: s:PlaceDelimitersAndInsBetween() function {{{2[J

line 1095: " This is function is called to place comment delimiters down and place the[J

line 1096: " cursor between them[J

line 1097: function s:PlaceDelimitersAndInsBetween()[J

line 1147: [J

line 1148: " Function: s:RemoveDelimiters(left, right, line) {{{2[J

line 1149: " this function is called to remove the first left comment delimiter and the[J

line 1150: " last right delimiter of the given line.[J

line 1151: "[J

line 1152: " The args left and right must be strings. If there is no right delimiter (as[J

line 1153: " is the case for e.g vim file comments) them the arg right should be ""[J

line 1154: "[J

line 1155: " Args:[J

line 1156: "   -left: the left comment delimiter[J

line 1157: "   -right: the right comment delimiter[J

line 1158: "   -line: the line to remove the delimiters from[J

line 1159: function s:RemoveDelimiters(left, right, line)[J

line 1196: [J

line 1197: " Function: s:UncommentLines(topLine, bottomLine) {{{2[J

line 1198: " This function uncomments the given lines[J

line 1199: "[J

line 1200: " Args:[J

line 1201: " topLine: the top line of the visual selection to uncomment[J

line 1202: " bottomLine: the bottom line of the visual selection to uncomment[J

line 1203: function s:UncommentLines(topLine, bottomLine)[J

line 1242: [J

line 1243: " Function: s:UncommentLinesSexy(topline, bottomline) {{{2[J

line 1244: " This function removes all the comment characters associated with the sexy[J

line 1245: " comment spanning the given lines[J

line 1246: " Args:[J

line 1247: "   -topline/bottomline: the top/bottom lines of the sexy comment[J

line 1248: function s:UncommentLinesSexy(topline, bottomline)[J

line 1359: [J

line 1360: " Function: s:UncommentLineNormal(line) {{{2[J

line 1361: " uncomments the given line and returns the result[J

line 1362: " Args:[J

line 1363: "   -line: the line to uncomment[J

line 1364: function s:UncommentLineNormal(line)[J

line 1437: [J

line 1438: " Function: s:UncommentLinesNormal(topline, bottomline) {{{2[J

line 1439: " This function is called to uncomment lines that arent a sexy comment[J

line 1440: " Args:[J

line 1441: "   -topline/bottomline: the top/bottom line numbers of the comment[J

line 1442: function s:UncommentLinesNormal(topline, bottomline)[J

line 1450: [J

line 1451: [J

line 1452: " Section: Other helper functions {{{1[J

line 1453: " ============================================================================[J

line 1454: [J

line 1455: " Function: s:AddLeftDelim(delim, theLine) {{{2[J

line 1456: " Args:[J

line 1457: function s:AddLeftDelim(delim, theLine)[J

line 1460: [J

line 1461: " Function: s:AddLeftDelimAligned(delim, theLine) {{{2[J

line 1462: " Args:[J

line 1463: function s:AddLeftDelimAligned(delim, theLine, alignIndx)[J

line 1474: [J

line 1475: " Function: s:AddRightDelim(delim, theLine) {{{2[J

line 1476: " Args:[J

line 1477: function s:AddRightDelim(delim, theLine)[J

line 1484: [J

line 1485: " Function: s:AddRightDelimAligned(delim, theLine, alignIndx) {{{2[J

line 1486: " Args:[J

line 1487: function s:AddRightDelimAligned(delim, theLine, alignIndx)[J

line 1502: [J

line 1503: " Function: s:AltMultipart() {{{2[J

line 1504: " returns 1 if the alternative delims are multipart[J

line 1505: function s:AltMultipart()[J

line 1508: [J

line 1509: " Function: s:CanCommentLine(forceNested, line) {{{2[J

line 1510: "This function is used to determine whether the given line can be commented.[J

line 1511: "It returns 1 if it can be and 0 otherwise[J

line 1512: "[J

line 1513: " Args:[J

line 1514: "   -forceNested: a flag indicating whether the caller wants comments to be nested[J

line 1515: "    if the current line is already commented[J

line 1516: "   -lineNum: the line num of the line to check for commentability[J

line 1517: function s:CanCommentLine(forceNested, lineNum)[J

line 1544: [J

line 1545: " Function: s:CanPlaceCursor(line, col) {{{2[J

line 1546: " returns 1 if the cursor can be placed exactly in the given position[J

line 1547: function s:CanPlaceCursor(line, col)[J

line 1555: [J

line 1556: " Function: s:CanSexyCommentLines(topline, bottomline) {{{2[J

line 1557: " Return: 1 if the given lines can be commented sexually, 0 otherwise[J

line 1558: function s:CanSexyCommentLines(topline, bottomline)[J

line 1569: " Function: s:CanToggleCommentLine(forceNested, line) {{{2[J

line 1570: "This function is used to determine whether the given line can be toggle commented.[J

line 1571: "It returns 1 if it can be and 0 otherwise[J

line 1572: "[J

line 1573: " Args:[J

line 1574: "   -lineNum: the line num of the line to check for commentability[J

line 1575: function s:CanToggleCommentLine(forceNested, lineNum)[J

line 1593: [J

line 1594: " Function: s:ConvertLeadingSpacesToTabs(line) {{{2[J

line 1595: " This function takes a line and converts all leading tabs on that line into[J

line 1596: " spaces[J

line 1597: "[J

line 1598: " Args:[J

line 1599: "   -line: the line whose leading tabs will be converted[J

line 1600: function s:ConvertLeadingSpacesToTabs(line)[J

line 1608: [J

line 1609: [J

line 1610: " Function: s:ConvertLeadingTabsToSpaces(line) {{{2[J

line 1611: " This function takes a line and converts all leading spaces on that line into[J

line 1612: " tabs[J

line 1613: "[J

line 1614: " Args:[J

line 1615: "   -line: the line whose leading spaces will be converted[J

line 1616: function s:ConvertLeadingTabsToSpaces(line)[J

line 1624: [J

line 1625: " Function: s:ConvertLeadingWhiteSpace(line) {{{2[J

line 1626: " Converts the leading white space to tabs/spaces depending on &ts[J

line 1627: "[J

line 1628: " Args:[J

line 1629: "   -line: the line to convert[J

line 1630: function s:ConvertLeadingWhiteSpace(line)[J

line 1642: [J

line 1643: [J

line 1644: " Function: s:CountNonESCedOccurances(str, searchstr, escChar) {{{2[J

line 1645: " This function counts the number of substrings contained in another string.[J

line 1646: " These substrings are only counted if they are not escaped with escChar[J

line 1647: " Args:[J

line 1648: "   -str: the string to look for searchstr in[J

line 1649: "   -searchstr: the substring to search for in str[J

line 1650: "   -escChar: the escape character which, when preceding an instance of[J

line 1651: "    searchstr, will cause it not to be counted[J

line 1652: function s:CountNonESCedOccurances(str, searchstr, escChar)[J

line 1671: " Function: s:DoesBlockHaveDelim(delim, top, bottom) {{{2[J

line 1672: " Returns 1 if the given block of lines has a delimiter (a:delim) in it[J

line 1673: " Args:[J

line 1674: "   -delim: the comment delimiter to check the block for[J

line 1675: "   -top: the top line number of the block[J

line 1676: "   -bottom: the bottom line number of the block[J

line 1677: function s:DoesBlockHaveDelim(delim, top, bottom)[J

line 1688: [J

line 1689: " Function: s:DoesBlockHaveMultipartDelim(top, bottom) {{{2[J

line 1690: " Returns 1 if the given block has a >= 1 multipart delimiter in it[J

line 1691: " Args:[J

line 1692: "   -top: the top line number of the block[J

line 1693: "   -bottom: the bottom line number of the block[J

line 1694: function s:DoesBlockHaveMultipartDelim(top, bottom)[J

line 1704: [J

line 1705: [J

line 1706: " Function: s:Esc(str) {{{2[J

line 1707: " Escapes all the tricky chars in the given string[J

line 1708: function s:Esc(str)[J

line 1712: [J

line 1713: " Function: s:FindDelimiterIndex(delimiter, line) {{{2[J

line 1714: " This function is used to get the string index of the input comment delimiter[J

line 1715: " on the input line. If no valid comment delimiter is found in the line then[J

line 1716: " -1 is returned[J

line 1717: " Args:[J

line 1718: "   -delimiter: the delimiter we are looking to find the index of[J

line 1719: "   -line: the line we are looking for delimiter on[J

line 1720: function s:FindDelimiterIndex(delimiter, line)[J

line 1765: [J

line 1766: " Function: s:FindBoundingLinesOfSexyCom(lineNum) {{{2[J

line 1767: " This function takes in a line number and tests whether this line number is[J

line 1768: " the top/bottom/middle line of a sexy comment. If it is then the top/bottom[J

line 1769: " lines of the sexy comment are returned[J

line 1770: " Args:[J

line 1771: "   -lineNum: the line number that is to be tested whether it is the[J

line 1772: "    top/bottom/middle line of a sexy com[J

line 1773: " Returns:[J

line 1774: "   A string that has the top/bottom lines of the sexy comment encoded in it.[J

line 1775: "   The format is 'topline,bottomline'. If a:lineNum turns out not to be the[J

line 1776: "   top/bottom/middle of a sexy comment then -1 is returned[J

line 1777: function s:FindBoundingLinesOfSexyCom(lineNum)[J

line 1839: [J

line 1840: [J

line 1841: " Function: s:GetSexyComMarker() {{{2[J

line 1842: " Returns the sexy comment marker for the current filetype.[J

line 1843: "[J

line 1844: " C style sexy comments are assumed if possible. If not then the sexy comment[J

line 1845: " marker is the last char of the delimiter pair that has both left and right[J

line 1846: " delims and has the longest left delim[J

line 1847: "[J

line 1848: " Args:[J

line 1849: "   -space: specifies whether the marker is to have a space string after it[J

line 1850: "    (the space string will only be added if NERDSpaceDelims is set)[J

line 1851: "   -esc: specifies whether the tricky chars in the marker are to be ESCed[J

line 1852: function s:GetSexyComMarker(space, esc)[J

line 1892: [J

line 1893: " Function: s:GetSexyComLeft(space, esc) {{{2[J

line 1894: " Returns the left delimiter for sexy comments for this filetype or -1 if[J

line 1895: " there is none. C style sexy comments are used if possible[J

line 1896: " Args:[J

line 1897: "   -space: specifies if the delim has a space string on the end[J

line 1898: "   (the space string will only be added if NERDSpaceDelims is set)[J

line 1899: "   -esc: specifies whether the tricky chars in the string are ESCed[J

line 1900: function s:GetSexyComLeft(space, esc)[J

line 1929: [J

line 1930: " Function: s:GetSexyComRight(space, esc) {{{2[J

line 1931: " Returns the right delimiter for sexy comments for this filetype or -1 if[J

line 1932: " there is none. C style sexy comments are used if possible.[J

line 1933: " Args:[J

line 1934: "   -space: specifies if the delim has a space string on the start[J

line 1935: "   (the space string will only be added if NERDSpaceDelims[J

line 1936: "   is specified for the current filetype)[J

line 1937: "   -esc: specifies whether the tricky chars in the string are ESCed[J

line 1938: function s:GetSexyComRight(space, esc)[J

line 1967: [J

line 1968: " Function: s:HasMultipartDelims() {{{2[J

line 1969: " Returns 1 iff the current filetype has at least one set of multipart delims[J

line 1970: function s:HasMultipartDelims()[J

line 1973: [J

line 1974: " Function: s:HasLeadingTabs(...) {{{2[J

line 1975: " Returns 1 if any of the given strings have leading tabs[J

line 1976: function s:HasLeadingTabs(...)[J

line 1984: " Function: s:HasCStyleComments() {{{2[J

line 1985: " Returns 1 iff the current filetype has c style comment delimiters[J

line 1986: function s:HasCStyleComments()[J

line 1989: [J

line 1990: " Function: s:IsCommentedNormOrSexy(lineNum) {{{2[J

line 1991: "This function is used to determine whether the given line is commented with[J

line 1992: "either set of delimiters or if it is part of a sexy comment[J

line 1993: "[J

line 1994: " Args:[J

line 1995: "   -lineNum: the line number of the line to check[J

line 1996: function s:IsCommentedNormOrSexy(lineNum)[J

line 2010: [J

line 2011: " Function: s:IsCommented(left, right, line) {{{2[J

line 2012: "This function is used to determine whether the given line is commented with[J

line 2013: "the given delimiters[J

line 2014: "[J

line 2015: " Args:[J

line 2016: "   -line: the line that to check if commented[J

line 2017: "   -left/right: the left and right delimiters to check for[J

line 2018: function s:IsCommented(left, right, line)[J

line 2025: [J

line 2026: " Function: s:IsCommentedFromStartOfLine(left, line) {{{2[J

line 2027: "This function is used to determine whether the given line is commented with[J

line 2028: "the given delimiters at the start of the line i.e the left delimiter is the[J

line 2029: "first thing on the line (apart from spaces\tabs)[J

line 2030: "[J

line 2031: " Args:[J

line 2032: "   -line: the line that to check if commented[J

line 2033: "   -left: the left delimiter to check for[J

line 2034: function s:IsCommentedFromStartOfLine(left, line)[J

line 2040: [J

line 2041: " Function: s:IsCommentedOuttermost(left, right, leftAlt, rightAlt, line) {{{2[J

line 2042: " Finds the type of the outtermost delims on the line[J

line 2043: "[J

line 2044: " Args:[J

line 2045: "   -line: the line that to check if the outtermost comments on it are[J

line 2046: "    left/right[J

line 2047: "   -left/right: the left and right delimiters to check for[J

line 2048: "   -leftAlt/rightAlt: the left and right alternative delimiters to check for[J

line 2049: "[J

line 2050: " Returns:[J

line 2051: "   0 if the line is not commented with either set of delims[J

line 2052: "   1 if the line is commented with the left/right delim set[J

line 2053: "   2 if the line is commented with the leftAlt/rightAlt delim set[J

line 2054: function s:IsCommentedOuttermost(left, right, leftAlt, rightAlt, line)[J

line 2082: [J

line 2083: [J

line 2084: " Function: s:IsDelimValid(delimiter, delIndx, line) {{{2[J

line 2085: " This function is responsible for determining whether a given instance of a[J

line 2086: " comment delimiter is a real delimiter or not. For example, in java the[J

line 2087: " // string is a comment delimiter but in the line:[J

line 2088: "               System.out.println("//");[J

line 2089: " it does not count as a comment delimiter. This function is responsible for[J

line 2090: " distinguishing between such cases. It does so by applying a set of[J

line 2091: " heuristics that are not fool proof but should work most of the time.[J

line 2092: "[J

line 2093: " Args:[J

line 2094: "   -delimiter: the delimiter we are validating[J

line 2095: "   -delIndx: the position of delimiter in line[J

line 2096: "   -line: the line that delimiter occurs in[J

line 2097: "[J

line 2098: " Returns:[J

line 2099: " 0 if the given delimiter is not a real delimiter (as far as we can tell) ,[J

line 2100: " 1 otherwise[J

line 2101: function s:IsDelimValid(delimiter, delIndx, line)[J

line 2160: [J

line 2161: " Function: s:IsNumEven(num) {{{2[J

line 2162: " A small function the returns 1 if the input number is even and 0 otherwise[J

line 2163: " Args:[J

line 2164: "   -num: the number to check[J

line 2165: function s:IsNumEven(num)[J

line 2168: [J

line 2169: " Function: s:IsEscaped(str, indx, escChar) {{{2[J

line 2170: " This function takes a string, an index into that string and an esc char and[J

line 2171: " returns 1 if the char at the index is escaped (i.e if it is preceded by an[J

line 2172: " odd number of esc chars)[J

line 2173: " Args:[J

line 2174: "   -str: the string to check[J

line 2175: "   -indx: the index into str that we want to check[J

line 2176: "   -escChar: the escape char the char at indx may be ESCed with[J

line 2177: function s:IsEscaped(str, indx, escChar)[J

line 2197: [J

line 2198: " Function: s:IsInSexyComment(line) {{{2[J

line 2199: " returns 1 if the given line number is part of a sexy comment[J

line 2200: function s:IsInSexyComment(line)[J

line 2203: [J

line 2204: " Function: s:IsSexyComment(topline, bottomline) {{{2[J

line 2205: " This function takes in 2 line numbers and returns 1 if the lines between and[J

line 2206: " including the given line numbers are a sexy comment. It returns 0 otherwise.[J

line 2207: " Args:[J

line 2208: "   -topline: the line that the possible sexy comment starts on[J

line 2209: "   -bottomline: the line that the possible sexy comment stops on[J

line 2210: function s:IsSexyComment(topline, bottomline)[J

line 2284: [J

line 2285: " Function: s:LastIndexOfDelim(delim, str) {{{2[J

line 2286: " This function takes a string and a delimiter and returns the last index of[J

line 2287: " that delimiter in string[J

line 2288: " Args:[J

line 2289: "   -delim: the delimiter to look for[J

line 2290: "   -str: the string to look for delim in[J

line 2291: function s:LastIndexOfDelim(delim, str)[J

line 2322: [J

line 2323: " Function: s:Left(...) {{{2[J

line 2324: " returns left delimiter data[J

line 2325: function s:Left(...)[J

line 2344: [J

line 2345: " Function: s:LeftMostIndx(countCommentedLines, countEmptyLines, topline, bottomline) {{{2[J

line 2346: " This function takes in 2 line numbers and returns the index of the left most[J

line 2347: " char (that is not a space or a tab) on all of these lines.[J

line 2348: " Args:[J

line 2349: "   -countCommentedLines: 1 if lines that are commented are to be checked as[J

line 2350: "    well. 0 otherwise[J

line 2351: "   -countEmptyLines: 1 if empty lines are to be counted in the search[J

line 2352: "   -topline: the top line to be checked[J

line 2353: "   -bottomline: the bottom line to be checked[J

line 2354: function s:LeftMostIndx(countCommentedLines, countEmptyLines, topline, bottomline)[J

line 2388: [J

line 2389: " Function: s:Multipart() {{{2[J

line 2390: " returns 1 if the current delims are multipart[J

line 2391: function s:Multipart()[J

line 2394: [J

line 2395: " Function: s:NerdEcho(msg, typeOfMsg) {{{2[J

line 2396: " Args:[J

line 2397: "   -msg: the message to echo[J

line 2398: "   -typeOfMsg: 0 = warning message[J

line 2399: "               1 = normal message[J

line 2400: function s:NerdEcho(msg, typeOfMsg)[J

line 2409: [J

line 2410: " Function: s:NumberOfLeadingTabs(s) {{{2[J

line 2411: " returns the number of leading tabs in the given string[J

line 2412: function s:NumberOfLeadingTabs(s)[J

line 2415: [J

line 2416: " Function: s:NumLinesInBuf() {{{2[J

line 2417: " Returns the number of lines in the current buffer[J

line 2418: function s:NumLinesInBuf()[J

line 2421: [J

line 2422: " Function: s:ReplaceDelims(toReplace1, toReplace2, replacor1, replacor2, str) {{{2[J

line 2423: " This function takes in a string, 2 delimiters in that string and 2 strings[J

line 2424: " to replace these delimiters with.[J

line 2425: "[J

line 2426: " Args:[J

line 2427: "   -toReplace1: the first delimiter to replace[J

line 2428: "   -toReplace2: the second delimiter to replace[J

line 2429: "   -replacor1: the string to replace toReplace1 with[J

line 2430: "   -replacor2: the string to replace toReplace2 with[J

line 2431: "   -str: the string that the delimiters to be replaced are in[J

line 2432: function s:ReplaceDelims(toReplace1, toReplace2, replacor1, replacor2, str)[J

line 2437: [J

line 2438: " Function: s:ReplaceLeftMostDelim(toReplace, replacor, str) {{{2[J

line 2439: " This function takes a string and a delimiter and replaces the left most[J

line 2440: " occurrence of this delimiter in the string with a given string[J

line 2441: "[J

line 2442: " Args:[J

line 2443: "   -toReplace: the delimiter in str that is to be replaced[J

line 2444: "   -replacor: the string to replace toReplace with[J

line 2445: "   -str: the string that contains toReplace[J

line 2446: function s:ReplaceLeftMostDelim(toReplace, replacor, str)[J

line 2461: [J

line 2462: " Function: s:ReplaceRightMostDelim(toReplace, replacor, str) {{{2[J

line 2463: " This function takes a string and a delimiter and replaces the right most[J

line 2464: " occurrence of this delimiter in the string with a given string[J

line 2465: "[J

line 2466: " Args:[J

line 2467: "   -toReplace: the delimiter in str that is to be replaced[J

line 2468: "   -replacor: the string to replace toReplace with[J

line 2469: "   -str: the string that contains toReplace[J

line 2470: "[J

line 2471: function s:ReplaceRightMostDelim(toReplace, replacor, str)[J

line 2486: [J

line 2487: "FUNCTION: s:RestoreScreenState() {{{2[J

line 2488: "[J

line 2489: "Sets the screen state back to what it was when s:SaveScreenState was last[J

line 2490: "called.[J

line 2491: "[J

line 2492: function s:RestoreScreenState()[J

line 2501: [J

line 2502: " Function: s:Right(...) {{{2[J

line 2503: " returns right delimiter data[J

line 2504: function s:Right(...)[J

line 2523: [J

line 2524: " Function: s:RightMostIndx(countCommentedLines, countEmptyLines, topline, bottomline) {{{2[J

line 2525: " This function takes in 2 line numbers and returns the index of the right most[J

line 2526: " char on all of these lines.[J

line 2527: " Args:[J

line 2528: "   -countCommentedLines: 1 if lines that are commented are to be checked as[J

line 2529: "    well. 0 otherwise[J

line 2530: "   -countEmptyLines: 1 if empty lines are to be counted in the search[J

line 2531: "   -topline: the top line to be checked[J

line 2532: "   -bottomline: the bottom line to be checked[J

line 2533: function s:RightMostIndx(countCommentedLines, countEmptyLines, topline, bottomline)[J

line 2562: [J

line 2563: "FUNCTION: s:SaveScreenState() {{{2[J

line 2564: "Saves the current cursor position in the current buffer and the window[J

line 2565: "scroll position[J

line 2566: function s:SaveScreenState()[J

line 2570: [J

line 2571: " Function: s:SwapOutterMultiPartDelimsForPlaceHolders(line) {{{2[J

line 2572: " This function takes a line and swaps the outter most multi-part delims for[J

line 2573: " place holders[J

line 2574: " Args:[J

line 2575: "   -line: the line to swap the delims in[J

line 2576: "[J

line 2577: function s:SwapOutterMultiPartDelimsForPlaceHolders(line)[J

line 2598: [J

line 2599: " Function: s:SwapOutterPlaceHoldersForMultiPartDelims(line) {{{2[J

line 2600: " This function takes a line and swaps the outtermost place holders for[J

line 2601: " multi-part delims[J

line 2602: " Args:[J

line 2603: "   -line: the line to swap the delims in[J

line 2604: "[J

line 2605: function s:SwapOutterPlaceHoldersForMultiPartDelims(line)[J

line 2619: " Function: s:TabbedCol(line, col) {{{2[J

line 2620: " Gets the col number for given line and existing col number. The new col[J

line 2621: " number is the col number when all leading spaces are converted to tabs[J

line 2622: " Args:[J

line 2623: "   -line:the line to get the rel col for[J

line 2624: "   -col: the abs col[J

line 2625: function s:TabbedCol(line, col)[J

line 2630: "FUNCTION: s:TabSpace() {{{2[J

line 2631: "returns a string of spaces equal in length to &tabstop[J

line 2632: function s:TabSpace()[J

line 2641: [J

line 2642: " Function: s:UnEsc(str, escChar) {{{2[J

line 2643: " This function removes all the escape chars from a string[J

line 2644: " Args:[J

line 2645: "   -str: the string to remove esc chars from[J

line 2646: "   -escChar: the escape char to be removed[J

line 2647: function s:UnEsc(str, escChar)[J

line 2650: [J

line 2651: " Function: s:UntabbedCol(line, col) {{{2[J

line 2652: " Takes a line and a col and returns the absolute column of col taking into[J

line 2653: " account that a tab is worth 3 or 4 (or whatever) spaces.[J

line 2654: " Args:[J

line 2655: "   -line:the line to get the abs col for[J

line 2656: "   -col: the col that doesnt take into account tabs[J

line 2657: function s:UntabbedCol(line, col)[J

line 2662: " Section: Comment mapping setup {{{1[J

line 2663: " ===========================================================================[J

line 2664: [J

line 2665: " switch to/from alternative delimiters[J

line 2666: nnoremap <plug>NERDCommenterAltDelims :call <SID>SwitchToAlternativeDelimiters(1)<cr>[J

line 2667: [J

line 2668: " comment out lines[J

line 2669: nnoremap <silent> <plug>NERDCommenterComment :call NERDComment(0, "norm")<cr>[J

line 2670: vnoremap <silent> <plug>NERDCommenterComment <ESC>:call NERDComment(1, "norm")<cr>[J

line 2671: [J

line 2672: " toggle comments[J

line 2673: nnoremap <silent> <plug>NERDCommenterToggle :call NERDComment(0, "toggle")<cr>[J

line 2674: vnoremap <silent> <plug>NERDCommenterToggle <ESC>:call NERDComment(1, "toggle")<cr>[J

line 2675: [J

line 2676: " minimal comments[J

line 2677: nnoremap <silent> <plug>NERDCommenterMinimal :call NERDComment(0, "minimal")<cr>[J

line 2678: vnoremap <silent> <plug>NERDCommenterMinimal <ESC>:call NERDComment(1, "minimal")<cr>[J

line 2679: [J

line 2680: " sexy comments[J

line 2681: nnoremap <silent> <plug>NERDCommenterSexy :call NERDComment(0, "sexy")<CR>[J

line 2682: vnoremap <silent> <plug>NERDCommenterSexy <ESC>:call NERDComment(1, "sexy")<CR>[J

line 2683: [J

line 2684: " invert comments[J

line 2685: nnoremap <silent> <plug>NERDCommenterInvert :call NERDComment(0, "invert")<CR>[J

line 2686: vnoremap <silent> <plug>NERDCommenterInvert <ESC>:call NERDComment(1, "invert")<CR>[J

line 2687: [J

line 2688: " yank then comment[J

line 2689: nmap <silent> <plug>NERDCommenterYank :call NERDComment(0, "yank")<CR>[J

line 2690: vmap <silent> <plug>NERDCommenterYank <ESC>:call NERDComment(1, "yank")<CR>[J

line 2691: [J

line 2692: " left aligned comments[J

line 2693: nnoremap <silent> <plug>NERDCommenterAlignLeft :call NERDComment(0, "alignLeft")<cr>[J

line 2694: vnoremap <silent> <plug>NERDCommenterAlignLeft <ESC>:call NERDComment(1, "alignLeft")<cr>[J

line 2695: [J

line 2696: " left and right aligned comments[J

line 2697: nnoremap <silent> <plug>NERDCommenterAlignBoth :call NERDComment(0, "alignBoth")<cr>[J

line 2698: vnoremap <silent> <plug>NERDCommenterAlignBoth <ESC>:call NERDComment(1, "alignBoth")<cr>[J

line 2699: [J

line 2700: " nested comments[J

line 2701: nnoremap <silent> <plug>NERDCommenterNest :call NERDComment(0, "nested")<cr>[J

line 2702: vnoremap <silent> <plug>NERDCommenterNest <ESC>:call NERDComment(1, "nested")<cr>[J

line 2703: [J

line 2704: " uncomment[J

line 2705: nnoremap <silent> <plug>NERDCommenterUncomment :call NERDComment(0, "uncomment")<cr>[J

line 2706: vnoremap <silent> <plug>NERDCommenterUncomment :call NERDComment(1, "uncomment")<cr>[J

line 2707: [J

line 2708: " comment till the end of the line[J

line 2709: nnoremap <silent> <plug>NERDCommenterToEOL :call NERDComment(0, "toEOL")<cr>[J

line 2710: [J

line 2711: " append comments[J

line 2712: nmap <silent> <plug>NERDCommenterAppend :call NERDComment(0, "append")<cr>[J

line 2713: [J

line 2714: " insert comments[J

line 2715: inoremap <silent> <plug>NERDCommenterInInsert <SPACE><BS><ESC>:call NERDComment(0, "insert")<CR>[J

line 2716: [J

line 2717: [J

line 2718: function! s:CreateMaps(target, combo)[J

line 2727: [J

line 2728: if g:NERDCreateDefaultMappings[J

line 2729:     call s:CreateMaps('<plug>NERDCommenterComment',    '<leader>cc')[J

calling function <SNR>17_CreateMaps[J('<plug>NERDCommenterComment', '<leader>cc')

line 1:     if !hasmapto(a:target, 'n')[J

line 2:         exec 'nmap ' . a:combo . ' ' . a:target[J

line 2: nmap <leader>cc <plug>NERDCommenterComment[J

line 3:     endif[J

line 4: [J

line 5:     if !hasmapto(a:target, 'v')[J

line 6:         exec 'vmap ' . a:combo . ' ' . a:target[J

line 6: vmap <leader>cc <plug>NERDCommenterComment[J

line 7:     endif[J

function <SNR>17_CreateMaps returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2730:     call s:CreateMaps('<plug>NERDCommenterToggle',     '<leader>c<space>')[J

calling function <SNR>17_CreateMaps[J('<plug>NERDCommenterToggle', '<leader>c<space>')

line 1:     if !hasmapto(a:target, 'n')[J

line 2:         exec 'nmap ' . a:combo . ' ' . a:target[J

line 2: nmap <leader>c<space> <plug>NERDCommenterToggle[J

line 3:     endif[J

line 4: [J

line 5:     if !hasmapto(a:target, 'v')[J

line 6:         exec 'vmap ' . a:combo . ' ' . a:target[J

line 6: vmap <leader>c<space> <plug>NERDCommenterToggle[J

line 7:     endif[J

function <SNR>17_CreateMaps returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2731:     call s:CreateMaps('<plug>NERDCommenterMinimal',    '<leader>cm')[J

calling function <SNR>17_CreateMaps[J('<plug>NERDCommenterMinimal', '<leader>cm')

line 1:     if !hasmapto(a:target, 'n')[J

line 2:         exec 'nmap ' . a:combo . ' ' . a:target[J

line 2: nmap <leader>cm <plug>NERDCommenterMinimal[J

line 3:     endif[J

line 4: [J

line 5:     if !hasmapto(a:target, 'v')[J

line 6:         exec 'vmap ' . a:combo . ' ' . a:target[J

line 6: vmap <leader>cm <plug>NERDCommenterMinimal[J

line 7:     endif[J

function <SNR>17_CreateMaps returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2732:     call s:CreateMaps('<plug>NERDCommenterSexy',       '<leader>cs')[J

calling function <SNR>17_CreateMaps[J('<plug>NERDCommenterSexy', '<leader>cs')

line 1:     if !hasmapto(a:target, 'n')[J

line 2:         exec 'nmap ' . a:combo . ' ' . a:target[J

line 2: nmap <leader>cs <plug>NERDCommenterSexy[J

line 3:     endif[J

line 4: [J

line 5:     if !hasmapto(a:target, 'v')[J

line 6:         exec 'vmap ' . a:combo . ' ' . a:target[J

line 6: vmap <leader>cs <plug>NERDCommenterSexy[J

line 7:     endif[J

function <SNR>17_CreateMaps returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2733:     call s:CreateMaps('<plug>NERDCommenterInvert',     '<leader>ci')[J

calling function <SNR>17_CreateMaps[J('<plug>NERDCommenterInvert', '<leader>ci')

line 1:     if !hasmapto(a:target, 'n')[J

line 2:         exec 'nmap ' . a:combo . ' ' . a:target[J

line 2: nmap <leader>ci <plug>NERDCommenterInvert[J

line 3:     endif[J

line 4: [J

line 5:     if !hasmapto(a:target, 'v')[J

line 6:         exec 'vmap ' . a:combo . ' ' . a:target[J

line 6: vmap <leader>ci <plug>NERDCommenterInvert[J

line 7:     endif[J

function <SNR>17_CreateMaps returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2734:     call s:CreateMaps('<plug>NERDCommenterYank',       '<leader>cy')[J

calling function <SNR>17_CreateMaps[J('<plug>NERDCommenterYank', '<leader>cy')

line 1:     if !hasmapto(a:target, 'n')[J

line 2:         exec 'nmap ' . a:combo . ' ' . a:target[J

line 2: nmap <leader>cy <plug>NERDCommenterYank[J

line 3:     endif[J

line 4: [J

line 5:     if !hasmapto(a:target, 'v')[J

line 6:         exec 'vmap ' . a:combo . ' ' . a:target[J

line 6: vmap <leader>cy <plug>NERDCommenterYank[J

line 7:     endif[J

function <SNR>17_CreateMaps returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2735:     call s:CreateMaps('<plug>NERDCommenterAlignLeft',  '<leader>cl')[J

calling function <SNR>17_CreateMaps[J('<plug>NERDCommenterAlignLeft', '<leader>cl')

line 1:     if !hasmapto(a:target, 'n')[J

line 2:         exec 'nmap ' . a:combo . ' ' . a:target[J

line 2: nmap <leader>cl <plug>NERDCommenterAlignLeft[J

line 3:     endif[J

line 4: [J

line 5:     if !hasmapto(a:target, 'v')[J

line 6:         exec 'vmap ' . a:combo . ' ' . a:target[J

line 6: vmap <leader>cl <plug>NERDCommenterAlignLeft[J

line 7:     endif[J

function <SNR>17_CreateMaps returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2736:     call s:CreateMaps('<plug>NERDCommenterAlignBoth',  '<leader>cb')[J

calling function <SNR>17_CreateMaps[J('<plug>NERDCommenterAlignBoth', '<leader>cb')

line 1:     if !hasmapto(a:target, 'n')[J

line 2:         exec 'nmap ' . a:combo . ' ' . a:target[J

line 2: nmap <leader>cb <plug>NERDCommenterAlignBoth[J

line 3:     endif[J

line 4: [J

line 5:     if !hasmapto(a:target, 'v')[J

line 6:         exec 'vmap ' . a:combo . ' ' . a:target[J

line 6: vmap <leader>cb <plug>NERDCommenterAlignBoth[J

line 7:     endif[J

function <SNR>17_CreateMaps returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2737:     call s:CreateMaps('<plug>NERDCommenterNest',       '<leader>cn')[J

calling function <SNR>17_CreateMaps[J('<plug>NERDCommenterNest', '<leader>cn')

line 1:     if !hasmapto(a:target, 'n')[J

line 2:         exec 'nmap ' . a:combo . ' ' . a:target[J

line 2: nmap <leader>cn <plug>NERDCommenterNest[J

line 3:     endif[J

line 4: [J

line 5:     if !hasmapto(a:target, 'v')[J

line 6:         exec 'vmap ' . a:combo . ' ' . a:target[J

line 6: vmap <leader>cn <plug>NERDCommenterNest[J

line 7:     endif[J

function <SNR>17_CreateMaps returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2738:     call s:CreateMaps('<plug>NERDCommenterUncomment',  '<leader>cu')[J

calling function <SNR>17_CreateMaps[J('<plug>NERDCommenterUncomment', '<leader>cu')

line 1:     if !hasmapto(a:target, 'n')[J

line 2:         exec 'nmap ' . a:combo . ' ' . a:target[J

line 2: nmap <leader>cu <plug>NERDCommenterUncomment[J

line 3:     endif[J

line 4: [J

line 5:     if !hasmapto(a:target, 'v')[J

line 6:         exec 'vmap ' . a:combo . ' ' . a:target[J

line 6: vmap <leader>cu <plug>NERDCommenterUncomment[J

line 7:     endif[J

function <SNR>17_CreateMaps returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2739:     call s:CreateMaps('<plug>NERDCommenterToEOL',      '<leader>c$')[J

calling function <SNR>17_CreateMaps[J('<plug>NERDCommenterToEOL', '<leader>c$')

line 1:     if !hasmapto(a:target, 'n')[J

line 2:         exec 'nmap ' . a:combo . ' ' . a:target[J

line 2: nmap <leader>c$ <plug>NERDCommenterToEOL[J

line 3:     endif[J

line 4: [J

line 5:     if !hasmapto(a:target, 'v')[J

line 6:         exec 'vmap ' . a:combo . ' ' . a:target[J

line 6: vmap <leader>c$ <plug>NERDCommenterToEOL[J

line 7:     endif[J

function <SNR>17_CreateMaps returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2740:     call s:CreateMaps('<plug>NERDCommenterAppend',     '<leader>cA')[J

calling function <SNR>17_CreateMaps[J('<plug>NERDCommenterAppend', '<leader>cA')

line 1:     if !hasmapto(a:target, 'n')[J

line 2:         exec 'nmap ' . a:combo . ' ' . a:target[J

line 2: nmap <leader>cA <plug>NERDCommenterAppend[J

line 3:     endif[J

line 4: [J

line 5:     if !hasmapto(a:target, 'v')[J

line 6:         exec 'vmap ' . a:combo . ' ' . a:target[J

line 6: vmap <leader>cA <plug>NERDCommenterAppend[J

line 7:     endif[J

function <SNR>17_CreateMaps returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2741: [J

line 2742:     if !hasmapto('<plug>NERDCommenterAltDelims', 'n')[J

line 2743:         nmap <leader>ca <plug>NERDCommenterAltDelims[J

line 2744:     endif[J

line 2745: endif[J

line 2746: [J

line 2747: [J

line 2748: [J

line 2749: " Section: Menu item setup {{{1[J

line 2750: " ===========================================================================[J

line 2751: "check if the user wants the menu to be displayed[J

line 2752: if g:NERDMenuMode != 0[J

line 2753: [J

line 2754:     let menuRoot = ""[J

line 2755:     if g:NERDMenuMode == 1[J

line 2756:         let menuRoot = 'comment'[J

line 2757:     elseif g:NERDMenuMode == 2[J

line 2758:         let menuRoot = '&comment'[J

line 2759:     elseif g:NERDMenuMode == 3[J

line 2760:         let menuRoot = '&Plugin.&comment'[J

line 2761:     endif[J

line 2762: [J

line 2763:     function! s:CreateMenuItems(target, desc, root)[J

line 2767:     call s:CreateMenuItems("<plug>NERDCommenterComment",    'Comment', menuRoot)[J

calling function <SNR>17_CreateMenuItems[J('<plug>NERDCommenterComment', 'Comment', '&Plugin.&comment')

line 1:         exec 'nmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 1: nmenu <silent> &Plugin.&comment.Comment <plug>NERDCommenterComment[J

line 2:         exec 'vmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 2: vmenu <silent> &Plugin.&comment.Comment <plug>NERDCommenterComment[J

function <SNR>17_CreateMenuItems returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2768:     call s:CreateMenuItems("<plug>NERDCommenterToggle",     'Toggle', menuRoot)[J

calling function <SNR>17_CreateMenuItems[J('<plug>NERDCommenterToggle', 'Toggle', '&Plugin.&comment')

line 1:         exec 'nmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 1: nmenu <silent> &Plugin.&comment.Toggle <plug>NERDCommenterToggle[J

line 2:         exec 'vmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 2: vmenu <silent> &Plugin.&comment.Toggle <plug>NERDCommenterToggle[J

function <SNR>17_CreateMenuItems returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2769:     call s:CreateMenuItems('<plug>NERDCommenterMinimal',    'Minimal', menuRoot)[J

calling function <SNR>17_CreateMenuItems[J('<plug>NERDCommenterMinimal', 'Minimal', '&Plugin.&comment')

line 1:         exec 'nmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 1: nmenu <silent> &Plugin.&comment.Minimal <plug>NERDCommenterMinimal[J

line 2:         exec 'vmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 2: vmenu <silent> &Plugin.&comment.Minimal <plug>NERDCommenterMinimal[J

function <SNR>17_CreateMenuItems returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2770:     call s:CreateMenuItems('<plug>NERDCommenterNest',       'Nested', menuRoot)[J

calling function <SNR>17_CreateMenuItems[J('<plug>NERDCommenterNest', 'Nested', '&Plugin.&comment')

line 1:         exec 'nmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 1: nmenu <silent> &Plugin.&comment.Nested <plug>NERDCommenterNest[J

line 2:         exec 'vmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 2: vmenu <silent> &Plugin.&comment.Nested <plug>NERDCommenterNest[J

function <SNR>17_CreateMenuItems returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2771:     exec 'nmenu <silent> '. menuRoot .'.To\ EOL <plug>NERDCommenterToEOL'[J

line 2771: nmenu <silent> &Plugin.&comment.To\ EOL <plug>NERDCommenterToEOL[J

line 2772:     call s:CreateMenuItems('<plug>NERDCommenterInvert',     'Invert', menuRoot)[J

calling function <SNR>17_CreateMenuItems[J('<plug>NERDCommenterInvert', 'Invert', '&Plugin.&comment')

line 1:         exec 'nmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 1: nmenu <silent> &Plugin.&comment.Invert <plug>NERDCommenterInvert[J

line 2:         exec 'vmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 2: vmenu <silent> &Plugin.&comment.Invert <plug>NERDCommenterInvert[J

function <SNR>17_CreateMenuItems returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2773:     call s:CreateMenuItems('<plug>NERDCommenterSexy',       'Sexy', menuRoot)[J

calling function <SNR>17_CreateMenuItems[J('<plug>NERDCommenterSexy', 'Sexy', '&Plugin.&comment')

line 1:         exec 'nmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 1: nmenu <silent> &Plugin.&comment.Sexy <plug>NERDCommenterSexy[J

line 2:         exec 'vmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 2: vmenu <silent> &Plugin.&comment.Sexy <plug>NERDCommenterSexy[J

function <SNR>17_CreateMenuItems returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2774:     call s:CreateMenuItems('<plug>NERDCommenterYank',       'Yank\ then\ comment', menuRoot)[J

calling function <SNR>17_CreateMenuItems[J('<plug>NERDCommenterYank', 'Yank\ then\ comment', '&Plugin.&comment')

line 1:         exec 'nmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 1: nmenu <silent> &Plugin.&comment.Yank\ then\ comment <plug>NERDCommenterYank[J

line 2:         exec 'vmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 2: vmenu <silent> &Plugin.&comment.Yank\ then\ comment <plug>NERDCommenterYank[J

function <SNR>17_CreateMenuItems returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2775:     exec 'nmenu <silent> '. menuRoot .'.Append <plug>NERDCommenterAppend'[J

line 2775: nmenu <silent> &Plugin.&comment.Append <plug>NERDCommenterAppend[J

line 2776:     exec 'menu <silent> '. menuRoot .'.-Sep-    :'[J

line 2776: menu <silent> &Plugin.&comment.-Sep-    :[J

line 2777:     call s:CreateMenuItems('<plug>NERDCommenterAlignLeft',  'Left\ aligned', menuRoot)[J

calling function <SNR>17_CreateMenuItems[J('<plug>NERDCommenterAlignLeft', 'Left\ aligned', '&Plugin.&comment')

line 1:         exec 'nmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 1: nmenu <silent> &Plugin.&comment.Left\ aligned <plug>NERDCommenterAlignLeft[J

line 2:         exec 'vmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 2: vmenu <silent> &Plugin.&comment.Left\ aligned <plug>NERDCommenterAlignLeft[J

function <SNR>17_CreateMenuItems returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2778:     call s:CreateMenuItems('<plug>NERDCommenterAlignBoth',  'Left\ and\ right\ aligned', menuRoot)[J

calling function <SNR>17_CreateMenuItems[J('<plug>NERDCommenterAlignBoth', 'Left\ and\ right\ aligned', '&Plugin.&comment')

line 1:         exec 'nmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 1: nmenu <silent> &Plugin.&comment.Left\ and\ right\ aligned <plug>NERDCommenterAlignBoth[J

line 2:         exec 'vmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 2: vmenu <silent> &Plugin.&comment.Left\ and\ right\ aligned <plug>NERDCommenterAlignBoth[J

function <SNR>17_CreateMenuItems returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2779:     exec 'menu <silent> '. menuRoot .'.-Sep2-    :'[J

line 2779: menu <silent> &Plugin.&comment.-Sep2-    :[J

line 2780:     call s:CreateMenuItems('<plug>NERDCommenterUncomment',  'Uncomment', menuRoot)[J

calling function <SNR>17_CreateMenuItems[J('<plug>NERDCommenterUncomment', 'Uncomment', '&Plugin.&comment')

line 1:         exec 'nmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 1: nmenu <silent> &Plugin.&comment.Uncomment <plug>NERDCommenterUncomment[J

line 2:         exec 'vmenu <silent> ' . a:root . '.' . a:desc . ' ' . a:target[J

line 2: vmenu <silent> &Plugin.&comment.Uncomment <plug>NERDCommenterUncomment[J

function <SNR>17_CreateMenuItems returning #0[J

continuing in /Users/Eric/.config/vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2781:     exec 'nmenu <silent> '. menuRoot .'.Switch\ Delimiters <plug>NERDCommenterAltDelims'[J

line 2781: nmenu <silent> &Plugin.&comment.Switch\ Delimiters <plug>NERDCommenterAltDelims[J

line 2782:     exec 'imenu <silent> '. menuRoot .'.Insert\ Comment\ Here <plug>NERDCommenterInInsert'[J

line 2782: imenu <silent> &Plugin.&comment.Insert\ Comment\ Here <plug>NERDCommenterInInsert[J

line 2783:     exec 'menu <silent> '. menuRoot .'.-Sep3-    :'[J

line 2783: menu <silent> &Plugin.&comment.-Sep3-    :[J

line 2784:     exec 'menu <silent>'. menuRoot .'.Help :help NERDCommenterContents<CR>'[J

line 2784: menu <silent>&Plugin.&comment.Help :help NERDCommenterContents<CR>[J

line 2785: endif[J

line 2786: " vim: set foldmethod=marker :[J

finished sourcing /Users/Eric/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J
Searching for "/Users/Eric/.vim/bundle/nerdtree/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/nerdtree/plugin/NERD_tree.vim"[J
line 1: " ============================================================================[J

line 2: " File:        NERD_tree.vim[J

line 3: " Description: vim global plugin that provides a nice tree explorer[J

line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>[J

line 5: " Last Change: 1 December, 2009[J

line 6: " License:     This program is free software. It comes without any warranty,[J

line 7: "              to the extent permitted by applicable law. You can redistribute[J

line 8: "              it and/or modify it under the terms of the Do What The Fuck You[J

line 9: "              Want To Public License, Version 2, as published by Sam Hocevar.[J

line 10: "              See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 11: "[J

line 12: " ============================================================================[J

line 13: let s:NERD_tree_version = '4.1.0'[J

line 14: [J

line 15: " SECTION: Script init stuff {{{1[J

line 16: "============================================================[J

line 17: if exists("loaded_nerd_tree")[J

line 18:     finish[J

line 19: endif[J

line 20: if v:version < 700[J

line 21:     echoerr "NERDTree: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"[J

line 22:     finish[J

line 23: endif[J

line 24: let loaded_nerd_tree = 1[J

line 25: [J

line 26: "for line continuation - i.e dont want C in &cpo[J

line 27: let s:old_cpo = &cpo[J

line 28: set cpo&vim[J

line 29: [J

line 30: "Function: s:initVariable() function {{{2[J

line 31: "This function is used to initialise a given variable to a given value. The[J

line 32: "variable is only initialised if it does not exist prior[J

line 33: "[J

line 34: "Args:[J

line 35: "var: the name of the var to be initialised[J

line 36: "value: the value to initialise var to[J

line 37: "[J

line 38: "Returns:[J

line 39: "1 if the var is set, 0 otherwise[J

line 40: function! s:initVariable(var, value)[J

line 47: [J

line 48: "SECTION: Init variable calls and other random constants {{{2[J

line 49: call s:initVariable("g:NERDChristmasTree", 1)[J

calling function <SNR>18_initVariable[J('g:NERDChristmasTree', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDChristmasTree = '1'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 50: call s:initVariable("g:NERDTreeAutoCenter", 1)[J

calling function <SNR>18_initVariable[J('g:NERDTreeAutoCenter', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeAutoCenter = '1'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 51: call s:initVariable("g:NERDTreeAutoCenterThreshold", 3)[J

calling function <SNR>18_initVariable[J('g:NERDTreeAutoCenterThreshold', 3)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeAutoCenterThreshold = '3'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 52: call s:initVariable("g:NERDTreeCaseSensitiveSort", 0)[J

calling function <SNR>18_initVariable[J('g:NERDTreeCaseSensitiveSort', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeCaseSensitiveSort = '0'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 53: call s:initVariable("g:NERDTreeChDirMode", 0)[J

calling function <SNR>18_initVariable[J('g:NERDTreeChDirMode', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeChDirMode = '0'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 54: if !exists("g:NERDTreeIgnore")[J

line 55:     let g:NERDTreeIgnore = ['\~$'][J

line 56: endif[J

line 57: call s:initVariable("g:NERDTreeBookmarksFile", expand('$HOME') . '/.NERDTreeBookmarks')[J

calling function <SNR>18_initVariable[J('g:NERDTreeBookmarksFile', '/Users/Eric/.NERDTreeBookmarks')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeBookmarksFile = '/Users/Eric/.NERDTreeBookmarks'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 58: call s:initVariable("g:NERDTreeHighlightCursorline", 1)[J

calling function <SNR>18_initVariable[J('g:NERDTreeHighlightCursorline', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeHighlightCursorline = '1'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 59: call s:initVariable("g:NERDTreeHijackNetrw", 1)[J

calling function <SNR>18_initVariable[J('g:NERDTreeHijackNetrw', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeHijackNetrw = '1'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 60: call s:initVariable("g:NERDTreeMouseMode", 1)[J

calling function <SNR>18_initVariable[J('g:NERDTreeMouseMode', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMouseMode = '1'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 61: call s:initVariable("g:NERDTreeNotificationThreshold", 100)[J

calling function <SNR>18_initVariable[J('g:NERDTreeNotificationThreshold', 100)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeNotificationThreshold = '100'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 62: call s:initVariable("g:NERDTreeQuitOnOpen", 0)[J

calling function <SNR>18_initVariable[J('g:NERDTreeQuitOnOpen', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeQuitOnOpen = '0'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 63: call s:initVariable("g:NERDTreeShowBookmarks", 0)[J

calling function <SNR>18_initVariable[J('g:NERDTreeShowBookmarks', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeShowBookmarks = '0'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 64: call s:initVariable("g:NERDTreeShowFiles", 1)[J

calling function <SNR>18_initVariable[J('g:NERDTreeShowFiles', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeShowFiles = '1'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 65: call s:initVariable("g:NERDTreeShowHidden", 0)[J

calling function <SNR>18_initVariable[J('g:NERDTreeShowHidden', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeShowHidden = '0'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 66: call s:initVariable("g:NERDTreeShowLineNumbers", 0)[J

calling function <SNR>18_initVariable[J('g:NERDTreeShowLineNumbers', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeShowLineNumbers = '0'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 67: call s:initVariable("g:NERDTreeSortDirs", 1)[J

calling function <SNR>18_initVariable[J('g:NERDTreeSortDirs', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeSortDirs = '1'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 68: [J

line 69: if !exists("g:NERDTreeSortOrder")[J

line 70:     let g:NERDTreeSortOrder = ['\/$', '*', '\.swp$',  '\.bak$', '\~$'][J

line 71: else[J

line 72:     "if there isnt a * in the sort sequence then add one[J

line 73:     if count(g:NERDTreeSortOrder, '*') < 1[J

line 74:         call add(g:NERDTreeSortOrder, '*')[J

line 75:     endif[J

line 76: endif[J

line 77: [J

line 78: "we need to use this number many times for sorting... so we calculate it only[J

line 79: "once here[J

line 80: let s:NERDTreeSortStarIndex = index(g:NERDTreeSortOrder, '*')[J

line 81: [J

line 82: if !exists('g:NERDTreeStatusline')[J

line 83: [J

line 84:     "the exists() crap here is a hack to stop vim spazzing out when[J

line 85:     "loading a session that was created with an open nerd tree. It spazzes[J

line 86:     "because it doesnt store b:NERDTreeRoot (its a b: var, and its a hash)[J

line 87:     let g:NERDTreeStatusline = "%{exists('b:NERDTreeRoot')?b:NERDTreeRoot.path.str():''}"[J

line 88: [J

line 89: endif[J

line 90: call s:initVariable("g:NERDTreeWinPos", "left")[J

calling function <SNR>18_initVariable[J('g:NERDTreeWinPos', 'left')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeWinPos = 'left'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 91: call s:initVariable("g:NERDTreeWinSize", 31)[J

calling function <SNR>18_initVariable[J('g:NERDTreeWinSize', 31)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeWinSize = '31'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 92: [J

line 93: let s:running_windows = has("win16") || has("win32") || has("win64")[J

line 94: [J

line 95: "init the shell commands that will be used to copy nodes, and remove dir trees[J

line 96: "[J

line 97: "Note: the space after the command is important[J

line 98: if s:running_windows[J

line 99:     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rmdir /s /q ')[J

line 100: else[J

line 101:     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rm -rf ')[J

calling function <SNR>18_initVariable[J('g:NERDTreeRemoveDirCmd', 'rm -rf ')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeRemoveDirCmd = 'rm -rf '[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 102:     call s:initVariable("g:NERDTreeCopyCmd", 'cp -r ')[J

calling function <SNR>18_initVariable[J('g:NERDTreeCopyCmd', 'cp -r ')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeCopyCmd = 'cp -r '[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 103: endif[J

line 104: [J

line 105: [J

line 106: "SECTION: Init variable calls for key mappings {{{2[J

line 107: call s:initVariable("g:NERDTreeMapActivateNode", "o")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapActivateNode', 'o')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapActivateNode = 'o'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 108: call s:initVariable("g:NERDTreeMapChangeRoot", "C")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapChangeRoot', 'C')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapChangeRoot = 'C'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 109: call s:initVariable("g:NERDTreeMapChdir", "cd")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapChdir', 'cd')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapChdir = 'cd'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 110: call s:initVariable("g:NERDTreeMapCloseChildren", "X")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapCloseChildren', 'X')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapCloseChildren = 'X'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 111: call s:initVariable("g:NERDTreeMapCloseDir", "x")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapCloseDir', 'x')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapCloseDir = 'x'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 112: call s:initVariable("g:NERDTreeMapDeleteBookmark", "D")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapDeleteBookmark', 'D')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapDeleteBookmark = 'D'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 113: call s:initVariable("g:NERDTreeMapMenu", "m")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapMenu', 'm')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapMenu = 'm'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 114: call s:initVariable("g:NERDTreeMapHelp", "?")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapHelp', '?')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapHelp = '?'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 115: call s:initVariable("g:NERDTreeMapJumpFirstChild", "K")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapJumpFirstChild', 'K')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapJumpFirstChild = 'K'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 116: call s:initVariable("g:NERDTreeMapJumpLastChild", "J")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapJumpLastChild', 'J')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapJumpLastChild = 'J'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 117: call s:initVariable("g:NERDTreeMapJumpNextSibling", "<C-j>")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapJumpNextSibling', '<C-j>')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapJumpNextSibling = '<C-j>'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 118: call s:initVariable("g:NERDTreeMapJumpParent", "p")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapJumpParent', 'p')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapJumpParent = 'p'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 119: call s:initVariable("g:NERDTreeMapJumpPrevSibling", "<C-k>")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapJumpPrevSibling', '<C-k>')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapJumpPrevSibling = '<C-k>'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 120: call s:initVariable("g:NERDTreeMapJumpRoot", "P")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapJumpRoot', 'P')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapJumpRoot = 'P'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 121: call s:initVariable("g:NERDTreeMapOpenExpl", "e")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapOpenExpl', 'e')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapOpenExpl = 'e'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 122: call s:initVariable("g:NERDTreeMapOpenInTab", "t")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapOpenInTab', 't')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapOpenInTab = 't'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 123: call s:initVariable("g:NERDTreeMapOpenInTabSilent", "T")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapOpenInTabSilent', 'T')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapOpenInTabSilent = 'T'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 124: call s:initVariable("g:NERDTreeMapOpenRecursively", "O")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapOpenRecursively', 'O')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapOpenRecursively = 'O'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 125: call s:initVariable("g:NERDTreeMapOpenSplit", "i")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapOpenSplit', 'i')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapOpenSplit = 'i'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 126: call s:initVariable("g:NERDTreeMapOpenVSplit", "s")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapOpenVSplit', 's')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapOpenVSplit = 's'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 127: call s:initVariable("g:NERDTreeMapPreview", "g" . NERDTreeMapActivateNode)[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapPreview', 'go')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapPreview = 'go'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 128: call s:initVariable("g:NERDTreeMapPreviewSplit", "g" . NERDTreeMapOpenSplit)[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapPreviewSplit', 'gi')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapPreviewSplit = 'gi'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 129: call s:initVariable("g:NERDTreeMapPreviewVSplit", "g" . NERDTreeMapOpenVSplit)[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapPreviewVSplit', 'gs')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapPreviewVSplit = 'gs'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 130: call s:initVariable("g:NERDTreeMapQuit", "q")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapQuit', 'q')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapQuit = 'q'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 131: call s:initVariable("g:NERDTreeMapRefresh", "r")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapRefresh', 'r')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapRefresh = 'r'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 132: call s:initVariable("g:NERDTreeMapRefreshRoot", "R")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapRefreshRoot', 'R')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapRefreshRoot = 'R'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 133: call s:initVariable("g:NERDTreeMapToggleBookmarks", "B")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapToggleBookmarks', 'B')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapToggleBookmarks = 'B'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 134: call s:initVariable("g:NERDTreeMapToggleFiles", "F")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapToggleFiles', 'F')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapToggleFiles = 'F'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 135: call s:initVariable("g:NERDTreeMapToggleFilters", "f")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapToggleFilters', 'f')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapToggleFilters = 'f'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 136: call s:initVariable("g:NERDTreeMapToggleHidden", "I")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapToggleHidden', 'I')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapToggleHidden = 'I'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 137: call s:initVariable("g:NERDTreeMapToggleZoom", "A")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapToggleZoom', 'A')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapToggleZoom = 'A'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 138: call s:initVariable("g:NERDTreeMapUpdir", "u")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapUpdir', 'u')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapUpdir = 'u'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 139: call s:initVariable("g:NERDTreeMapUpdirKeepOpen", "U")[J

calling function <SNR>18_initVariable[J('g:NERDTreeMapUpdirKeepOpen', 'U')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTreeMapUpdirKeepOpen = 'U'[J

line 3:         return 1[J

function <SNR>18_initVariable returning #1[J

continuing in /Users/Eric/.config/vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 140: [J

line 141: "SECTION: Script level variable declaration{{{2[J

line 142: if s:running_windows[J

line 143:     let s:escape_chars =  " `\|\"#%&,?()\*^<>"[J

line 144: else[J

line 145:     let s:escape_chars =  " \\`\|\"#%&,?()\*^<>"[J

line 146: endif[J

line 147: let s:NERDTreeBufName = 'NERD_tree_'[J

line 148: [J

line 149: let s:tree_wid = 2[J

line 150: let s:tree_markup_reg = '^[ `|]*[\-+~]'[J

line 151: let s:tree_up_dir_line = '.. (up a dir)'[J

line 152: [J

line 153: "the number to add to the nerd tree buffer name to make the buf name unique[J

line 154: let s:next_buffer_number = 1[J

line 155: [J

line 156: " SECTION: Commands {{{1[J

line 157: "============================================================[J

line 158: "init the command that users start the nerd tree with[J

line 159: command! -n=? -complete=dir -bar NERDTree :call s:initNerdTree('<args>')[J

line 160: command! -n=? -complete=dir -bar NERDTreeToggle :call s:toggle('<args>')[J

line 161: command! -n=0 -bar NERDTreeClose :call s:closeTreeIfOpen()[J

line 162: command! -n=1 -complete=customlist,s:completeBookmarks -bar NERDTreeFromBookmark call s:initNerdTree('<args>')[J

line 163: command! -n=0 -bar NERDTreeMirror call s:initNerdTreeMirror()[J

line 164: command! -n=0 -bar NERDTreeFind call s:findAndRevealPath()[J

line 165: " SECTION: Auto commands {{{1[J

line 166: "============================================================[J

line 167: augroup NERDTree[J

line 168:     "Save the cursor position whenever we close the nerd tree[J

line 169:     exec "autocmd BufWinLeave ". s:NERDTreeBufName ."* call <SID>saveScreenState()"[J

line 169: autocmd BufWinLeave NERD_tree_* call <SID>saveScreenState()[J

line 170:     "cache bookmarks when vim loads[J

line 171:     autocmd VimEnter * call s:Bookmark.CacheBookmarks(0)[J

line 172: [J

line 173:     "load all nerdtree plugins after vim starts[J

line 174:     autocmd VimEnter * runtime! nerdtree_plugin/**/*.vim[J

line 175: augroup END[J

line 176: [J

line 177: if g:NERDTreeHijackNetrw[J

line 178:     augroup NERDTreeHijackNetrw[J

line 179:         autocmd VimEnter * silent! autocmd! FileExplorer[J

line 180:         au BufEnter,VimEnter * call s:checkForBrowse(expand("<amatch>"))[J

line 181:     augroup END[J

line 182: endif[J

line 183: [J

line 184: "SECTION: Classes {{{1[J

line 185: "============================================================[J

line 186: "CLASS: Bookmark {{{2[J

line 187: "============================================================[J

line 188: let s:Bookmark = {}[J

line 189: " FUNCTION: Bookmark.activate() {{{3[J

line 190: function! s:Bookmark.activate()[J

line 200: " FUNCTION: Bookmark.AddBookmark(name, path) {{{3[J

line 201: " Class method to add a new bookmark to the list, if a previous bookmark exists[J

line 202: " with the same name, just update the path for that bookmark[J

line 203: function! s:Bookmark.AddBookmark(name, path)[J

line 213: " Function: Bookmark.Bookmarks()   {{{3[J

line 214: " Class method to get all bookmarks. Lazily initializes the bookmarks global[J

line 215: " variable[J

line 216: function! s:Bookmark.Bookmarks()[J

line 222: " Function: Bookmark.BookmarkExistsFor(name)   {{{3[J

line 223: " class method that returns 1 if a bookmark with the given name is found, 0[J

line 224: " otherwise[J

line 225: function! s:Bookmark.BookmarkExistsFor(name)[J

line 233: " Function: Bookmark.BookmarkFor(name)   {{{3[J

line 234: " Class method to get the bookmark that has the given name. {} is return if no[J

line 235: " bookmark is found[J

line 236: function! s:Bookmark.BookmarkFor(name)[J

line 244: " Function: Bookmark.BookmarkNames()   {{{3[J

line 245: " Class method to return an array of all bookmark names[J

line 246: function! s:Bookmark.BookmarkNames()[J

line 253: " FUNCTION: Bookmark.CacheBookmarks(silent) {{{3[J

line 254: " Class method to read all bookmarks from the bookmarks file intialize[J

line 255: " bookmark objects for each one.[J

line 256: "[J

line 257: " Args:[J

line 258: " silent - dont echo an error msg if invalid bookmarks are found[J

line 259: function! s:Bookmark.CacheBookmarks(silent)[J

line 291: " FUNCTION: Bookmark.compareTo(otherbookmark) {{{3[J

line 292: " Compare these two bookmarks for sorting purposes[J

line 293: function! s:Bookmark.compareTo(otherbookmark)[J

line 296: " FUNCTION: Bookmark.ClearAll() {{{3[J

line 297: " Class method to delete all bookmarks.[J

line 298: function! s:Bookmark.ClearAll()[J

line 304: " FUNCTION: Bookmark.delete() {{{3[J

line 305: " Delete this bookmark. If the node for this bookmark is under the current[J

line 306: " root, then recache bookmarks for its Path object[J

line 307: function! s:Bookmark.delete()[J

line 319: " FUNCTION: Bookmark.getNode(searchFromAbsoluteRoot) {{{3[J

line 320: " Gets the treenode for this bookmark[J

line 321: "[J

line 322: " Args:[J

line 323: " searchFromAbsoluteRoot: specifies whether we should search from the current[J

line 324: " tree root, or the highest cached node[J

line 325: function! s:Bookmark.getNode(searchFromAbsoluteRoot)[J

line 333: " FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot) {{{3[J

line 334: " Class method that finds the bookmark with the given name and returns the[J

line 335: " treenode for it.[J

line 336: function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot)[J

line 340: " FUNCTION: Bookmark.GetSelected() {{{3[J

line 341: " returns the Bookmark the cursor is over, or {}[J

line 342: function! s:Bookmark.GetSelected()[J

line 354: [J

line 355: " Function: Bookmark.InvalidBookmarks()   {{{3[J

line 356: " Class method to get all invalid bookmark strings read from the bookmarks[J

line 357: " file[J

line 358: function! s:Bookmark.InvalidBookmarks()[J

line 364: " FUNCTION: Bookmark.mustExist() {{{3[J

line 365: function! s:Bookmark.mustExist()[J

line 372: " FUNCTION: Bookmark.New(name, path) {{{3[J

line 373: " Create a new bookmark object with the given name and path object[J

line 374: function! s:Bookmark.New(name, path)[J

line 384: " FUNCTION: Bookmark.openInNewTab(options) {{{3[J

line 385: " Create a new bookmark object with the given name and path object[J

line 386: function! s:Bookmark.openInNewTab(options)[J

line 399: " Function: Bookmark.setPath(path)   {{{3[J

line 400: " makes this bookmark point to the given path[J

line 401: function! s:Bookmark.setPath(path)[J

line 404: " Function: Bookmark.Sort()   {{{3[J

line 405: " Class method that sorts all bookmarks[J

line 406: function! s:Bookmark.Sort()[J

line 410: " Function: Bookmark.str()   {{{3[J

line 411: " Get the string that should be rendered in the view for this bookmark[J

line 412: function! s:Bookmark.str()[J

line 424: " FUNCTION: Bookmark.toRoot() {{{3[J

line 425: " Make the node for this bookmark the new tree root[J

line 426: function! s:Bookmark.toRoot()[J

line 438: " FUNCTION: Bookmark.ToRoot(name) {{{3[J

line 439: " Make the node for this bookmark the new tree root[J

line 440: function! s:Bookmark.ToRoot(name)[J

line 444: [J

line 445: [J

line 446: "FUNCTION: Bookmark.validate() {{{3[J

line 447: function! s:Bookmark.validate()[J

line 457: [J

line 458: " Function: Bookmark.Write()   {{{3[J

line 459: " Class method to write all bookmarks to the bookmarks file[J

line 460: function! s:Bookmark.Write()[J

line 474: "CLASS: KeyMap {{{2[J

line 475: "============================================================[J

line 476: let s:KeyMap = {}[J

line 477: "FUNCTION: KeyMap.All() {{{3[J

line 478: function! s:KeyMap.All()[J

line 484: [J

line 485: "FUNCTION: KeyMap.BindAll() {{{3[J

line 486: function! s:KeyMap.BindAll()[J

line 491: [J

line 492: "FUNCTION: KeyMap.bind() {{{3[J

line 493: function! s:KeyMap.bind()[J

line 496: [J

line 497: "FUNCTION: KeyMap.Create(options) {{{3[J

line 498: function! s:KeyMap.Create(options)[J

line 505: "CLASS: MenuController {{{2[J

line 506: "============================================================[J

line 507: let s:MenuController = {}[J

line 508: "FUNCTION: MenuController.New(menuItems) {{{3[J

line 509: "create a new menu controller that operates on the given menu items[J

line 510: function! s:MenuController.New(menuItems)[J

line 519: [J

line 520: "FUNCTION: MenuController.showMenu() {{{3[J

line 521: "start the main loop of the menu and get the user to choose/execute a menu[J

line 522: "item[J

line 523: function! s:MenuController.showMenu()[J

line 545: [J

line 546: "FUNCTION: MenuController._echoPrompt() {{{3[J

line 547: function! s:MenuController._echoPrompt()[J

line 559: [J

line 560: "FUNCTION: MenuController._current(key) {{{3[J

line 561: "get the MenuItem that is curently selected[J

line 562: function! s:MenuController._current()[J

line 565: [J

line 566: "FUNCTION: MenuController._handleKeypress(key) {{{3[J

line 567: "change the selection (if appropriate) and return 1 if the user has made[J

line 568: "their choice, 0 otherwise[J

line 569: function! s:MenuController._handleKeypress(key)[J

line 591: [J

line 592: "FUNCTION: MenuController._allIndexesFor(shortcut) {{{3[J

line 593: "get indexes to all menu items with the given shortcut[J

line 594: function! s:MenuController._allIndexesFor(shortcut)[J

line 605: [J

line 606: "FUNCTION: MenuController._nextIndexFor(shortcut) {{{3[J

line 607: "get the index to the next menu item with the given shortcut, starts from the[J

line 608: "current cursor location and wraps around to the top again if need be[J

line 609: function! s:MenuController._nextIndexFor(shortcut)[J

line 624: [J

line 625: "FUNCTION: MenuController._setCmdheight() {{{3[J

line 626: "sets &cmdheight to whatever is needed to display the menu[J

line 627: function! s:MenuController._setCmdheight()[J

line 630: [J

line 631: "FUNCTION: MenuController._saveOptions() {{{3[J

line 632: "set any vim options that are required to make the menu work (saving their old[J

line 633: "values)[J

line 634: function! s:MenuController._saveOptions()[J

line 640: [J

line 641: "FUNCTION: MenuController._restoreOptions() {{{3[J

line 642: "restore the options we saved in _saveOptions()[J

line 643: function! s:MenuController._restoreOptions()[J

line 647: [J

line 648: "FUNCTION: MenuController._cursorDown() {{{3[J

line 649: "move the cursor to the next menu item, skipping separators[J

line 650: function! s:MenuController._cursorDown()[J

line 664: [J

line 665: "FUNCTION: MenuController._cursorUp() {{{3[J

line 666: "move the cursor to the previous menu item, skipping separators[J

line 667: function! s:MenuController._cursorUp()[J

line 681: [J

line 682: "CLASS: MenuItem {{{2[J

line 683: "============================================================[J

line 684: let s:MenuItem = {}[J

line 685: "FUNCTION: MenuItem.All() {{{3[J

line 686: "get all top level menu items[J

line 687: function! s:MenuItem.All()[J

line 693: [J

line 694: "FUNCTION: MenuItem.AllEnabled() {{{3[J

line 695: "get all top level menu items that are currently enabled[J

line 696: function! s:MenuItem.AllEnabled()[J

line 705: [J

line 706: "FUNCTION: MenuItem.Create(options) {{{3[J

line 707: "make a new menu item and add it to the global list[J

line 708: function! s:MenuItem.Create(options)[J

line 733: [J

line 734: "FUNCTION: MenuItem.CreateSeparator(options) {{{3[J

line 735: "make a new separator menu item and add it to the global list[J

line 736: function! s:MenuItem.CreateSeparator(options)[J

line 744: [J

line 745: "FUNCTION: MenuItem.CreateSubmenu(options) {{{3[J

line 746: "make a new submenu and add it to global list[J

line 747: function! s:MenuItem.CreateSubmenu(options)[J

line 753: [J

line 754: "FUNCTION: MenuItem.enabled() {{{3[J

line 755: "return 1 if this menu item should be displayed[J

line 756: "[J

line 757: "delegates off to the isActiveCallback, and defaults to 1 if no callback was[J

line 758: "specified[J

line 759: function! s:MenuItem.enabled()[J

line 765: [J

line 766: "FUNCTION: MenuItem.execute() {{{3[J

line 767: "perform the action behind this menu item, if this menuitem has children then[J

line 768: "display a new menu for them, otherwise deletegate off to the menuitem's[J

line 769: "callback[J

line 770: function! s:MenuItem.execute()[J

line 780: [J

line 781: "FUNCTION: MenuItem.isSeparator() {{{3[J

line 782: "return 1 if this menuitem is a separator[J

line 783: function! s:MenuItem.isSeparator()[J

line 786: [J

line 787: "FUNCTION: MenuItem.isSubmenu() {{{3[J

line 788: "return 1 if this menuitem is a submenu[J

line 789: function! s:MenuItem.isSubmenu()[J

line 792: [J

line 793: "CLASS: TreeFileNode {{{2[J

line 794: "This class is the parent of the TreeDirNode class and constitures the[J

line 795: "'Component' part of the composite design pattern between the treenode[J

line 796: "classes.[J

line 797: "============================================================[J

line 798: let s:TreeFileNode = {}[J

line 799: "FUNCTION: TreeFileNode.activate(forceKeepWinOpen) {{{3[J

line 800: function! s:TreeFileNode.activate(forceKeepWinOpen)[J

line 806: "FUNCTION: TreeFileNode.bookmark(name) {{{3[J

line 807: "bookmark this node with a:name[J

line 808: function! s:TreeFileNode.bookmark(name)[J

line 819: "FUNCTION: TreeFileNode.cacheParent() {{{3[J

line 820: "initializes self.parent if it isnt already[J

line 821: function! s:TreeFileNode.cacheParent()[J

line 830: "FUNCTION: TreeFileNode.compareNodes {{{3[J

line 831: "This is supposed to be a class level method but i cant figure out how to[J

line 832: "get func refs to work from a dict..[J

line 833: "[J

line 834: "A class level method that compares two nodes[J

line 835: "[J

line 836: "Args:[J

line 837: "n1, n2: the 2 nodes to compare[J

line 838: function! s:compareNodes(n1, n2)[J

line 841: [J

line 842: "FUNCTION: TreeFileNode.clearBoomarks() {{{3[J

line 843: function! s:TreeFileNode.clearBoomarks()[J

line 851: "FUNCTION: TreeFileNode.copy(dest) {{{3[J

line 852: function! s:TreeFileNode.copy(dest)[J

line 861: [J

line 862: "FUNCTION: TreeFileNode.delete {{{3[J

line 863: "Removes this node from the tree and calls the Delete method for its path obj[J

line 864: function! s:TreeFileNode.delete()[J

line 868: [J

line 869: "FUNCTION: TreeFileNode.displayString() {{{3[J

line 870: "[J

line 871: "Returns a string that specifies how the node should be represented as a[J

line 872: "string[J

line 873: "[J

line 874: "Return:[J

line 875: "a string that can be used in the view to represent this node[J

line 876: function! s:TreeFileNode.displayString()[J

line 879: [J

line 880: "FUNCTION: TreeFileNode.equals(treenode) {{{3[J

line 881: "[J

line 882: "Compares this treenode to the input treenode and returns 1 if they are the[J

line 883: "same node.[J

line 884: "[J

line 885: "Use this method instead of ==  because sometimes when the treenodes contain[J

line 886: "many children, vim seg faults when doing ==[J

line 887: "[J

line 888: "Args:[J

line 889: "treenode: the other treenode to compare to[J

line 890: function! s:TreeFileNode.equals(treenode)[J

line 893: [J

line 894: "FUNCTION: TreeFileNode.findNode(path) {{{3[J

line 895: "Returns self if this node.path.Equals the given path.[J

line 896: "Returns {} if not equal.[J

line 897: "[J

line 898: "Args:[J

line 899: "path: the path object to compare against[J

line 900: function! s:TreeFileNode.findNode(path)[J

line 906: "FUNCTION: TreeFileNode.findOpenDirSiblingWithVisibleChildren(direction) {{{3[J

line 907: "[J

line 908: "Finds the next sibling for this node in the indicated direction. This sibling[J

line 909: "must be a directory and may/may not have children as specified.[J

line 910: "[J

line 911: "Args:[J

line 912: "direction: 0 if you want to find the previous sibling, 1 for the next sibling[J

line 913: "[J

line 914: "Return:[J

line 915: "a treenode object or {} if no appropriate sibling could be found[J

line 916: function! s:TreeFileNode.findOpenDirSiblingWithVisibleChildren(direction)[J

line 931: "FUNCTION: TreeFileNode.findSibling(direction) {{{3[J

line 932: "[J

line 933: "Finds the next sibling for this node in the indicated direction[J

line 934: "[J

line 935: "Args:[J

line 936: "direction: 0 if you want to find the previous sibling, 1 for the next sibling[J

line 937: "[J

line 938: "Return:[J

line 939: "a treenode object or {} if no sibling could be found[J

line 940: function! s:TreeFileNode.findSibling(direction)[J

line 969: [J

line 970: "FUNCTION: TreeFileNode.getLineNum(){{{3[J

line 971: "returns the line number this node is rendered on, or -1 if it isnt rendered[J

line 972: function! s:TreeFileNode.getLineNum()[J

line 1018: [J

line 1019: "FUNCTION: TreeFileNode.GetRootForTab(){{{3[J

line 1020: "get the root node for this tab[J

line 1021: function! s:TreeFileNode.GetRootForTab()[J

line 1027: "FUNCTION: TreeFileNode.GetRootLineNum(){{{3[J

line 1028: "gets the line number of the root node[J

line 1029: function! s:TreeFileNode.GetRootLineNum()[J

line 1036: [J

line 1037: "FUNCTION: TreeFileNode.GetSelected() {{{3[J

line 1038: "gets the treenode that the cursor is currently over[J

line 1039: function! s:TreeFileNode.GetSelected()[J

line 1050: "FUNCTION: TreeFileNode.isVisible() {{{3[J

line 1051: "returns 1 if this node should be visible according to the tree filters and[J

line 1052: "hidden file filters (and their on/off status)[J

line 1053: function! s:TreeFileNode.isVisible()[J

line 1056: "FUNCTION: TreeFileNode.isRoot() {{{3[J

line 1057: "returns 1 if this node is b:NERDTreeRoot[J

line 1058: function! s:TreeFileNode.isRoot()[J

line 1065: [J

line 1066: "FUNCTION: TreeFileNode.makeRoot() {{{3[J

line 1067: "Make this node the root of the tree[J

line 1068: function! s:TreeFileNode.makeRoot()[J

line 1083: "FUNCTION: TreeFileNode.New(path) {{{3[J

line 1084: "Returns a new TreeNode object with the given path and parent[J

line 1085: "[J

line 1086: "Args:[J

line 1087: "path: a path object representing the full filesystem path to the file/dir that the node represents[J

line 1088: function! s:TreeFileNode.New(path)[J

line 1098: [J

line 1099: "FUNCTION: TreeFileNode.open() {{{3[J

line 1100: "Open the file represented by the given node in the current window, splitting[J

line 1101: "the window if needed[J

line 1102: "[J

line 1103: "ARGS:[J

line 1104: "treenode: file node to open[J

line 1105: function! s:TreeFileNode.open()[J

line 1136: "FUNCTION: TreeFileNode.openSplit() {{{3[J

line 1137: "Open this node in a new window[J

line 1138: function! s:TreeFileNode.openSplit()[J

line 1202: "FUNCTION: TreeFileNode.openVSplit() {{{3[J

line 1203: "Open this node in a new vertical window[J

line 1204: function! s:TreeFileNode.openVSplit()[J

line 1223: "FUNCTION: TreeFileNode.openInNewTab(options) {{{3[J

line 1224: function! s:TreeFileNode.openInNewTab(options)[J

line 1238: "FUNCTION: TreeFileNode.putCursorHere(isJump, recurseUpward){{{3[J

line 1239: "Places the cursor on the line number this node is rendered on[J

line 1240: "[J

line 1241: "Args:[J

line 1242: "isJump: 1 if this cursor movement should be counted as a jump by vim[J

line 1243: "recurseUpward: try to put the cursor on the parent if the this node isnt[J

line 1244: "visible[J

line 1245: function! s:TreeFileNode.putCursorHere(isJump, recurseUpward)[J

line 1264: [J

line 1265: "FUNCTION: TreeFileNode.refresh() {{{3[J

line 1266: function! s:TreeFileNode.refresh()[J

line 1269: "FUNCTION: TreeFileNode.rename() {{{3[J

line 1270: "Calls the rename method for this nodes path obj[J

line 1271: function! s:TreeFileNode.rename(newName)[J

line 1284: "FUNCTION: TreeFileNode.renderToString {{{3[J

line 1285: "returns a string representation for this tree to be rendered in the view[J

line 1286: function! s:TreeFileNode.renderToString()[J

line 1289: [J

line 1290: [J

line 1291: "Args:[J

line 1292: "depth: the current depth in the tree for this call[J

line 1293: "drawText: 1 if we should actually draw the line for this node (if 0 then the[J

line 1294: "child nodes are rendered only)[J

line 1295: "vertMap: a binary array that indicates whether a vertical bar should be draw[J

line 1296: "for each depth in the tree[J

line 1297: "isLastChild:true if this curNode is the last child of its parent[J

line 1298: function! s:TreeFileNode._renderToString(depth, drawText, vertMap, isLastChild)[J

line 1361: "CLASS: TreeDirNode {{{2[J

line 1362: "This class is a child of the TreeFileNode class and constitutes the[J

line 1363: "'Composite' part of the composite design pattern between the treenode[J

line 1364: "classes.[J

line 1365: "============================================================[J

line 1366: let s:TreeDirNode = copy(s:TreeFileNode)[J

line 1367: "FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{3[J

line 1368: "class method that returns the highest cached ancestor of the current root[J

line 1369: function! s:TreeDirNode.AbsoluteTreeRoot()[J

line 1376: "FUNCTION: TreeDirNode.activate(forceKeepWinOpen) {{{3[J

line 1377: unlet s:TreeDirNode.activate[J

line 1378: function! s:TreeDirNode.activate(forceKeepWinOpen)[J

line 1383: "FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{3[J

line 1384: "Adds the given treenode to the list of children for this node[J

line 1385: "[J

line 1386: "Args:[J

line 1387: "-treenode: the node to add[J

line 1388: "-inOrder: 1 if the new node should be inserted in sorted order[J

line 1389: function! s:TreeDirNode.addChild(treenode, inOrder)[J

line 1397: [J

line 1398: "FUNCTION: TreeDirNode.close() {{{3[J

line 1399: "Closes this directory[J

line 1400: function! s:TreeDirNode.close()[J

line 1403: [J

line 1404: "FUNCTION: TreeDirNode.closeChildren() {{{3[J

line 1405: "Closes all the child dir nodes of this node[J

line 1406: function! s:TreeDirNode.closeChildren()[J

line 1414: [J

line 1415: "FUNCTION: TreeDirNode.createChild(path, inOrder) {{{3[J

line 1416: "Instantiates a new child node for this node with the given path. The new[J

line 1417: "nodes parent is set to this node.[J

line 1418: "[J

line 1419: "Args:[J

line 1420: "path: a Path object that this node will represent/contain[J

line 1421: "inOrder: 1 if the new node should be inserted in sorted order[J

line 1422: "[J

line 1423: "Returns:[J

line 1424: "the newly created node[J

line 1425: function! s:TreeDirNode.createChild(path, inOrder)[J

line 1430: [J

line 1431: "FUNCTION: TreeDirNode.findNode(path) {{{3[J

line 1432: "Will find one of the children (recursively) that has the given path[J

line 1433: "[J

line 1434: "Args:[J

line 1435: "path: a path object[J

line 1436: unlet s:TreeDirNode.findNode[J

line 1437: function! s:TreeDirNode.findNode(path)[J

line 1455: "FUNCTION: TreeDirNode.getChildCount() {{{3[J

line 1456: "Returns the number of children this node has[J

line 1457: function! s:TreeDirNode.getChildCount()[J

line 1460: [J

line 1461: "FUNCTION: TreeDirNode.getChild(path) {{{3[J

line 1462: "Returns child node of this node that has the given path or {} if no such node[J

line 1463: "exists.[J

line 1464: "[J

line 1465: "This function doesnt not recurse into child dir nodes[J

line 1466: "[J

line 1467: "Args:[J

line 1468: "path: a path object[J

line 1469: function! s:TreeDirNode.getChild(path)[J

line 1482: [J

line 1483: "FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{3[J

line 1484: "returns the child at the given index[J

line 1485: "Args:[J

line 1486: "indx: the index to get the child from[J

line 1487: "visible: 1 if only the visible children array should be used, 0 if all the[J

line 1488: "children should be searched.[J

line 1489: function! s:TreeDirNode.getChildByIndex(indx, visible)[J

line 1496: [J

line 1497: "FUNCTION: TreeDirNode.getChildIndex(path) {{{3[J

line 1498: "Returns the index of the child node of this node that has the given path or[J

line 1499: "-1 if no such node exists.[J

line 1500: "[J

line 1501: "This function doesnt not recurse into child dir nodes[J

line 1502: "[J

line 1503: "Args:[J

line 1504: "path: a path object[J

line 1505: function! s:TreeDirNode.getChildIndex(path)[J

line 1527: [J

line 1528: "FUNCTION: TreeDirNode.GetSelected() {{{3[J

line 1529: "Returns the current node if it is a dir node, or else returns the current[J

line 1530: "nodes parent[J

line 1531: unlet s:TreeDirNode.GetSelected[J

line 1532: function! s:TreeDirNode.GetSelected()[J

line 1541: "FUNCTION: TreeDirNode.getVisibleChildCount() {{{3[J

line 1542: "Returns the number of visible children this node has[J

line 1543: function! s:TreeDirNode.getVisibleChildCount()[J

line 1546: [J

line 1547: "FUNCTION: TreeDirNode.getVisibleChildren() {{{3[J

line 1548: "Returns a list of children to display for this node, in the correct order[J

line 1549: "[J

line 1550: "Return:[J

line 1551: "an array of treenodes[J

line 1552: function! s:TreeDirNode.getVisibleChildren()[J

line 1561: [J

line 1562: "FUNCTION: TreeDirNode.hasVisibleChildren() {{{3[J

line 1563: "returns 1 if this node has any childre, 0 otherwise..[J

line 1564: function! s:TreeDirNode.hasVisibleChildren()[J

line 1567: [J

line 1568: "FUNCTION: TreeDirNode._initChildren() {{{3[J

line 1569: "Removes all childen from this node and re-reads them[J

line 1570: "[J

line 1571: "Args:[J

line 1572: "silent: 1 if the function should not echo any "please wait" messages for[J

line 1573: "large directories[J

line 1574: "[J

line 1575: "Return: the number of child nodes read[J

line 1576: function! s:TreeDirNode._initChildren(silent)[J

line 1619: "FUNCTION: TreeDirNode.New(path) {{{3[J

line 1620: "Returns a new TreeNode object with the given path and parent[J

line 1621: "[J

line 1622: "Args:[J

line 1623: "path: a path object representing the full filesystem path to the file/dir that the node represents[J

line 1624: unlet s:TreeDirNode.New[J

line 1625: function! s:TreeDirNode.New(path)[J

line 1640: "FUNCTION: TreeDirNode.open() {{{3[J

line 1641: "Reads in all this nodes children[J

line 1642: "[J

line 1643: "Return: the number of child nodes read[J

line 1644: unlet s:TreeDirNode.open[J

line 1645: function! s:TreeDirNode.open()[J

line 1653: [J

line 1654: " FUNCTION: TreeDirNode.openExplorer() {{{3[J

line 1655: " opens an explorer window for this node in the previous window (could be a[J

line 1656: " nerd tree or a netrw)[J

line 1657: function! s:TreeDirNode.openExplorer()[J

line 1667: "FUNCTION: TreeDirNode.openInNewTab(options) {{{3[J

line 1668: unlet s:TreeDirNode.openInNewTab[J

line 1669: function! s:TreeDirNode.openInNewTab(options)[J

line 1683: "FUNCTION: TreeDirNode.openRecursively() {{{3[J

line 1684: "Opens this treenode and all of its children whose paths arent 'ignored'[J

line 1685: "because of the file filters.[J

line 1686: "[J

line 1687: "This method is actually a wrapper for the OpenRecursively2 method which does[J

line 1688: "the work.[J

line 1689: function! s:TreeDirNode.openRecursively()[J

line 1692: [J

line 1693: "FUNCTION: TreeDirNode._openRecursively2() {{{3[J

line 1694: "Opens this all children of this treenode recursively if either:[J

line 1695: "   *they arent filtered by file filters[J

line 1696: "   *a:forceOpen is 1[J

line 1697: "[J

line 1698: "Args:[J

line 1699: "forceOpen: 1 if this node should be opened regardless of file filters[J

line 1700: function! s:TreeDirNode._openRecursively2(forceOpen)[J

line 1714: [J

line 1715: "FUNCTION: TreeDirNode.refresh() {{{3[J

line 1716: unlet s:TreeDirNode.refresh[J

line 1717: function! s:TreeDirNode.refresh()[J

line 1766: [J

line 1767: "FUNCTION: TreeDirNode.reveal(path) {{{3[J

line 1768: "reveal the given path, i.e. cache and open all treenodes needed to display it[J

line 1769: "in the UI[J

line 1770: function! s:TreeDirNode.reveal(path)[J

line 1792: "FUNCTION: TreeDirNode.removeChild(treenode) {{{3[J

line 1793: "[J

line 1794: "Removes the given treenode from this nodes set of children[J

line 1795: "[J

line 1796: "Args:[J

line 1797: "treenode: the node to remove[J

line 1798: "[J

line 1799: "Throws a NERDTree.ChildNotFoundError if the given treenode is not found[J

line 1800: function! s:TreeDirNode.removeChild(treenode)[J

line 1810: [J

line 1811: "FUNCTION: TreeDirNode.sortChildren() {{{3[J

line 1812: "[J

line 1813: "Sorts the children of this node according to alphabetical order and the[J

line 1814: "directory priority.[J

line 1815: "[J

line 1816: function! s:TreeDirNode.sortChildren()[J

line 1820: [J

line 1821: "FUNCTION: TreeDirNode.toggleOpen() {{{3[J

line 1822: "Opens this directory if it is closed and vice versa[J

line 1823: function! s:TreeDirNode.toggleOpen()[J

line 1830: [J

line 1831: "FUNCTION: TreeDirNode.transplantChild(newNode) {{{3[J

line 1832: "Replaces the child of this with the given node (where the child node's full[J

line 1833: "path matches a:newNode's fullpath). The search for the matching node is[J

line 1834: "non-recursive[J

line 1835: "[J

line 1836: "Arg:[J

line 1837: "newNode: the node to graft into the tree[J

line 1838: function! s:TreeDirNode.transplantChild(newNode)[J

line 1847: "============================================================[J

line 1848: "CLASS: Path {{{2[J

line 1849: "============================================================[J

line 1850: let s:Path = {}[J

line 1851: "FUNCTION: Path.AbsolutePathFor(str) {{{3[J

line 1852: function! s:Path.AbsolutePathFor(str)[J

line 1867: "FUNCTION: Path.bookmarkNames() {{{3[J

line 1868: function! s:Path.bookmarkNames()[J

line 1874: "FUNCTION: Path.cacheDisplayString() {{{3[J

line 1875: function! s:Path.cacheDisplayString()[J

line 1900: "FUNCTION: Path.changeToDir() {{{3[J

line 1901: function! s:Path.changeToDir()[J

line 1914: [J

line 1915: "FUNCTION: Path.compareTo() {{{3[J

line 1916: "[J

line 1917: "Compares this Path to the given path and returns 0 if they are equal, -1 if[J

line 1918: "this Path is "less than" the given path, or 1 if it is "greater".[J

line 1919: "[J

line 1920: "Args:[J

line 1921: "path: the path object to compare this to[J

line 1922: "[J

line 1923: "Return:[J

line 1924: "1, -1 or 0[J

line 1925: function! s:Path.compareTo(path)[J

line 1954: [J

line 1955: "FUNCTION: Path.Create(fullpath) {{{3[J

line 1956: "[J

line 1957: "Factory method.[J

line 1958: "[J

line 1959: "Creates a path object with the given path. The path is also created on the[J

line 1960: "filesystem. If the path already exists, a NERDTree.Path.Exists exception is[J

line 1961: "thrown. If any other errors occur, a NERDTree.Path exception is thrown.[J

line 1962: "[J

line 1963: "Args:[J

line 1964: "fullpath: the full filesystem path to the file/dir to create[J

line 1965: function! s:Path.Create(fullpath)[J

line 1990: [J

line 1991: "FUNCTION: Path.copy(dest) {{{3[J

line 1992: "[J

line 1993: "Copies the file/dir represented by this Path to the given location[J

line 1994: "[J

line 1995: "Args:[J

line 1996: "dest: the location to copy this dir/file to[J

line 1997: function! s:Path.copy(dest)[J

line 2010: [J

line 2011: "FUNCTION: Path.CopyingSupported() {{{3[J

line 2012: "[J

line 2013: "returns 1 if copying is supported for this OS[J

line 2014: function! s:Path.CopyingSupported()[J

line 2017: [J

line 2018: [J

line 2019: "FUNCTION: Path.copyingWillOverwrite(dest) {{{3[J

line 2020: "[J

line 2021: "returns 1 if copy this path to the given location will cause files to[J

line 2022: "overwritten[J

line 2023: "[J

line 2024: "Args:[J

line 2025: "dest: the location this path will be copied to[J

line 2026: function! s:Path.copyingWillOverwrite(dest)[J

line 2038: [J

line 2039: "FUNCTION: Path.delete() {{{3[J

line 2040: "[J

line 2041: "Deletes the file represented by this path.[J

line 2042: "Deletion of directories is not supported[J

line 2043: "[J

line 2044: "Throws NERDTree.Path.Deletion exceptions[J

line 2045: function! s:Path.delete()[J

line 2067: [J

line 2068: "FUNCTION: Path.displayString() {{{3[J

line 2069: "[J

line 2070: "Returns a string that specifies how the path should be represented as a[J

line 2071: "string[J

line 2072: function! s:Path.displayString()[J

line 2079: "FUNCTION: Path.extractDriveLetter(fullpath) {{{3[J

line 2080: "[J

line 2081: "If running windows, cache the drive letter for this path[J

line 2082: function! s:Path.extractDriveLetter(fullpath)[J

line 2090: "FUNCTION: Path.exists() {{{3[J

line 2091: "return 1 if this path points to a location that is readable or is a directory[J

line 2092: function! s:Path.exists()[J

line 2096: "FUNCTION: Path.getDir() {{{3[J

line 2097: "[J

line 2098: "Returns this path if it is a directory, else this paths parent.[J

line 2099: "[J

line 2100: "Return:[J

line 2101: "a Path object[J

line 2102: function! s:Path.getDir()[J

line 2109: "FUNCTION: Path.getParent() {{{3[J

line 2110: "[J

line 2111: "Returns a new path object for this paths parent[J

line 2112: "[J

line 2113: "Return:[J

line 2114: "a new Path object[J

line 2115: function! s:Path.getParent()[J

line 2124: "FUNCTION: Path.getLastPathComponent(dirSlash) {{{3[J

line 2125: "[J

line 2126: "Gets the last part of this path.[J

line 2127: "[J

line 2128: "Args:[J

line 2129: "dirSlash: if 1 then a trailing slash will be added to the returned value for[J

line 2130: "directory nodes.[J

line 2131: function! s:Path.getLastPathComponent(dirSlash)[J

line 2141: [J

line 2142: "FUNCTION: Path.getSortOrderIndex() {{{3[J

line 2143: "returns the index of the pattern in g:NERDTreeSortOrder that this path matches[J

line 2144: function! s:Path.getSortOrderIndex()[J

line 2154: [J

line 2155: "FUNCTION: Path.ignore() {{{3[J

line 2156: "returns true if this path should be ignored[J

line 2157: function! s:Path.ignore()[J

line 2180: [J

line 2181: "FUNCTION: Path.isUnder(path) {{{3[J

line 2182: "return 1 if this path is somewhere under the given path in the filesystem.[J

line 2183: "[J

line 2184: "a:path should be a dir[J

line 2185: function! s:Path.isUnder(path)[J

line 2194: [J

line 2195: "FUNCTION: Path.JoinPathStrings(...) {{{3[J

line 2196: function! s:Path.JoinPathStrings(...)[J

line 2203: [J

line 2204: "FUNCTION: Path.equals() {{{3[J

line 2205: "[J

line 2206: "Determines whether 2 path objects are "equal".[J

line 2207: "They are equal if the paths they represent are the same[J

line 2208: "[J

line 2209: "Args:[J

line 2210: "path: the other path obj to compare this with[J

line 2211: function! s:Path.equals(path)[J

line 2214: [J

line 2215: "FUNCTION: Path.New() {{{3[J

line 2216: "The Constructor for the Path object[J

line 2217: function! s:Path.New(path)[J

line 2226: [J

line 2227: "FUNCTION: Path.Slash() {{{3[J

line 2228: "return the slash to use for the current OS[J

line 2229: function! s:Path.Slash()[J

line 2232: [J

line 2233: "FUNCTION: Path.readInfoFromDisk(fullpath) {{{3[J

line 2234: "[J

line 2235: "[J

line 2236: "Throws NERDTree.Path.InvalidArguments exception.[J

line 2237: function! s:Path.readInfoFromDisk(fullpath)[J

line 2286: [J

line 2287: "FUNCTION: Path.refresh() {{{3[J

line 2288: function! s:Path.refresh()[J

line 2292: [J

line 2293: "FUNCTION: Path.rename() {{{3[J

line 2294: "[J

line 2295: "Renames this node on the filesystem[J

line 2296: function! s:Path.rename(newPath)[J

line 2313: [J

line 2314: "FUNCTION: Path.str() {{{3[J

line 2315: "[J

line 2316: "Returns a string representation of this Path[J

line 2317: "[J

line 2318: "Takes an optional dictionary param to specify how the output should be[J

line 2319: "formatted.[J

line 2320: "[J

line 2321: "The dict may have the following keys:[J

line 2322: "  'format'[J

line 2323: "  'escape'[J

line 2324: "  'truncateTo'[J

line 2325: "[J

line 2326: "The 'format' key may have a value of:[J

line 2327: "  'Cd' - a string to be used with the :cd command[J

line 2328: "  'Edit' - a string to be used with :e :sp :new :tabedit etc[J

line 2329: "  'UI' - a string used in the NERD tree UI[J

line 2330: "[J

line 2331: "The 'escape' key, if specified will cause the output to be escaped with[J

line 2332: "shellescape()[J

line 2333: "[J

line 2334: "The 'truncateTo' key causes the resulting string to be truncated to the value[J

line 2335: "'truncateTo' maps to. A '<' char will be prepended.[J

line 2336: function! s:Path.str(...)[J

line 2364: [J

line 2365: "FUNCTION: Path._strForUI() {{{3[J

line 2366: function! s:Path._strForUI()[J

line 2373: [J

line 2374: "FUNCTION: Path._strForCd() {{{3[J

line 2375: "[J

line 2376: " returns a string that can be used with :cd[J

line 2377: function! s:Path._strForCd()[J

line 2380: "FUNCTION: Path._strForEdit() {{{3[J

line 2381: "[J

line 2382: "Return: the string for this path that is suitable to be used with the :edit[J

line 2383: "command[J

line 2384: function! s:Path._strForEdit()[J

line 2409: "FUNCTION: Path._strForGlob() {{{3[J

line 2410: function! s:Path._strForGlob()[J

line 2425: "FUNCTION: Path._str() {{{3[J

line 2426: "[J

line 2427: "Gets the string path for this path object that is appropriate for the OS.[J

line 2428: "EG, in windows c:\foo\bar[J

line 2429: "    in *nix  /foo/bar[J

line 2430: function! s:Path._str()[J

line 2440: [J

line 2441: "FUNCTION: Path.strTrunk() {{{3[J

line 2442: "Gets the path without the last segment on the end.[J

line 2443: function! s:Path.strTrunk()[J

line 2446: [J

line 2447: "FUNCTION: Path.WinToUnixPath(pathstr){{{3[J

line 2448: "Takes in a windows path and returns the unix equiv[J

line 2449: "[J

line 2450: "A class level method[J

line 2451: "[J

line 2452: "Args:[J

line 2453: "pathstr: the windows path to convert[J

line 2454: function! s:Path.WinToUnixPath(pathstr)[J

line 2469: [J

line 2470: " SECTION: General Functions {{{1[J

line 2471: "============================================================[J

line 2472: "FUNCTION: s:bufInWindows(bnum){{{2[J

line 2473: "[[STOLEN FROM VTREEEXPLORER.VIM]][J

line 2474: "Determine the number of windows open to this buffer number.[J

line 2475: "Care of Yegappan Lakshman.  Thanks![J

line 2476: "[J

line 2477: "Args:[J

line 2478: "bnum: the subject buffers buffer number[J

line 2479: function! s:bufInWindows(bnum)[J

line 2495: "FUNCTION: s:checkForBrowse(dir) {{{2[J

line 2496: "inits a secondary nerd tree in the current buffer if appropriate[J

line 2497: function! s:checkForBrowse(dir)[J

line 2502: "FUNCTION: s:compareBookmarks(first, second) {{{2[J

line 2503: "Compares two bookmarks[J

line 2504: function! s:compareBookmarks(first, second)[J

line 2507: [J

line 2508: " FUNCTION: s:completeBookmarks(A,L,P) {{{2[J

line 2509: " completion function for the bookmark commands[J

line 2510: function! s:completeBookmarks(A,L,P)[J

line 2513: " FUNCTION: s:exec(cmd) {{{2[J

line 2514: " same as :exec cmd  but eventignore=all is set for the duration[J

line 2515: function! s:exec(cmd)[J

line 2521: " FUNCTION: s:findAndRevealPath() {{{2[J

line 2522: function! s:findAndRevealPath()[J

line 2544: "FUNCTION: s:initNerdTree(name) {{{2[J

line 2545: "Initialise the nerd tree for this tab. The tree will start in either the[J

line 2546: "given directory, or the directory associated with the given bookmark[J

line 2547: "[J

line 2548: "Args:[J

line 2549: "name: the name of a bookmark or a directory[J

line 2550: function! s:initNerdTree(name)[J

line 2603: [J

line 2604: "FUNCTION: s:initNerdTreeInPlace(dir) {{{2[J

line 2605: function! s:initNerdTreeInPlace(dir)[J

line 2666: " FUNCTION: s:initNerdTreeMirror() {{{2[J

line 2667: function! s:initNerdTreeMirror()[J

line 2719: " FUNCTION: s:nextBufferName() {{{2[J

line 2720: " returns the buffer name for the next nerd tree[J

line 2721: function! s:nextBufferName()[J

line 2726: " FUNCTION: s:tabpagevar(tabnr, var) {{{2[J

line 2727: function! s:tabpagevar(tabnr, var)[J

line 2743: " Function: s:treeExistsForBuffer()   {{{2[J

line 2744: " Returns 1 if a nerd tree root exists in the current buffer[J

line 2745: function! s:treeExistsForBuf()[J

line 2748: " Function: s:treeExistsForTab()   {{{2[J

line 2749: " Returns 1 if a nerd tree root exists in the current tab[J

line 2750: function! s:treeExistsForTab()[J

line 2753: " Function: s:unique(list)   {{{2[J

line 2754: " returns a:list without duplicates[J

line 2755: function! s:unique(list)[J

line 2764: " SECTION: Public API {{{1[J

line 2765: "============================================================[J

line 2766: let g:NERDTreePath = s:Path[J

line 2767: let g:NERDTreeDirNode = s:TreeDirNode[J

line 2768: let g:NERDTreeFileNode = s:TreeFileNode[J

line 2769: let g:NERDTreeBookmark = s:Bookmark[J

line 2770: [J

line 2771: function! NERDTreeAddMenuItem(options)[J

line 2774: [J

line 2775: function! NERDTreeAddMenuSeparator(...)[J

line 2779: [J

line 2780: function! NERDTreeAddSubmenu(options)[J

line 2783: [J

line 2784: function! NERDTreeAddKeyMap(options)[J

line 2787: [J

line 2788: function! NERDTreeRender()[J

line 2791: [J

line 2792: " SECTION: View Functions {{{1[J

line 2793: "============================================================[J

line 2794: "FUNCTION: s:centerView() {{{2[J

line 2795: "centers the nerd tree window around the cursor (provided the nerd tree[J

line 2796: "options permit)[J

line 2797: function! s:centerView()[J

line 2807: "FUNCTION: s:closeTree() {{{2[J

line 2808: "Closes the primary NERD tree window for this tab[J

line 2809: function! s:closeTree()[J

line 2822: [J

line 2823: "FUNCTION: s:closeTreeIfOpen() {{{2[J

line 2824: "Closes the NERD tree window if it is open[J

line 2825: function! s:closeTreeIfOpen()[J

line 2830: "FUNCTION: s:closeTreeIfQuitOnOpen() {{{2[J

line 2831: "Closes the NERD tree window if the close on open option is set[J

line 2832: function! s:closeTreeIfQuitOnOpen()[J

line 2837: "FUNCTION: s:createTreeWin() {{{2[J

line 2838: "Inits the NERD tree window. ie. opens it, sizes it, sets all the local[J

line 2839: "options etc[J

line 2840: function! s:createTreeWin()[J

line 2884: [J

line 2885: "FUNCTION: s:dumpHelp  {{{2[J

line 2886: "prints out the quick help[J

line 2887: function! s:dumpHelp()[J

line 2990: "FUNCTION: s:echo  {{{2[J

line 2991: "A wrapper for :echo. Appends 'NERDTree:' on the front of all messages[J

line 2992: "[J

line 2993: "Args:[J

line 2994: "msg: the message to echo[J

line 2995: function! s:echo(msg)[J

line 2999: "FUNCTION: s:echoWarning {{{2[J

line 3000: "Wrapper for s:echo, sets the message type to warningmsg for this message[J

line 3001: "Args:[J

line 3002: "msg: the message to echo[J

line 3003: function! s:echoWarning(msg)[J

line 3008: "FUNCTION: s:echoError {{{2[J

line 3009: "Wrapper for s:echo, sets the message type to errormsg for this message[J

line 3010: "Args:[J

line 3011: "msg: the message to echo[J

line 3012: function! s:echoError(msg)[J

line 3017: "FUNCTION: s:firstUsableWindow(){{{2[J

line 3018: "find the window number of the first normal window[J

line 3019: function! s:firstUsableWindow()[J

line 3033: "FUNCTION: s:getPath(ln) {{{2[J

line 3034: "Gets the full path to the node that is rendered on the given line number[J

line 3035: "[J

line 3036: "Args:[J

line 3037: "ln: the line number to get the path for[J

line 3038: "[J

line 3039: "Return:[J

line 3040: "A path if a node was selected, {} if nothing is selected.[J

line 3041: "If the 'up a dir' line was selected then the path to the parent of the[J

line 3042: "current root is returned[J

line 3043: function! s:getPath(ln)[J

line 3099: [J

line 3100: "FUNCTION: s:getTreeWinNum() {{{2[J

line 3101: "gets the nerd tree window number for this tab[J

line 3102: function! s:getTreeWinNum()[J

line 3109: "FUNCTION: s:indentLevelFor(line) {{{2[J

line 3110: function! s:indentLevelFor(line)[J

line 3113: "FUNCTION: s:isTreeOpen() {{{2[J

line 3114: function! s:isTreeOpen()[J

line 3117: "FUNCTION: s:isWindowUsable(winnumber) {{{2[J

line 3118: "Returns 0 if opening a file from the tree in the given window requires it to[J

line 3119: "be split, 1 otherwise[J

line 3120: "[J

line 3121: "Args:[J

line 3122: "winnumber: the number of the window in question[J

line 3123: function! s:isWindowUsable(winnumber)[J

line 3147: [J

line 3148: " FUNCTION: s:jumpToChild(direction) {{{2[J

line 3149: " Args:[J

line 3150: " direction: 0 if going to first child, 1 if going to last[J

line 3151: function! s:jumpToChild(direction)[J

line 3177: [J

line 3178: [J

line 3179: "FUNCTION: s:promptToDelBuffer(bufnum, msg){{{2[J

line 3180: "prints out the given msg and, if the user responds by pushing 'y' then the[J

line 3181: "buffer with the given bufnum is deleted[J

line 3182: "[J

line 3183: "Args:[J

line 3184: "bufnum: the buffer that may be deleted[J

line 3185: "msg: a message that will be echoed to the user asking them if they wish to[J

line 3186: "     del the buffer[J

line 3187: function! s:promptToDelBuffer(bufnum, msg)[J

line 3193: [J

line 3194: "FUNCTION: s:putCursorOnBookmarkTable(){{{2[J

line 3195: "Places the cursor at the top of the bookmarks table[J

line 3196: function! s:putCursorOnBookmarkTable()[J

line 3212: [J

line 3213: "FUNCTION: s:putCursorInTreeWin(){{{2[J

line 3214: "Places the cursor in the nerd tree window[J

line 3215: function! s:putCursorInTreeWin()[J

line 3222: [J

line 3223: "FUNCTION: s:renderBookmarks {{{2[J

line 3224: function! s:renderBookmarks()[J

line 3237: "FUNCTION: s:renderView {{{2[J

line 3238: "The entry function for rendering the tree[J

line 3239: function! s:renderView()[J

line 3289: [J

line 3290: "FUNCTION: s:renderViewSavingPosition {{{2[J

line 3291: "Renders the tree and ensures the cursor stays on the current node or the[J

line 3292: "current nodes parent if it is no longer available upon re-rendering[J

line 3293: function! s:renderViewSavingPosition()[J

line 3308: "FUNCTION: s:restoreScreenState() {{{2[J

line 3309: "[J

line 3310: "Sets the screen state back to what it was when s:saveScreenState was last[J

line 3311: "called.[J

line 3312: "[J

line 3313: "Assumes the cursor is in the NERDTree window[J

line 3314: function! s:restoreScreenState()[J

line 3327: [J

line 3328: "FUNCTION: s:saveScreenState() {{{2[J

line 3329: "Saves the current cursor position in the current buffer and the window[J

line 3330: "scroll position[J

line 3331: function! s:saveScreenState()[J

line 3342: [J

line 3343: "FUNCTION: s:setupStatusline() {{{2[J

line 3344: function! s:setupStatusline()[J

line 3349: "FUNCTION: s:setupSyntaxHighlighting() {{{2[J

line 3350: function! s:setupSyntaxHighlighting()[J

line 3439: [J

line 3440: "FUNCTION: s:stripMarkupFromLine(line, removeLeadingSpaces){{{2[J

line 3441: "returns the given line with all the tree parts stripped off[J

line 3442: "[J

line 3443: "Args:[J

line 3444: "line: the subject line[J

line 3445: "removeLeadingSpaces: 1 if leading spaces are to be removed (leading spaces =[J

line 3446: "any spaces before the actual text of the node)[J

line 3447: function! s:stripMarkupFromLine(line, removeLeadingSpaces)[J

line 3476: [J

line 3477: "FUNCTION: s:toggle(dir) {{{2[J

line 3478: "Toggles the NERD tree. I.e the NERD tree is open, it is closed, if it is[J

line 3479: "closed it is restored or initialized (if it doesnt exist)[J

line 3480: "[J

line 3481: "Args:[J

line 3482: "dir: the full path for the root node (is only used if the NERD tree is being[J

line 3483: "initialized.[J

line 3484: function! s:toggle(dir)[J

line 3499: "SECTION: Interface bindings {{{1[J

line 3500: "============================================================[J

line 3501: "FUNCTION: s:activateNode(forceKeepWindowOpen) {{{2[J

line 3502: "If the current node is a file, open it in the previous window (or a new one[J

line 3503: "if the previous is modified). If it is a directory then it is opened.[J

line 3504: "[J

line 3505: "args:[J

line 3506: "forceKeepWindowOpen - dont close the window even if NERDTreeQuitOnOpen is set[J

line 3507: function! s:activateNode(forceKeepWindowOpen)[J

line 3522: [J

line 3523: "FUNCTION: s:bindMappings() {{{2[J

line 3524: function! s:bindMappings()[J

line 3591: [J

line 3592: " FUNCTION: s:bookmarkNode(name) {{{2[J

line 3593: " Associate the current node with the given name[J

line 3594: function! s:bookmarkNode(name)[J

line 3607: "FUNCTION: s:checkForActivate() {{{2[J

line 3608: "Checks if the click should open the current node, if so then activate() is[J

line 3609: "called (directories are automatically opened if the symbol beside them is[J

line 3610: "clicked)[J

line 3611: function! s:checkForActivate()[J

line 3634: [J

line 3635: " FUNCTION: s:chCwd() {{{2[J

line 3636: function! s:chCwd()[J

line 3649: [J

line 3650: " FUNCTION: s:chRoot() {{{2[J

line 3651: " changes the current root to the selected one[J

line 3652: function! s:chRoot()[J

line 3663: [J

line 3664: " FUNCTION: s:clearBookmarks(bookmarks) {{{2[J

line 3665: function! s:clearBookmarks(bookmarks)[J

line 3679: " FUNCTION: s:closeChildren() {{{2[J

line 3680: " closes all childnodes of the current node[J

line 3681: function! s:closeChildren()[J

line 3692: " FUNCTION: s:closeCurrentDir() {{{2[J

line 3693: " closes the parent dir of the current node[J

line 3694: function! s:closeCurrentDir()[J

line 3710: " FUNCTION: s:closeTreeWindow() {{{2[J

line 3711: " close the tree window[J

line 3712: function! s:closeTreeWindow()[J

line 3723: " FUNCTION: s:deleteBookmark() {{{2[J

line 3724: " if the cursor is on a bookmark, prompt to delete[J

line 3725: function! s:deleteBookmark()[J

line 3747: [J

line 3748: " FUNCTION: s:displayHelp() {{{2[J

line 3749: " toggles the help display[J

line 3750: function! s:displayHelp()[J

line 3755: [J

line 3756: " FUNCTION: s:handleMiddleMouse() {{{2[J

line 3757: function! s:handleMiddleMouse()[J

line 3770: [J

line 3771: [J

line 3772: " FUNCTION: s:jumpToFirstChild() {{{2[J

line 3773: " wrapper for the jump to child method[J

line 3774: function! s:jumpToFirstChild()[J

line 3777: [J

line 3778: " FUNCTION: s:jumpToLastChild() {{{2[J

line 3779: " wrapper for the jump to child method[J

line 3780: function! s:jumpToLastChild()[J

line 3783: [J

line 3784: " FUNCTION: s:jumpToParent() {{{2[J

line 3785: " moves the cursor to the parent of the current node[J

line 3786: function! s:jumpToParent()[J

line 3799: [J

line 3800: " FUNCTION: s:jumpToRoot() {{{2[J

line 3801: " moves the cursor to the root node[J

line 3802: function! s:jumpToRoot()[J

line 3806: [J

line 3807: " FUNCTION: s:jumpToSibling() {{{2[J

line 3808: " moves the cursor to the sibling of the current node in the given direction[J

line 3809: "[J

line 3810: " Args:[J

line 3811: " forward: 1 if the cursor should move to the next sibling, 0 if it should[J

line 3812: " move back to the previous sibling[J

line 3813: function! s:jumpToSibling(forward)[J

line 3826: [J

line 3827: " FUNCTION: s:openBookmark(name) {{{2[J

line 3828: " put the cursor on the given bookmark and, if its a file, open it[J

line 3829: function! s:openBookmark(name)[J

line 3845: " FUNCTION: s:openEntrySplit(vertical, forceKeepWindowOpen) {{{2[J

line 3846: "Opens the currently selected file from the explorer in a[J

line 3847: "new window[J

line 3848: "[J

line 3849: "args:[J

line 3850: "forceKeepWindowOpen - dont close the window even if NERDTreeQuitOnOpen is set[J

line 3851: function! s:openEntrySplit(vertical, forceKeepWindowOpen)[J

line 3866: [J

line 3867: " FUNCTION: s:openExplorer() {{{2[J

line 3868: function! s:openExplorer()[J

line 3876: [J

line 3877: " FUNCTION: s:openInNewTab(stayCurrentTab) {{{2[J

line 3878: " Opens the selected node or bookmark in a new tab[J

line 3879: " Args:[J

line 3880: " stayCurrentTab: if 1 then vim will stay in the current tab, if 0 then vim[J

line 3881: " will go to the tab where the new file is opened[J

line 3882: function! s:openInNewTab(stayCurrentTab)[J

line 3892: [J

line 3893: " FUNCTION: s:openNodeRecursively() {{{2[J

line 3894: function! s:openNodeRecursively()[J

line 3907: [J

line 3908: "FUNCTION: s:previewNode() {{{2[J

line 3909: "Args:[J

line 3910: "   openNewWin: if 0, use the previous window, if 1 open in new split, if 2[J

line 3911: "               open in a vsplit[J

line 3912: function! s:previewNode(openNewWin)[J

line 3921: [J

line 3922: " FUNCTION: s:revealBookmark(name) {{{2[J

line 3923: " put the cursor on the node associate with the given name[J

line 3924: function! s:revealBookmark(name)[J

line 3932: " FUNCTION: s:refreshRoot() {{{2[J

line 3933: " Reloads the current root. All nodes below this will be lost and the root dir[J

line 3934: " will be reloaded.[J

line 3935: function! s:refreshRoot()[J

line 3942: [J

line 3943: " FUNCTION: s:refreshCurrent() {{{2[J

line 3944: " refreshes the root for the current node[J

line 3945: function! s:refreshCurrent()[J

line 3958: " FUNCTION: s:showMenu() {{{2[J

line 3959: function! s:showMenu()[J

line 3969: [J

line 3970: " FUNCTION: s:toggleIgnoreFilter() {{{2[J

line 3971: " toggles the use of the NERDTreeIgnore option[J

line 3972: function! s:toggleIgnoreFilter()[J

line 3977: [J

line 3978: " FUNCTION: s:toggleShowBookmarks() {{{2[J

line 3979: " toggles the display of bookmarks[J

line 3980: function! s:toggleShowBookmarks()[J

line 3990: " FUNCTION: s:toggleShowFiles() {{{2[J

line 3991: " toggles the display of hidden files[J

line 3992: function! s:toggleShowFiles()[J

line 3997: [J

line 3998: " FUNCTION: s:toggleShowHidden() {{{2[J

line 3999: " toggles the display of hidden files[J

line 4000: function! s:toggleShowHidden()[J

line 4005: [J

line 4006: " FUNCTION: s:toggleZoom() {{2[J

line 4007: " zoom (maximize/minimize) the NERDTree window[J

line 4008: function! s:toggleZoom()[J

line 4018: [J

line 4019: "FUNCTION: s:upDir(keepState) {{{2[J

line 4020: "moves the tree up a level[J

line 4021: "[J

line 4022: "Args:[J

line 4023: "keepState: 1 if the current root should be left open when the tree is[J

line 4024: "re-rendered[J

line 4025: function! s:upDir(keepState)[J

line 4054: [J

line 4055: [J

line 4056: "reset &cpo back to users setting[J

line 4057: let &cpo = s:old_cpo[J

line 4058: [J

line 4059: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/Eric/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J
Searching for "/Users/Eric/.vim/bundle/snipmate/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/snipmate/plugin/snipMate.vim"[J
line 1: " File:          snipMate.vim[J

line 2: " Author:        Michael Sanders[J

line 3: " Last Updated:  July 13, 2009[J

line 4: " Version:       0.83[J

line 5: " Description:   snipMate.vim implements some of TextMate's snippets features in[J

line 6: "                Vim. A snippet is a piece of often-typed text that you can[J

line 7: "                insert into your document using a trigger word followed by a "<tab>".[J

line 8: "[J

line 9: "                For more help see snipMate.txt; you can do this by using:[J

line 10: "                :helptags ~/.vim/doc[J

line 11: "                :h snipMate.txt[J

line 12: [J

line 13: if exists('loaded_snips') || &cp || version < 700[J

line 14: ^Ifinish[J

line 15: endif[J

line 16: let loaded_snips = 1[J

line 17: if !exists('snips_author') | let snips_author = 'Me' | endif[J

line 17:  let snips_author = 'Me' | endif[J

line 17:  endif[J

line 18: [J

line 19: au BufRead,BufNewFile *.snippets\= set ft=snippet[J

line 20: au FileType snippet setl noet fdm=indent[J

line 21: [J

line 22: let s:snippets = {} | let s:multi_snips = {}[J

line 22:  let s:multi_snips = {}[J

line 23: [J

line 24: if !exists('snippets_dir')[J

line 25: ^Ilet snippets_dir = substitute(globpath(&rtp, 'snippets/'), "\n", ',', 'g')[J

line 26: endif[J

line 27: [J

line 28: fun! MakeSnip(scope, trigger, content, ...)[J

line 40: [J

line 41: fun! ExtractSnips(dir, ft)[J

line 53: [J

line 54: " Processes a single-snippet file; optionally add the name of the parent[J

line 55: " directory for a snippet with multiple matches.[J

line 56: fun s:ProcessFile(file, ft, ...)[J

line 67: [J

line 68: fun! ExtractSnipsFile(file, ft)[J

line 94: [J

line 95: fun! ResetSnippets()[J

line 98: [J

line 99: let g:did_ft = {}[J

line 100: fun! GetSnippets(dir, filetypes)[J

line 112: [J

line 113: " Define "aliasft" snippets for the filetype "realft".[J

line 114: fun s:DefineSnips(dir, aliasft, realft)[J

line 124: [J

line 125: fun! TriggerSnippet()[J

line 162: [J

line 163: fun! BackwardsSnippet()[J

line 179: [J

line 180: " Check if word under cursor is snippet trigger; if it isn't, try checking if[J

line 181: " the text after non-word characters is (e.g. check for "foo" in "bar.foo")[J

line 182: fun s:GetSnippet(word, scope)[J

line 200: [J

line 201: fun s:ChooseSnippet(scope, trigger)[J

line 212: [J

line 213: fun! ShowAvailableSnips()[J

line 247: " vim:noet:sw=4:ts=4:ft=vim[J

finished sourcing /Users/Eric/.vim/bundle/snipmate/plugin/snipMate.vim[J
Searching for "/Users/Eric/.vim/bundle/vim-abolish/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/vim-abolish/plugin/abolish.vim"[J
line 1: " abolish.vim - Language friendly searches, substitutions, and abbreviations[J

line 2: " Maintainer:   Tim Pope <vimNOSPAM@tpope.org>[J

line 3: " Version:      1.0[J

line 4: [J

line 5: " Install this file as plugin/abolish.vim.  See doc/abolish.txt for details.[J

line 6: " To access it from Vim, see :help add-local-help (hint: :helptags ~/.vim/doc)[J

line 7: " Afterwards, you should be able to do :help abolish[J

line 8: [J

line 9: " Initialization {{{1[J

line 10: [J

line 11: " Exit quickly when:[J

line 12: " - this plugin was already loaded (or disabled)[J

line 13: " - when 'compatible' is set[J

line 14: " - Vim is older than 7.0[J

line 15: if (exists("g:loaded_abolish") && g:loaded_abolish) || &cp || v:version < 700[J

line 16:     finish[J

line 17: endif[J

line 18: let g:loaded_abolish = 1[J

line 19: [J

line 20: let s:cpo_save = &cpo[J

line 21: set cpo&vim[J

line 22: [J

line 23: if !exists("g:abolish_save_file")[J

line 24:     if strpart(expand("<sfile>"),0,strlen(expand("~"))) == expand("~")[J

line 25:         let g:abolish_save_file = expand("<sfile>:h:h")."/after/plugin/abolish.vim"[J

line 26:     elseif isdirectory(expand("~/.vim"))[J

line 27:         let g:abolish_save_file = expand("~/.vim/after/plugin/abolish.vim")[J

line 28:     elseif isdirectory(expand("~/vimfiles")) || has("win32")[J

line 29:         let g:abolish_save_file = expand("~/vimfiles/after/plugin/abolish.vim")[J

line 30:     else[J

line 31:         let g:abolish_save_file = expand("~/.vim/after/plugin/abolish.vim")[J

line 32:     endif[J

line 33: endif[J

line 34: [J

line 35: " }}}1[J

line 36: " Utility functions {{{1[J

line 37: [J

line 38: function! s:function(name)[J

line 41: [J

line 42: function! s:send(self,func,...)[J

line 61: [J

line 62: let s:object = {}[J

line 63: function! s:object.clone(...)[J

line 67: [J

line 68: if !exists("g:Abolish")[J

line 69:     let Abolish = {}[J

line 70: endif[J

line 71: call extend(Abolish, s:object, 'force')[J

line 72: call extend(Abolish, {'Coercions': {}}, 'keep')[J

line 73: [J

line 74: function! s:throw(msg)[J

line 78: [J

line 79: function! s:words()[J

line 93: [J

line 94: function! s:extractopts(list,opts)[J

line 115: [J

line 116: " }}}1[J

line 117: " Dictionary creation {{{1[J

line 118: [J

line 119: function! s:mixedcase(word)[J

line 122: [J

line 123: function! s:camelcase(word)[J

line 130: [J

line 131: function! s:snakecase(word)[J

line 139: [J

line 140: function! s:uppercase(word)[J

line 143: [J

line 144: function! s:dashcase(word)[J

line 147: [J

line 154: call extend(Abolish, { 'camelcase':  s:function('s:camelcase'), 'mixedcase':  s:function('s:mixedcase'), 'snakecase':  s:function('s:snakecase'), 'uppercase':  s:function('s:uppercase'), 'dashcase':   s:function('s:dashcase') }, 'keep')[J

calling function <SNR>20_function[J('s:camelcase')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>20_function returning function('<SNR>20_camelcase')[J

continuing in /Users/Eric/.config/vim/bundle/vim-abolish/plugin/abolish.vim[J

calling function <SNR>20_function[J('s:mixedcase')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>20_function returning function('<SNR>20_mixedcase')[J

continuing in /Users/Eric/.config/vim/bundle/vim-abolish/plugin/abolish.vim[J

calling function <SNR>20_function[J('s:snakecase')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>20_function returning function('<SNR>20_snakecase')[J

continuing in /Users/Eric/.config/vim/bundle/vim-abolish/plugin/abolish.vim[J

calling function <SNR>20_function[J('s:uppercase')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>20_function returning function('<SNR>20_uppercase')[J

continuing in /Users/Eric/.config/vim/bundle/vim-abolish/plugin/abolish.vim[J

calling function <SNR>20_function[J('s:dashcase')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>20_function returning function('<SNR>20_dashcase')[J

continuing in /Users/Eric/.config/vim/bundle/vim-abolish/plugin/abolish.vim[J

line 155: [J

line 156: function! s:create_dictionary(lhs,rhs,opts)[J

line 171: [J

line 172: function! s:expand_braces(dict)[J

line 201: [J

line 202: " }}}1[J

line 203: " Abolish Dispatcher {{{1[J

line 204: [J

line 205: function! s:SubComplete(A,L,P)[J

line 213: [J

line 214: function! s:Complete(A,L,P)[J

line 227: [J

line 228: let s:commands = {}[J

line 229: let s:commands.abstract = s:object.clone()[J

calling function 140[J()

line 1:     let sub = deepcopy(self)[J

line 2:     return a:0 ? extend(sub,a:1) : sub[J

function 140 returning {'clone': function('140')}[J

continuing in /Users/Eric/.config/vim/bundle/vim-abolish/plugin/abolish.vim[J

line 230: [J

line 231: function! s:commands.abstract.dispatch(bang,line1,line2,count,args)[J

line 234: [J

line 235: function! s:commands.abstract.go(bang,line1,line2,count,args)[J

line 242: [J

line 243: function! s:dispatcher(bang,line1,line2,count,args)[J

line 264: [J

line 265: " }}}1[J

line 266: " Subvert Dispatcher {{{1[J

line 267: [J

line 268: function! s:subvert_dispatcher(bang,line1,line2,count,args)[J

line 278: [J

line 279: function! s:parse_subvert(bang,line1,line2,count,args)[J

line 305: [J

line 306: function! s:normalize_options(flags)[J

line 327: [J

line 328: " }}}1[J

line 329: " Searching {{{1[J

line 330: [J

line 331: function! s:subesc(pattern)[J

line 334: [J

line 335: function! s:sort(a,b)[J

line 344: [J

line 345: function! s:pattern(dict,boundaries)[J

line 358: [J

line 359: function! s:egrep_pattern(dict,boundaries)[J

line 372: [J

line 373: function! s:c()[J

line 377: [J

line 378: function! s:find_command(cmd,flags,word)[J

line 396: [J

line 397: function! s:grep_command(args,bang,flags,word)[J

line 407: [J

line 408: let s:commands.search = s:commands.abstract.clone()[J

calling function 140[J()

line 1:     let sub = deepcopy(self)[J

line 2:     return a:0 ? extend(sub,a:1) : sub[J

function 140 returning {'clone': function('140'), 'go': func...ion('142'), 'dispatch': function('141')}[J

continuing in /Users/Eric/.config/vim/bundle/vim-abolish/plugin/abolish.vim[J

line 409: let s:commands.search.options = {"word": 0, "variable": 0, "flags": ""}[J

line 410: [J

line 411: function! s:commands.search.process(bang,line1,line2,count,args)[J

line 427: [J

line 428: " }}}1[J

line 429: " Substitution {{{1[J

line 430: [J

line 431: function! Abolished()[J

line 434: [J

line 435: function! s:substitute_command(cmd,bad,good,flags)[J

line 442: [J

line 443: function! s:parse_substitute(bang,line1,line2,count,args)[J

line 464: [J

line 465: let s:commands.substitute = s:commands.abstract.clone()[J

calling function 140[J()

line 1:     let sub = deepcopy(self)[J

line 2:     return a:0 ? extend(sub,a:1) : sub[J

function 140 returning {'clone': function('140'), 'go': func...ion('142'), 'dispatch': function('141')}[J

continuing in /Users/Eric/.config/vim/bundle/vim-abolish/plugin/abolish.vim[J

line 466: let s:commands.substitute.options = {"word": 0, "variable": 0, "flags": "g"}[J

line 467: [J

line 468: function! s:commands.substitute.process(bang,line1,line2,count,args)[J

line 484: [J

line 485: " }}}1[J

line 486: " Abbreviations {{{1[J

line 487: [J

line 488: function! s:badgood(args)[J

line 499: [J

line 500: function! s:abbreviate_from_dict(cmd,dict)[J

line 505: [J

line 506: let s:commands.abbrev     = s:commands.abstract.clone()[J

calling function 140[J()

line 1:     let sub = deepcopy(self)[J

line 2:     return a:0 ? extend(sub,a:1) : sub[J

function 140 returning {'clone': function('140'), 'go': func...ion('142'), 'dispatch': function('141')}[J

continuing in /Users/Eric/.config/vim/bundle/vim-abolish/plugin/abolish.vim[J

line 507: let s:commands.abbrev.options = {"buffer":0,"cmdline":0,"delete":0}[J

line 508: function! s:commands.abbrev.process(bang,line1,line2,count,args)[J

line 548: [J

line 549: let s:commands.delete   = s:commands.abbrev.clone()[J

calling function 140[J()

line 1:     let sub = deepcopy(self)[J

line 2:     return a:0 ? extend(sub,a:1) : sub[J

function 140 returning {'options': {'cmdline': 0, 'delete': ...tion('141'), 'process': function('145')}[J

continuing in /Users/Eric/.config/vim/bundle/vim-abolish/plugin/abolish.vim[J

line 550: let s:commands.delete.options.delete = 1[J

line 551: [J

line 552: " }}}1[J

line 553: " Maps {{{1[J

line 554: [J

line 555: function! s:unknown_coercion(letter,word)[J

line 558: [J

line 567: call extend(Abolish.Coercions, { 'c': Abolish.camelcase, 'm': Abolish.mixedcase, 's': Abolish.snakecase, '_': Abolish.snakecase, 'u': Abolish.uppercase, '-': Abolish.dashcase, "function missing": s:function("s:unknown_coercion")}, "keep")[J

calling function <SNR>20_function[J('s:unknown_coercion')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>20_function returning function('<SNR>20_unknown_coercion')[J

continuing in /Users/Eric/.config/vim/bundle/vim-abolish/plugin/abolish.vim[J

line 568: [J

line 569: function! s:coerce(transformation)[J

line 595: [J

line 596: nnoremap <silent> <Plug>Coerce :<C-U>call <SID>coerce(nr2char(getchar()))<CR>[J

line 597: [J

line 598: " }}}1[J

line 599: [J

line 600: nmap cr  <Plug>Coerce[J

line 601: [J

line 603: command! -nargs=+ -bang -bar -range=0 -complete=custom,s:Complete Abolish :exec s:dispatcher(<bang>0,<line1>,<line2>,<count>,[<f-args>])[J

line 605: command! -nargs=1 -bang -bar -range=0 -complete=custom,s:SubComplete Subvert :exec s:subvert_dispatcher(<bang>0,<line1>,<line2>,<count>,<q-args>)[J

line 606: if exists(':S') != 2[J

line 608:     command -nargs=1 -bang -bar -range=0 -complete=custom,s:SubComplete S :exec s:subvert_dispatcher(<bang>0,<line1>,<line2>,<count>,<q-args>)[J

line 609: endif[J

line 610: [J

line 611: let &cpo = s:cpo_save[J

line 612: [J

line 613: " vim:set ft=vim ts=8 sw=4 sts=4:[J

finished sourcing /Users/Eric/.vim/bundle/vim-abolish/plugin/abolish.vim[J
Searching for "/Users/Eric/.vim/bundle/vim-cucumber/plugin/**/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-endwise/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/vim-endwise/plugin/endwise.vim"[J
line 1: " endwise.vim - EndWise[J

line 2: " Author:       Tim Pope <vimNOSPAM@tpope.info>[J

line 3: " Version:      1.0[J

line 4: [J

line 5: " Distributable under the same terms as Vim itself (see :help license)[J

line 6: [J

line 7: " Exit quickly when:[J

line 8: " - this plugin was already loaded (or disabled)[J

line 9: " - when 'compatible' is set[J

line 10: if (exists("g:loaded_endwise") && g:loaded_endwise) || &cp[J

line 11:     finish[J

line 12: endif[J

line 13: let g:loaded_endwise = 1[J

line 14: [J

line 15: [J

line 16: let s:cpo_save = &cpo[J

line 17: set cpo&vim[J

line 18: [J

line 19: augroup endwise " {{{1[J

line 20:     au![J

line 25:     autocmd FileType ruby let b:endwise_addition = '\=submatch(0)=="{" ? "}" : "end"' | let b:endwise_words = 'module,class,def,if,unless,case,while,until,begin,do' | let b:endwise_pattern = '^\s*\zs\%(module\|class\|def\|if\|unless\|case\|while\|until\|for\|\|begin\)\>\%(.*[^.:@$]\<end\>\)\@!\|\<do\ze\%(\s*|.*|\)\=\s*$' | let b:endwise_syngroups = 'rubyModule,rubyClass,rubyDefine,rubyControl,rubyConditional,rubyRepeat'[J

line 30:     autocmd FileType vb,vbnet,aspvbs let b:endwise_addition = 'End &' | let b:endwise_words = 'Function,Sub,Class,Module,Enum,Namespace' | let b:endwise_pattern = '\%(\<End\>.*\)\@<!\<&\>' | let b:endwise_syngroups = 'vbStatement,vbnetStorage,vbnetProcedure,vbnet.*Words,AspVBSStatement'[J

line 34:     autocmd FileType vim let b:endwise_addition = 'end&' | let b:endwise_words = 'fu\%[nction],wh\%[ile],if,for,try' | let b:endwise_syngroups = 'vimFuncKey,vimNotFunc,vimCommand'[J

line 35: augroup END " }}}1[J

line 36: [J

line 37: " Maps {{{1[J

line 38: [J

line 39: if maparg("<Plug>DiscretionaryEnd") == ""[J

line 40:     inoremap <silent> <SID>DiscretionaryEnd <C-R>=<SID>crend(0)<CR>[J

line 41:     inoremap <silent> <SID>AlwaysEnd        <C-R>=<SID>crend(1)<CR>[J

line 42:     imap    <script> <Plug>DiscretionaryEnd <SID>DiscretionaryEnd[J

line 43:     imap    <script> <Plug>AlwaysEnd        <SID>AlwaysEnd[J

line 44: endif[J

line 45: if maparg('<CR>','i') =~# '<C-R>=.*crend(.)<CR>\|<\%(Plug\|SID\)>.*End'[J

line 46:     " Already mapped[J

line 47: elseif maparg('<CR>','i') =~ '<CR>'[J

line 48:     exe "imap <script> <C-X><CR> ".maparg('<CR>','i')."<SID>AlwaysEnd"[J

line 49:     exe "imap <script> <CR>      ".maparg('<CR>','i')."<SID>DiscretionaryEnd"[J

line 50: else[J

line 51:     imap <C-X><CR> <CR><Plug>AlwaysEnd[J

line 52:     imap <CR>      <CR><Plug>DiscretionaryEnd[J

line 53: endif[J

line 54: [J

line 55: if maparg('<M-o>','i') == ''[J

line 56:     inoremap <M-o> <C-O>o[J

line 57: endif[J

line 58: [J

line 59: " }}}1[J

line 60: [J

line 61: " Code {{{1[J

line 62: [J

line 63: function! s:mysearchpair(beginpat,endpat,synpat)[J

line 70: [J

line 71: function! s:crend(always)[J

line 113: [J

line 114: function! s:synname()[J

line 126: [J

line 127: " }}}1[J

line 128: [J

line 129: let &cpo = s:cpo_save[J

line 130: [J

line 131: " vim:set ft=vim ff=unix ts=8 sw=4 sts=4:[J

finished sourcing /Users/Eric/.vim/bundle/vim-endwise/plugin/endwise.vim[J
Searching for "/Users/Eric/.vim/bundle/vim-fugitive/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/vim-fugitive/plugin/fugitive.vim"[J
line 1: " fugitive.vim - A Git wrapper so awesome, it should be illegal[J

line 2: " Maintainer:   Tim Pope <vimNOSPAM@tpope.org>[J

line 3: " Version:      1.1[J

line 4: " GetLatestVimScripts: 2975 1 :AutoInstall: fugitive.vim[J

line 5: [J

line 6: if exists('g:loaded_fugitive') || &cp[J

line 7:   finish[J

line 8: endif[J

line 9: let g:loaded_fugitive = 1[J

line 10: [J

line 11: if !exists('g:fugitive_git_executable')[J

line 12:   let g:fugitive_git_executable = 'git'[J

line 13: endif[J

line 14: [J

line 15: " Utility {{{1[J

line 16: [J

line 17: function! s:function(name) abort[J

line 20: [J

line 21: function! s:sub(str,pat,rep) abort[J

line 24: [J

line 25: function! s:gsub(str,pat,rep) abort[J

line 28: [J

line 29: function! s:shellesc(arg) abort[J

line 38: [J

line 39: function! s:fnameescape(file) abort[J

line 46: [J

line 47: function! s:throw(string) abort[J

line 51: [J

line 52: function! s:warn(str)[J

line 58: [J

line 59: function! s:shellslash(path)[J

line 66: [J

line 67: function! s:add_methods(namespace, method_names) abort[J

line 72: [J

line 73: let s:commands = [][J

line 74: function! s:command(definition) abort[J

line 77: [J

line 78: function! s:define_commands()[J

line 83: [J

line 84: function! s:compatibility_check()[J

line 90: [J

line 91: augroup fugitive_utility[J

line 92:   autocmd![J

line 93:   autocmd User Fugitive call s:define_commands()[J

line 94:   autocmd VimEnter * call s:compatibility_check()[J

line 95: augroup END[J

line 96: [J

line 97: let s:abstract_prototype = {}[J

line 98: [J

line 99: " }}}1[J

line 100: " Initialization {{{1[J

line 101: [J

line 102: function! s:ExtractGitDir(path) abort[J

line 121: [J

line 122: function! s:Detect(path)[J

line 144: [J

line 145: augroup fugitive[J

line 146:   autocmd![J

line 147:   autocmd BufNewFile,BufReadPost * call s:Detect(expand('<amatch>:p'))[J

line 148:   autocmd FileType           netrw call s:Detect(expand('<afile>:p'))[J

line 149:   autocmd VimEnter * if expand('<amatch>')==''|call s:Detect(getcwd())|endif[J

line 150:   autocmd BufWinLeave * execute getwinvar(+winnr(), 'fugitive_restore')[J

line 151: augroup END[J

line 152: [J

line 153: " }}}1[J

line 154: " Repository {{{1[J

line 155: [J

line 156: let s:repo_prototype = {}[J

line 157: let s:repos = {}[J

line 158: [J

line 159: function! s:repo(...) abort[J

line 172: [J

line 173: function! s:repo_dir(...) dict abort[J

line 176: [J

line 177: function! s:repo_tree(...) dict abort[J

line 184: [J

line 185: function! s:repo_bare() dict abort[J

line 188: [J

line 189: function! s:repo_translate(spec) dict abort[J

line 229: [J

line 230: call s:add_methods('repo',['dir','tree','bare','translate'])[J

calling function <SNR>22_add_methods[J('repo', ['dir', 'tree', 'bare', 'translate'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:repo_dir')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_repo_dir')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:repo_tree')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_repo_tree')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:repo_bare')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_repo_bare')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:repo_translate')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_repo_translate')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>22_add_methods returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 231: [J

line 232: function! s:repo_git_command(...) dict abort[J

line 236: [J

line 237: function! s:repo_git_chomp(...) dict abort[J

line 240: [J

line 241: function! s:repo_git_chomp_in_tree(...) dict abort[J

line 251: [J

line 252: function! s:repo_rev_parse(rev) dict abort[J

line 259: [J

line 260: call s:add_methods('repo',['git_command','git_chomp','git_chomp_in_tree','rev_parse'])[J

calling function <SNR>22_add_methods[J('repo', ['git_command', 'git_chomp', 'git_cho...homp', 'git_chomp_in_tree', 'rev_parse'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:repo_git_command')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_repo_git_command')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:repo_git_chomp')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_repo_git_chomp')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:repo_git_chomp_in_tree')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_repo_git_chomp_in_t...nction('<SNR>22_repo_git_chomp_in_tree')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:repo_rev_parse')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_repo_rev_parse')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>22_add_methods returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 261: [J

line 262: function! s:repo_dirglob(base) dict abort[J

line 268: [J

line 269: function! s:repo_superglob(base) dict abort[J

line 306: [J

line 307: call s:add_methods('repo',['dirglob','superglob'])[J

calling function <SNR>22_add_methods[J('repo', ['dirglob', 'superglob'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:repo_dirglob')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_repo_dirglob')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:repo_superglob')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_repo_superglob')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>22_add_methods returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 308: [J

line 309: function! s:repo_keywordprg() dict abort[J

line 317: [J

line 318: call s:add_methods('repo',['keywordprg'])[J

calling function <SNR>22_add_methods[J('repo', ['keywordprg'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:repo_keywordprg')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_repo_keywordprg')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>22_add_methods returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 319: [J

line 320: " }}}1[J

line 321: " Buffer {{{1[J

line 322: [J

line 323: let s:buffer_prototype = {}[J

line 324: [J

line 325: function! s:buffer(...) abort[J

line 333: [J

line 334: function! fugitive#buffer(...) abort[J

Searching for "autoload/fugitive.vim" in "/Users/Eric/.vim,/Users/Eric/.vim/bundle/align,/Users/Eric/.vim/bundle/command-t,/Users/Eric/.vim/bundle/gist,/Users/Eric/.vim/bundle/nerdcommenter,/Users/Eric/.vim/bundle/nerdtree,/Users/Eric/.vim/bundle/snipmate,/Users/Eric/.vim/bundle/vim-abolish,/Users/Eric/.vim/bundle/vim-cucumber,/Users/Eric/.vim/bundle/vim-endwise,/Users/Eric/.vim/bundle/vim-fugitive,/Users/Eric/.vim/bundle/vim-git,/Users/Eric/.vim/bundle/vim-markdown-preview,/Users/Eric/.vim/bundle/vim-pastie,/Users/Eric/.vim/bundle/vim-rails,/Users/Eric/.vim/bundle/vim-repeat,/Users/Eric/.vim/bundle/vim-rspec,/Users/Eric/.vim/bundle/vim-surround,/Users/Eric/.vim/bundle/vim-unimpaired,/usr/share/vim/vimfiles,/usr/share/vim/vim72,/usr/share/vim/vimfiles/after,/Users/Eric/.vim/bundle/snipmate/after,/Users/Eric/.vim/after"[J
Searching for "/Users/Eric/.vim/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/align/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/command-t/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/gist/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/nerdcommenter/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/nerdtree/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/snipmate/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-abolish/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-cucumber/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-endwise/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-fugitive/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-git/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-markdown-preview/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-pastie/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-rails/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-repeat/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-rspec/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-surround/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-unimpaired/autoload/fugitive.vim"[J
Searching for "/usr/share/vim/vimfiles/autoload/fugitive.vim"[J
Searching for "/usr/share/vim/vim72/autoload/fugitive.vim"[J
Searching for "/usr/share/vim/vimfiles/after/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/bundle/snipmate/after/autoload/fugitive.vim"[J
Searching for "/Users/Eric/.vim/after/autoload/fugitive.vim"[J
not found in 'runtimepath': "autoload/fugitive.vim"[J
line 337: [J

line 338: function! s:buffer_getvar(var) dict abort[J

line 341: [J

line 342: function! s:buffer_setvar(var,value) dict abort[J

line 345: [J

line 346: function! s:buffer_getline(lnum) dict abort[J

line 349: [J

line 350: function! s:buffer_repo() dict abort[J

line 353: [J

line 354: function! s:buffer_type(...) dict abort[J

line 380: [J

line 381: function! s:buffer_spec() dict abort[J

line 385: [J

line 386: function! s:buffer_name() dict abort[J

line 389: [J

line 390: function! s:buffer_commit() dict abort[J

line 393: [J

line 394: function! s:buffer_path(...) dict abort[J

line 403: [J

line 404: function! s:buffer_rev() dict abort[J

line 418: [J

line 419: function! s:buffer_sha1() dict abort[J

line 426: [J

line 427: function! s:buffer_expand(rev) dict abort[J

line 442: [J

line 443: function! s:buffer_containing_commit() dict abort[J

line 452: [J

line 453: call s:add_methods('buffer',['getvar','setvar','getline','repo','type','spec','name','commit','path','rev','sha1','expand','containing_commit'])[J

calling function <SNR>22_add_methods[J('buffer', ['getvar', 'setvar', 'getline', 'repo..., 'sha1', 'expand', 'containing_commit'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:buffer_getvar')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_buffer_getvar')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:buffer_setvar')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_buffer_setvar')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:buffer_getline')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_buffer_getline')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:buffer_repo')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_buffer_repo')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:buffer_type')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_buffer_type')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:buffer_spec')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_buffer_spec')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:buffer_name')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_buffer_name')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:buffer_commit')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_buffer_commit')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:buffer_path')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_buffer_path')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:buffer_rev')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_buffer_rev')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:buffer_sha1')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_buffer_sha1')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:buffer_expand')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_buffer_expand')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:buffer_containing_commit')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_buffer_containing_c...tion('<SNR>22_buffer_containing_commit')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>22_add_methods returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 454: [J

line 455: " }}}1[J

line 456: " Git {{{1[J

line 457: [J

line 458: call s:command("-bang -nargs=? -complete=customlist,s:GitComplete Git :execute s:Git(<bang>0,<q-args>)")[J

calling function <SNR>22_command[J('-bang -nargs=? -complete=customlist,...te Git :execute s:Git(<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 459: [J

line 460: function! s:ExecuteInTree(cmd) abort[J

line 470: [J

line 471: function! s:Git(bang,cmd) abort[J

line 481: [J

line 482: function! s:GitComplete(A,L,P) abort[J

line 495: [J

line 496: " }}}1[J

line 497: " Gcd, Glcd {{{1[J

line 498: [J

line 499: function! s:DirComplete(A,L,P) abort[J

line 503: [J

line 504: call s:command("-bar -bang -nargs=? -complete=customlist,s:DirComplete Gcd  :cd<bang>  `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`")[J

calling function <SNR>22_command[J('-bar -bang -nargs=? -complete=custom...ir(<q-args>) : s:repo().tree(<q-args>)`')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 505: call s:command("-bar -bang -nargs=? -complete=customlist,s:DirComplete Glcd :lcd<bang> `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`")[J

calling function <SNR>22_command[J('-bar -bang -nargs=? -complete=custom...ir(<q-args>) : s:repo().tree(<q-args>)`')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 506: [J

line 507: " }}}1[J

line 508: " Gstatus {{{1[J

line 509: [J

line 510: call s:command("-bar Gstatus :execute s:Status()")[J

calling function <SNR>22_command[J('-bar Gstatus :execute s:Status()')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 511: [J

line 512: function! s:Status() abort[J

line 522: [J

line 523: function! fugitive#reload_status() abort[J

line 547: [J

line 548: function! s:StageDiff(bang) abort[J

line 568: [J

line 569: function! s:StageToggle(lnum1,lnum2) abort[J

line 615: [J

line 616: function! s:StagePatch(lnum1,lnum2) abort[J

line 662: [J

line 663: " }}}1[J

line 664: " Gcommit {{{1[J

line 665: [J

line 666: call s:command("-nargs=? -complete=customlist,s:CommitComplete Gcommit :execute s:Commit(<q-args>)")[J

calling function <SNR>22_command[J('-nargs=? -complete=customlist,s:Comm...ete Gcommit :execute s:Commit(<q-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 667: [J

line 668: function! s:Commit(args) abort[J

line 739: [J

line 740: function! s:CommitComplete(A,L,P) abort[J

line 748: [J

line 749: function! s:FinishCommit()[J

line 758: [J

line 759: augroup fugitive_commit[J

line 760:   autocmd![J

line 761:   autocmd VimLeavePre,BufDelete *.git/COMMIT_EDITMSG execute s:sub(s:FinishCommit(), '^echoerr (.*)', 'echohl ErrorMsg|echo \1|echohl NONE')[J

line 762: augroup END[J

line 763: [J

line 764: " }}}1[J

line 765: " Ggrep, Glog {{{1[J

line 766: [J

line 767: if !exists('g:fugitive_summary_format')[J

line 768:   let g:fugitive_summary_format = '%s'[J

line 769: endif[J

line 770: [J

line 771: call s:command("-bang -nargs=? -complete=customlist,s:EditComplete Ggrep :execute s:Grep(<bang>0,<q-args>)")[J

calling function <SNR>22_command[J('-bang -nargs=? -complete=customlist,...Ggrep :execute s:Grep(<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 772: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Glog :execute s:Log('grep<bang>',<f-args>)")[J

calling function <SNR>22_command[J('-bar -bang -nargs=* -complete=custom...:execute s:Log(''grep<bang>'',<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 773: [J

line 774: function! s:Grep(bang,arg) abort[J

line 806: [J

line 807: function! s:Log(cmd,...)[J

line 840: [J

line 841: " }}}1[J

line 842: " Gedit, Gpedit, Gsplit, Gvsplit, Gtabedit, Gread {{{1[J

line 843: [J

line 844: function! s:Edit(cmd,...) abort[J

line 871: [J

line 872: function! s:EditComplete(A,L,P) abort[J

line 875: [J

line 876: call s:command("-bar -bang -nargs=? -complete=customlist,s:EditComplete Ge       :execute s:Edit('edit<bang>',<f-args>)")[J

calling function <SNR>22_command[J('-bar -bang -nargs=? -complete=custom...execute s:Edit(''edit<bang>'',<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 877: call s:command("-bar -bang -nargs=? -complete=customlist,s:EditComplete Gedit    :execute s:Edit('edit<bang>',<f-args>)")[J

calling function <SNR>22_command[J('-bar -bang -nargs=? -complete=custom...execute s:Edit(''edit<bang>'',<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 878: call s:command("-bar -bang -nargs=? -complete=customlist,s:EditComplete Gpedit   :execute s:Edit('pedit<bang>',<f-args>)")[J

calling function <SNR>22_command[J('-bar -bang -nargs=? -complete=custom...xecute s:Edit(''pedit<bang>'',<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 879: call s:command("-bar -bang -nargs=? -complete=customlist,s:EditComplete Gsplit   :execute s:Edit('split<bang>',<f-args>)")[J

calling function <SNR>22_command[J('-bar -bang -nargs=? -complete=custom...xecute s:Edit(''split<bang>'',<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 880: call s:command("-bar -bang -nargs=? -complete=customlist,s:EditComplete Gvsplit  :execute s:Edit('vsplit<bang>',<f-args>)")[J

calling function <SNR>22_command[J('-bar -bang -nargs=? -complete=custom...ecute s:Edit(''vsplit<bang>'',<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 881: call s:command("-bar -bang -nargs=? -complete=customlist,s:EditComplete Gtabedit :execute s:Edit('tabedit<bang>',<f-args>)")[J

calling function <SNR>22_command[J('-bar -bang -nargs=? -complete=custom...cute s:Edit(''tabedit<bang>'',<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 882: call s:command("-bar -bang -nargs=? -count -complete=customlist,s:EditComplete Gread :execute s:Edit((!<count> && <line1> ? '' : <count>).'read<bang>',<f-args>)")[J

calling function <SNR>22_command[J('-bar -bang -nargs=? -count -complete...''' : <count>).''read<bang>'',<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 883: [J

line 884: " }}}1[J

line 885: " Gwrite {{{1[J

line 886: [J

line 887: call s:command("-bar -bang -nargs=? -complete=customlist,s:EditComplete Gwrite :execute s:Write(<bang>0,<f-args>)")[J

calling function <SNR>22_command[J('-bar -bang -nargs=? -complete=custom...rite :execute s:Write(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 888: [J

line 889: function! s:Write(force,...) abort[J

line 1006: [J

line 1007: " }}}1[J

line 1008: " Gdiff {{{1[J

line 1009: [J

line 1010: call s:command("-bang -bar -nargs=? -complete=customlist,s:EditComplete Gdiff :execute s:Diff(<bang>0,<f-args>)")[J

calling function <SNR>22_command[J('-bang -bar -nargs=? -complete=custom...Gdiff :execute s:Diff(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>22_command returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1011: [J

line 1012: augroup fugitive_diff[J

line 1013:   autocmd![J

line 1014:   autocmd BufWinLeave * if s:diff_window_count() == 2 && &diff && getbufvar(+expand('<abuf>'), 'git_dir') !=# '' | execute 'windo call s:diff_off()' | endif[J

line 1015:   autocmd BufWinEnter * if s:diff_window_count() == 1 && &diff && getbufvar(+expand('<abuf>'), 'git_dir') !=# '' | call s:diff_off() | endif[J

line 1016: augroup END[J

line 1017: [J

line 1018: function! s:diff_window_count()[J

line 1025: [J

line 1026: function! s:diff_off()[J

line 1031: [J

line 1032: function! s:buffer_compare_age(commit) dict abort[J

line 1051: [J

line 1052: call s:add_methods('buffer',['compare_age'])[J

calling function <SNR>22_add_methods[J('buffer', ['compare_age'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:buffer_compare_age')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_buffer_compare_age'...[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>22_add_methods returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1053: [J

line 1054: function! s:Diff(bang,...) abort[J

line 1105: [J

line 1106: " }}}1[J

line 1107: " Gmove, Gremove {{{1[J

line 1108: [J

line 1109: function! s:Move(force,destination)[J

line 1134: [J

line 1135: function! s:MoveComplete(A,L,P)[J

line 1144: [J

line 1145: function! s:Remove(force)[J

line 1166: [J

line 1167: augroup fugitive_remove[J

line 1168:   autocmd![J

line 1172:   autocmd User Fugitive if s:buffer().commit() =~# '^0\=$' | exe "command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)" | exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif[J

line 1173: augroup END[J

line 1174: [J

line 1175: " }}}1[J

line 1176: " Gblame {{{1[J

line 1177: [J

line 1178: augroup fugitive_blame[J

line 1179:   autocmd![J

line 1180:   autocmd BufReadPost *.fugitiveblame setfiletype fugitiveblame[J

line 1181:   autocmd FileType fugitiveblame setlocal nomodeline | if exists('b:git_dir') | let &l:keywordprg = s:repo().keywordprg() | endif[J

line 1182:   autocmd Syntax fugitiveblame call s:BlameSyntax()[J

line 1183:   autocmd User Fugitive if s:buffer().type('file', 'blob') | exe "command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])" | endif[J

line 1184: augroup END[J

line 1185: [J

line 1186: function! s:Blame(bang,line1,line2,count,args) abort[J

line 1266: [J

line 1267: function! s:BlameJump(suffix) abort[J

line 1299: [J

line 1300: function! s:BlameSyntax() abort[J

line 1325: [J

line 1326: " }}}1[J

line 1327: " File access {{{1[J

line 1328: [J

line 1329: function! s:ReplaceCmd(cmd,...) abort[J

line 1359: [J

line 1360: function! s:BufReadIndex()[J

line 1408: [J

line 1409: function! s:FileRead()[J

line 1425: [J

line 1426: function! s:BufReadIndexFile()[J

line 1439: [J

line 1440: function! s:BufWriteIndexFile()[J

line 1470: [J

line 1471: function! s:BufReadObject()[J

line 1540: [J

line 1541: augroup fugitive_files[J

line 1542:   autocmd![J

line 1543:   autocmd BufReadCmd  *.git/index                      exe s:BufReadIndex()[J

line 1544:   autocmd BufReadCmd  *.git/*index*.lock               exe s:BufReadIndex()[J

line 1545:   autocmd FileReadCmd fugitive://**//[0-3]/**          exe s:FileRead()[J

line 1546:   autocmd BufReadCmd  fugitive://**//[0-3]/**          exe s:BufReadIndexFile()[J

line 1547:   autocmd BufWriteCmd fugitive://**//[0-3]/**          exe s:BufWriteIndexFile()[J

line 1548:   autocmd BufReadCmd  fugitive://**//[0-9a-f][0-9a-f]* exe s:BufReadObject()[J

line 1549:   autocmd FileReadCmd fugitive://**//[0-9a-f][0-9a-f]* exe s:FileRead()[J

line 1550:   autocmd FileType git       call s:JumpInit()[J

line 1551: augroup END[J

line 1552: [J

line 1553: " }}}1[J

line 1554: " Go to file {{{1[J

line 1555: [J

line 1556: function! s:JumpInit() abort[J

line 1570: [J

line 1571: function! s:GF(mode) abort[J

line 1716: [J

line 1717: " }}}1[J

line 1718: " Statusline {{{1[J

line 1719: [J

line 1720: function! s:repo_head_ref() dict abort[J

line 1723: [J

line 1724: call s:add_methods('repo',['head_ref'])[J

calling function <SNR>22_add_methods[J('repo', ['head_ref'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:repo_head_ref')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_repo_head_ref')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>22_add_methods returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1725: [J

line 1726: function! fugitive#statusline(...)[J

line 1746: [J

line 1747: function! s:repo_config(conf) dict abort[J

line 1750: [J

line 1751: function! s:repo_user() dict abort[J

line 1756: [J

line 1757: call s:add_methods('repo',['config', 'user'])[J

calling function <SNR>22_add_methods[J('repo', ['config', 'user'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:repo_config')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_repo_config')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>22_add_methods..<SNR>22_function[J('s:repo_user')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>22_add_methods..<SNR>22_function returning function('<SNR>22_repo_user')[J

continuing in function <SNR>22_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>22_add_methods returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1758: [J

line 1759: " }}}1[J

line 1760: [J

line 1761: " vim:set ft=vim ts=8 sw=2 sts=2:[J

finished sourcing /Users/Eric/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J
Searching for "/Users/Eric/.vim/bundle/vim-git/plugin/**/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-markdown-preview/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/vim-markdown-preview/plugin/vmp.vim"[J
line 1: let g:VMPoutputformat    = 'html'[J

line 2: let g:VMPoutputdirectory = '/tmp'[J

line 3: let g:VMPhtmlreader      = 'open'[J

line 4: let g:VMPstylesheet      = 'github.css'[J

line 5: [J

line 6: function! PreviewMKD()[J

line 68: [J

line 69: :command! Mm :call PreviewMKD()[J

finished sourcing /Users/Eric/.vim/bundle/vim-markdown-preview/plugin/vmp.vim[J
Searching for "/Users/Eric/.vim/bundle/vim-pastie/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/vim-pastie/plugin/pastie.vim"[J
line 1: " pastie.vim - Interface for pastie.org[J

line 2: " Maintainer:   Tim Pope <vimNOSPAM@tpope.org>[J

line 3: " URL:          http://www.vim.org/scripts/script.php?script_id=1624[J

line 4: " GetLatestVimScripts: 1624 1 :AutoInstall: pastie.vim[J

line 5: [J

line 6: if exists("g:loaded_pastie") || &cp[J

line 7:     finish[J

line 8: endif[J

line 9: let g:loaded_pastie = 1[J

line 10: [J

line 11: augroup pastie[J

line 12:     autocmd![J

line 13:     autocmd BufReadPre  http://pastie.org/*[0-9]?key=*           call s:extractcookies(expand("<amatch>"))[J

line 14:     autocmd BufReadPost http://pastie.org/*[0-9]?key=*           call s:PastieSwapout(expand("<amatch>"))[J

line 15:     autocmd BufReadPost http://pastie.org/*[0-9]                 call s:PastieSwapout(expand("<amatch>"))[J

line 16:     autocmd BufReadPost http://pastie.org/pastes/*[0-9]/download call s:PastieRead(expand("<amatch>"))[J

line 17:     autocmd BufReadPost http://pastie.org/*[0-9].*               call s:PastieRead(expand("<amatch>"))[J

line 18:     autocmd BufWriteCmd http://pastie.org/pastes/*[0-9]/download call s:PastieWrite(expand("<amatch>"))[J

line 19:     autocmd BufWriteCmd http://pastie.org/*[0-9].*               call s:PastieWrite(expand("<amatch>"))[J

line 20:     autocmd BufWriteCmd http://pastie.org/pastes/                call s:PastieWrite(expand("<amatch>"))[J

line 21: [J

line 22:     autocmd BufReadPre  http://pastie.caboo.se/*[0-9]?key=*           call s:extractcookies(expand("<amatch>"))[J

line 23:     autocmd BufReadPost http://pastie.caboo.se/*[0-9]?key=*           call s:PastieSwapout(expand("<amatch>"))[J

line 24:     autocmd BufReadPost http://pastie.caboo.se/*[0-9]                 call s:PastieSwapout(expand("<amatch>"))[J

line 25:     autocmd BufReadPost http://pastie.caboo.se/pastes/*[0-9]/download call s:PastieRead(expand("<amatch>"))[J

line 26:     autocmd BufReadPost http://pastie.caboo.se/*[0-9].*               call s:PastieRead(expand("<amatch>"))[J

line 27:     autocmd BufWriteCmd http://pastie.caboo.se/pastes/*[0-9]/download call s:PastieWrite(expand("<amatch>"))[J

line 28:     autocmd BufWriteCmd http://pastie.caboo.se/*[0-9].*               call s:PastieWrite(expand("<amatch>"))[J

line 29:     autocmd BufWriteCmd http://pastie.caboo.se/pastes/                call s:PastieWrite(expand("<amatch>"))[J

line 30: augroup END[J

line 31: [J

line 32: let s:domain = "pastie.org"[J

line 33: [J

line 34: let s:dl_suffix = ".txt" " Used only for :file[J

line 35: [J

line 36: if !exists("g:pastie_destination")[J

line 37:     if version >= 700[J

line 38:         let g:pastie_destination = 'tab'[J

line 39:     else[J

line 40:         let g:pastie_destination = 'window'[J

line 41:     endif[J

line 42:     "let g:pastie_destination = 'buffer'[J

line 43: endif[J

line 44: [J

line 45: command! -bar -bang -nargs=* -range=0 -complete=file Pastie :call s:Pastie(<bang>0,<line1>,<line2>,<count>,<f-args>)[J

line 46: [J

line 47: function! s:Pastie(bang,line1,line2,count,...)[J

line 234: [J

line 235: function! s:dobufreadpost()[J

line 242: [J

line 243: function! s:PastieSwapout(file)[J

line 249: [J

line 250: function! s:PastieRead(file)[J

line 267: [J

line 268: function! s:afterload()[J

line 287: [J

line 288: function! s:PastieWrite(file)[J

line 334: [J

line 335: function! s:error(msg)[J

line 341: [J

line 342: function! s:filetype(type)[J

line 361: [J

line 362: function! s:parser(type)[J

line 378: [J

line 379: function! s:grabwin()[J

line 392: [J

line 393: function! s:cookies()[J

line 430: [J

line 431: function! s:extractcookies(path)[J

line 443: [J

line 444: function! s:extractcookiesfromheader(cookie)[J

line 461: [J

line 462: function! s:latestid()[J

line 465: [J

line 466: function! s:urlencode(str)[J

line 470: [J

line 471: function! s:newwindow()[J

line 485: [J

line 486: " vim:set sw=4 sts=4 et:[J

finished sourcing /Users/Eric/.vim/bundle/vim-pastie/plugin/pastie.vim[J
Searching for "/Users/Eric/.vim/bundle/vim-rails/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/vim-rails/plugin/rails.vim"[J
line 1: " rails.vim - Detect a rails application[J

line 2: " Author:       Tim Pope <vimNOSPAM@tpope.org>[J

line 3: " GetLatestVimScripts: 1567 1 :AutoInstall: rails.vim[J

line 4: " URL:          http://rails.vim.tpope.net/[J

line 5: [J

line 6: " Install this file as plugin/rails.vim.  See doc/rails.txt for details. (Grab[J

line 7: " it from the URL above if you don't have it.)  To access it from Vim, see[J

line 8: " :help add-local-help (hint: :helptags ~/.vim/doc) Afterwards, you should be[J

line 9: " able to do :help rails[J

line 10: [J

line 11: if exists('g:loaded_rails') || &cp || v:version < 700[J

line 12:   finish[J

line 13: endif[J

line 14: let g:loaded_rails = 1[J

line 15: [J

line 16: " Utility Functions {{{1[J

line 17: [J

line 18: function! s:error(str)[J

line 24: [J

line 25: function! s:autoload(...)[J

line 45: [J

line 46: " }}}1[J

line 47: " Configuration {{{[J

line 48: [J

line 49: function! s:SetOptDefault(opt,val)[J

line 54: [J

line 55: call s:SetOptDefault("rails_statusline",1)[J

calling function <SNR>25_SetOptDefault[J('rails_statusline', 1)

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>25_SetOptDefault returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-rails/plugin/rails.vim[J

line 56: call s:SetOptDefault("rails_syntax",1)[J

calling function <SNR>25_SetOptDefault[J('rails_syntax', 1)

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>25_SetOptDefault returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-rails/plugin/rails.vim[J

line 57: call s:SetOptDefault("rails_mappings",1)[J

calling function <SNR>25_SetOptDefault[J('rails_mappings', 1)

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>25_SetOptDefault returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-rails/plugin/rails.vim[J

line 58: call s:SetOptDefault("rails_abbreviations",1)[J

calling function <SNR>25_SetOptDefault[J('rails_abbreviations', 1)

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>25_SetOptDefault returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-rails/plugin/rails.vim[J

line 59: call s:SetOptDefault("rails_ctags_arguments","--languages=-javascript")[J

calling function <SNR>25_SetOptDefault[J('rails_ctags_arguments', '--languages=-javascript')

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>25_SetOptDefault returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-rails/plugin/rails.vim[J

line 60: call s:SetOptDefault("rails_default_file","README")[J

calling function <SNR>25_SetOptDefault[J('rails_default_file', 'README')

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>25_SetOptDefault returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-rails/plugin/rails.vim[J

line 61: call s:SetOptDefault("rails_root_url",'http://localhost:3000/')[J

calling function <SNR>25_SetOptDefault[J('rails_root_url', 'http://localhost:3000/')

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>25_SetOptDefault returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-rails/plugin/rails.vim[J

line 62: call s:SetOptDefault("rails_modelines",0)[J

calling function <SNR>25_SetOptDefault[J('rails_modelines', 0)

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>25_SetOptDefault returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-rails/plugin/rails.vim[J

line 63: call s:SetOptDefault("rails_menu",!has('mac'))[J

calling function <SNR>25_SetOptDefault[J('rails_menu', 1)

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>25_SetOptDefault returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-rails/plugin/rails.vim[J

line 64: call s:SetOptDefault("rails_gnu_screen",1)[J

calling function <SNR>25_SetOptDefault[J('rails_gnu_screen', 1)

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>25_SetOptDefault returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-rails/plugin/rails.vim[J

line 65: call s:SetOptDefault("rails_history_size",5)[J

calling function <SNR>25_SetOptDefault[J('rails_history_size', 5)

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>25_SetOptDefault returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-rails/plugin/rails.vim[J

line 66: call s:SetOptDefault("rails_generators","controller\ngenerator\nhelper\nintegration_test\nmailer\nmetal\nmigration\nmodel\nobserver\nperformance_test\nplugin\nresource\nscaffold\nscaffold_controller\nsession_migration\nstylesheets")[J

calling function <SNR>25_SetOptDefault[J('rails_generators', 'controller
generator
helper
integ...troller
session_migration
stylesheets')

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>25_SetOptDefault returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-rails/plugin/rails.vim[J

line 67: if exists("g:loaded_dbext") && executable("sqlite3") && ! executable("sqlite")[J

line 68:   " Since dbext can't find it by itself[J

line 69:   call s:SetOptDefault("dbext_default_SQLITE_bin","sqlite3")[J

line 70: endif[J

line 71: [J

line 72: " }}}1[J

line 73: " Detection {{{1[J

line 74: [J

line 75: function! s:escvar(r)[J

line 81: [J

line 82: function! s:Detect(filename)[J

line 115: [J

line 116: function! s:BufInit(path)[J

line 122: [J

line 123: " }}}1[J

line 124: " Initialization {{{1[J

line 125: [J

line 126: augroup railsPluginDetect[J

line 127:   autocmd![J

line 128:   autocmd BufNewFile,BufRead * call s:Detect(expand("<afile>:p"))[J

line 129:   autocmd VimEnter * if expand("<amatch>") == "" && !exists("b:rails_root") | call s:Detect(getcwd()) | endif | if exists("b:rails_root") | silent doau User BufEnterRails | endif[J

line 130:   autocmd FileType netrw if !exists("b:rails_root") | call s:Detect(expand("<afile>:p")) | endif | if exists("b:rails_root") | silent doau User BufEnterRails | endif[J

line 131:   autocmd BufEnter * if exists("b:rails_root")|silent doau User BufEnterRails|endif[J

line 132:   autocmd BufLeave * if exists("b:rails_root")|silent doau User BufLeaveRails|endif[J

line 133:   autocmd Syntax railslog if s:autoload()|call rails#log_syntax()|endif[J

line 134: augroup END[J

line 135: [J

line 136: command! -bar -bang -nargs=* -complete=dir Rails :if s:autoload()|call rails#new_app_command(<bang>0,<f-args>)|endif[J

line 137: [J

line 138: " }}}1[J

line 139: " abolish.vim support {{{1[J

line 140: [J

line 141: function! s:function(name)[J

line 144: [J

line 145: augroup railsPluginAbolish[J

line 146:   autocmd![J

line 147:   autocmd VimEnter * call s:abolish_setup()[J

line 148: augroup END[J

line 149: [J

line 150: function! s:abolish_setup()[J

line 160: [J

line 161: function! s:abolish_l(word)[J

line 165: [J

line 166: function! s:abolish_t(word)[J

line 173: [J

line 174: " }}}1[J

line 175: " Menus {{{1[J

line 176: [J

line 177: if !(g:rails_menu && has("menu"))[J

line 178:   finish[J

line 179: endif[J

line 180: [J

line 181: function! s:sub(str,pat,rep)[J

line 184: [J

line 185: function! s:gsub(str,pat,rep)[J

line 188: [J

line 189: function! s:menucmd(priority)[J

line 192: [J

line 193: function! s:CreateMenus() abort[J

line 250: [J

line 251: function! s:ProjectMenu()[J

line 269: [J

line 270: function! s:menuBufEnter()[J

line 304: [J

line 305: function! s:menuBufLeave()[J

line 320: [J

line 321: function! s:menuprompt(vimcmd,prompt)[J

line 328: [J

line 329: call s:CreateMenus()[J

calling function <SNR>25_CreateMenus[J()

line 1:   if exists("g:rails_installed_menu") && g:rails_installed_menu != ""[J

line 2:     exe "aunmenu ".s:gsub(g:rails_installed_menu,'\&','')[J

line 3:     unlet g:rails_installed_menu[J

line 4:   endif[J

line 5:   if has("menu") && (exists("g:did_install_default_menus") || exists("$CREAM")) && g:rails_menu[J

line 6:     if g:rails_menu > 1[J

line 7:       let g:rails_installed_menu = '&Rails'[J

line 8:     else[J

line 9:       let g:rails_installed_menu = '&Plugin.&Rails'[J

line 10:     endif[J

line 11:     let dots = s:gsub(g:rails_installed_menu,'[^.]','')[J

line 12:     let menucmd = s:menucmd(200)[J

line 13:     if exists("$CREAM")[J

line 14:       exe menucmd.g:rails_installed_menu.'.-PSep- :'[J

line 15:       exe menucmd.g:rails_installed_menu.'.&Related\ file\^I:R\ /\ Alt+] :R<CR>'[J

line 16:       exe menucmd.g:rails_installed_menu.'.&Alternate\ file\^I:A\ /\ Alt+[ :A<CR>'[J

line 17:       exe menucmd.g:rails_installed_menu.'.&File\ under\ cursor\^ICtrl+Enter :Rfind<CR>'[J

line 18:     else[J

line 19:       exe menucmd.g:rails_installed_menu.'.-PSep- :'[J

line 20:       exe menucmd.g:rails_installed_menu.'.&Related\ file\^I:R\ /\ ]f :R<CR>'[J

line 21:       exe menucmd.g:rails_installed_menu.'.&Alternate\ file\^I:A\ /\ [f :A<CR>'[J

line 22:       exe menucmd.g:rails_installed_menu.'.&File\ under\ cursor\^Igf :Rfind<CR>'[J

line 23:     endif[J

line 24:     exe menucmd.g:rails_installed_menu.'.&Other\ files.Application\ &Controller :Rcontroller application<CR>'[J

line 25:     exe menucmd.g:rails_installed_menu.'.&Other\ files.Application\ &Helper :Rhelper application<CR>'[J

line 26:     exe menucmd.g:rails_installed_menu.'.&Other\ files.Application\ &Javascript :Rjavascript application<CR>'[J

line 27:     exe menucmd.g:rails_installed_menu.'.&Other\ files.Application\ &Layout :Rlayout application<CR>'[J

line 28:     exe menucmd.g:rails_installed_menu.'.&Other\ files.Application\ &README :R doc/README_FOR_APP<CR>'[J

line 29:     exe menucmd.g:rails_installed_menu.'.&Other\ files.&Environment :Renvironment<CR>'[J

line 30:     exe menucmd.g:rails_installed_menu.'.&Other\ files.&Database\ Configuration :R config/database.yml<CR>'[J

line 31:     exe menucmd.g:rails_installed_menu.'.&Other\ files.Database\ &Schema :Rmigration 0<CR>'[J

line 32:     exe menucmd.g:rails_installed_menu.'.&Other\ files.R&outes :Rinitializer<CR>'[J

line 33:     exe menucmd.g:rails_installed_menu.'.&Other\ files.&Test\ Helper :Rintegrationtest<CR>'[J

line 34:     exe menucmd.g:rails_installed_menu.'.-FSep- :'[J

line 35:     exe menucmd.g:rails_installed_menu.'.Ra&ke\^I:Rake :Rake<CR>'[J

line 36:     let menucmd = substitute(menucmd,'200 $','500 ','')[J

line 37:     exe menucmd.g:rails_installed_menu.'.&Server\^I:Rserver.&Start\^I:Rserver :Rserver<CR>'[J

line 38:     exe menucmd.g:rails_installed_menu.'.&Server\^I:Rserver.&Force\ start\^I:Rserver! :Rserver!<CR>'[J

line 39:     exe menucmd.g:rails_installed_menu.'.&Server\^I:Rserver.&Kill\^I:Rserver!\ - :Rserver! -<CR>'[J

line 40:     exe substitute(menucmd,'<script>','<script> <silent>','').g:rails_installed_menu.'.&Evaluate\ Ruby\.\.\.\^I:Rp :call <SID>menuprompt("Rp","Code to execute and output: ")<CR>'[J

line 41:     exe menucmd.g:rails_installed_menu.'.&Console\^I:Rscript :Rscript console<CR>'[J

line 42:     exe menucmd.g:rails_installed_menu.'.&Preview\^I:Rpreview :Rpreview<CR>'[J

line 43:     exe menucmd.g:rails_installed_menu.'.&Log\ file\^I:Rlog :Rlog<CR>'[J

line 44:     exe substitute(s:sub(menucmd,'anoremenu','vnoremenu'),'<script>','<script> <silent>','').g:rails_installed_menu.'.E&xtract\ as\ partial\^I:Rextract :call <SID>menuprompt("'."'".'<,'."'".'>Rextract","Partial name (e.g., template or /controller/template): ")<CR>'[J

line 45:     exe menucmd.g:rails_installed_menu.'.&Migration\ writer\^I:Rinvert :Rinvert<CR>'[J

line 46:     exe menucmd.'         '.g:rails_installed_menu.'.-HSep- :'[J

line 47:     exe substitute(menucmd,'<script>','<script> <silent>','').g:rails_installed_menu.'.&Help\^I:help\ rails :if <SID>autoload()<Bar>exe RailsHelpCommand("")<Bar>endif<CR>'[J

line 48:     exe substitute(menucmd,'<script>','<script> <silent>','').g:rails_installed_menu.'.Abo&ut\^I :if <SID>autoload()<Bar>exe RailsHelpCommand("about")<Bar>endif<CR>'[J

line 49:     let g:rails_did_menus = 1[J

line 50:     call s:ProjectMenu()[J

line 51:     call s:menuBufLeave()[J

line 52:     if exists("b:rails_root")[J

line 53:       call s:menuBufEnter()[J

line 54:     endif[J

line 55:   endif[J

function <SNR>25_CreateMenus returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-rails/plugin/rails.vim[J

line 330: [J

line 331: augroup railsPluginMenu[J

line 332:   autocmd![J

line 333:   autocmd User BufEnterRails call s:menuBufEnter()[J

line 334:   autocmd User BufLeaveRails call s:menuBufLeave()[J

line 335:   " g:RAILS_HISTORY hasn't been set when s:InitPlugin() is called.[J

line 336:   autocmd VimEnter *         call s:ProjectMenu()[J

line 337: augroup END[J

line 338: [J

line 339: " }}}1[J

line 340: " vim:set sw=2 sts=2:[J

finished sourcing /Users/Eric/.vim/bundle/vim-rails/plugin/rails.vim[J
Searching for "/Users/Eric/.vim/bundle/vim-repeat/plugin/**/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/vim-rspec/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/vim-rspec/plugin/vim-rspec.vim"[J
line 1: "[J

line 2: " Vim Rspec[J

line 3: " Last change: March 5 2009[J

line 4: " Version> 0.0.5[J

line 5: " Maintainer: Eustáquio 'TaQ' Rangel[J

line 6: " License: GPL[J

line 7: " URL: git://github.com/taq/vim-rspec[J

line 8: "[J

line 9: " Script to run the spec command inside Vim[J

line 10: " To install, unpack the files on your ~/.vim directory and source it [J

line 11: "[J

line 12: " The following options can be set/overridden in your .vimrc[J

line 13: "   * g:RspecXSLPath     :: Path to xsl file[J

line 14: "   * g:RspecRBFilePath  :: Path to vim-rspec.rb[J

line 15: "   * g:RspecBin         :: Rspec binary command (in rspec 2 this is 'rspec')[J

line 16: "   * g:RspecOpts        :: Opts to send to rspec call[J

line 17: [J

line 18: let s:xsltproc_cmd^I= ""[J

line 19: let s:grep_cmd^I^I^I= ""[J

line 20: let s:hpricot_cmd^I^I= ""[J

line 21: let s:xslt^I^I^I^I= 0[J

line 22: let s:hpricot^I^I^I= 0[J

line 23: [J

line 24: function! s:find_xslt()[J

line 27: [J

line 28: function! s:find_grep()[J

line 31: [J

line 32: function! s:find_hpricot()[J

line 35: [J

line 36: function! s:error_msg(msg)[J

line 41: [J

line 42: function! s:notice_msg(msg)[J

line 47: [J

line 48: function! s:fetch(varname, default)[J

line 55: [J

line 56: function! s:RunSpecMain(type)[J

line 152: [J

line 153: function! s:TryToOpen()[J

line 163: [J

line 164: function! RunSpec()[J

line 167: [J

line 168: function! RunSpecs()[J

line 171: [J

line 172: command! RunSpec^Icall RunSpec()[J

line 173: command! RunSpecs^Icall RunSpecs()[J

finished sourcing /Users/Eric/.vim/bundle/vim-rspec/plugin/vim-rspec.vim[J
Searching for "/Users/Eric/.vim/bundle/vim-surround/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/vim-surround/plugin/surround.vim"[J
line 1: " surround.vim - Surroundings[J

line 2: " Author:       Tim Pope <vimNOSPAM@tpope.org>[J

line 3: " Version:      1.90[J

line 4: " GetLatestVimScripts: 1697 1 :AutoInstall: surround.vim[J

line 5: "[J

line 6: " See surround.txt for help.  This can be accessed by doing[J

line 7: "[J

line 8: " :helptags ~/.vim/doc[J

line 9: " :help surround[J

line 10: "[J

line 11: " Licensed under the same terms as Vim itself.[J

line 12: [J

line 13: " ============================================================================[J

line 14: [J

line 15: " Exit quickly when:[J

line 16: " - this plugin was already loaded or disabled[J

line 17: " - when 'compatible' is set[J

line 18: if (exists("g:loaded_surround") && g:loaded_surround) || &cp[J

line 19:   finish[J

line 20: endif[J

line 21: let g:loaded_surround = 1[J

line 22: [J

line 23: let s:cpo_save = &cpo[J

line 24: set cpo&vim[J

line 25: [J

line 26: " Input functions {{{1[J

line 27: [J

line 28: function! s:getchar()[J

line 35: [J

line 36: function! s:inputtarget()[J

line 50: [J

line 51: function! s:inputreplacement()[J

line 63: [J

line 64: function! s:beep()[J

line 68: [J

line 69: function! s:redraw()[J

line 73: [J

line 74: " }}}1[J

line 75: [J

line 76: " Wrapping functions {{{1[J

line 77: [J

line 78: function! s:extractbefore(str)[J

line 85: [J

line 86: function! s:extractafter(str)[J

line 93: [J

line 94: function! s:repeat(str,count)[J

line 103: [J

line 104: function! s:fixindent(str,spc)[J

line 113: [J

line 114: function! s:process(string)[J

line 153: [J

line 154: function! s:wrap(string,char,type,...)[J

line 312: [J

line 313: function! s:wrapreg(reg,char,...)[J

line 320: " }}}1[J

line 321: [J

line 322: function! s:insert(...) " {{{1[J

line 370: [J

line 371: function! s:reindent() " {{{1[J

line 376: [J

line 377: function! s:dosurround(...) " {{{1[J

line 480: [J

line 481: function! s:changesurround() " {{{1[J

line 492: [J

line 493: function! s:opfunc(type,...) " {{{1[J

line 553: [J

line 554: function! s:opfunc2(arg)[J

line 557: [J

line 558: function! s:closematch(str) " {{{1[J

line 573: [J

line 574: nnoremap <silent> <Plug>Dsurround  :<C-U>call <SID>dosurround(<SID>inputtarget())<CR>[J

line 575: nnoremap <silent> <Plug>Csurround  :<C-U>call <SID>changesurround()<CR>[J

line 576: nnoremap <silent> <Plug>Yssurround :<C-U>call <SID>opfunc(v:count1)<CR>[J

line 577: nnoremap <silent> <Plug>YSsurround :<C-U>call <SID>opfunc2(v:count1)<CR>[J

line 578: " <C-U> discards the numerical argument but there's not much we can do with it[J

line 579: nnoremap <silent> <Plug>Ysurround  :<C-U>set opfunc=<SID>opfunc<CR>g@[J

line 580: nnoremap <silent> <Plug>YSurround  :<C-U>set opfunc=<SID>opfunc2<CR>g@[J

line 581: vnoremap <silent> <Plug>Vsurround  :<C-U>call <SID>opfunc(visualmode())<CR>[J

line 582: vnoremap <silent> <Plug>VSurround  :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 1 : 0)<CR>[J

line 583: vnoremap <silent> <Plug>VgSurround :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 0 : 1)<CR>[J

line 584: inoremap <silent> <Plug>Isurround  <C-R>=<SID>insert()<CR>[J

line 585: inoremap <silent> <Plug>ISurround  <C-R>=<SID>insert(1)<CR>[J

line 586: [J

line 587: if !exists("g:surround_no_mappings") || ! g:surround_no_mappings[J

line 588:   nmap      ds   <Plug>Dsurround[J

line 589:   nmap      cs   <Plug>Csurround[J

line 590:   nmap      ys   <Plug>Ysurround[J

line 591:   nmap      yS   <Plug>YSurround[J

line 592:   nmap      yss  <Plug>Yssurround[J

line 593:   nmap      ySs  <Plug>YSsurround[J

line 594:   nmap      ySS  <Plug>YSsurround[J

line 595:   if !hasmapto("<Plug>Vsurround","v") && !hasmapto("<Plug>VSurround","v")[J

line 596:     if exists(":xmap")[J

line 597:       xmap  s    <Plug>Vsurround[J

line 598:     else[J

line 599:       vmap  s    <Plug>Vsurround[J

line 600:     endif[J

line 601:   endif[J

line 602:   if !hasmapto("<Plug>VSurround","v")[J

line 603:     if exists(":xmap")[J

line 604:       xmap  S    <Plug>VSurround[J

line 605:     else[J

line 606:       vmap  S    <Plug>VSurround[J

line 607:     endif[J

line 608:   endif[J

line 609:   if exists(":xmap")[J

line 610:     xmap    gS   <Plug>VgSurround[J

line 611:   else[J

line 612:     vmap    gS   <Plug>VgSurround[J

line 613:   endif[J

line 614:   if !hasmapto("<Plug>Isurround","i") && "" == mapcheck("<C-S>","i")[J

line 615:     imap    <C-S> <Plug>Isurround[J

line 616:   endif[J

line 617:   imap      <C-G>s <Plug>Isurround[J

line 618:   imap      <C-G>S <Plug>ISurround[J

line 619:   "Implemented internally instead[J

line 620:   "imap      <C-S><C-S> <Plug>ISurround[J

line 621: endif[J

line 622: [J

line 623: let &cpo = s:cpo_save[J

line 624: [J

line 625: " vim:set ft=vim sw=2 sts=2 et:[J

finished sourcing /Users/Eric/.vim/bundle/vim-surround/plugin/surround.vim[J
Searching for "/Users/Eric/.vim/bundle/vim-unimpaired/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/vim-unimpaired/plugin/unimpaired.vim"[J
line 1: " unimpaired.vim - Pairs of handy bracket mappings[J

line 2: " Maintainer:   Tim Pope <vimNOSPAM@tpope.org>[J

line 3: " Version:      1.1[J

line 4: [J

line 5: if exists("g:loaded_unimpaired") || &cp || v:version < 700[J

line 6:   finish[J

line 7: endif[J

line 8: let g:loaded_unimpaired = 1[J

line 9: [J

line 10: let s:cpo_save = &cpo[J

line 11: set cpo&vim[J

line 12: [J

line 13: " Next and previous {{{1[J

line 14: [J

line 15: function! s:MapNextFamily(map,cmd)[J

line 27: [J

line 28: call s:MapNextFamily('a','')[J

calling function <SNR>28_MapNextFamily[J('a', '')

line 1:   let map = '<Plug>unimpaired'.toupper(a:map)[J

line 2:   let end = ' ".(v:count ? v:count : "")<CR>'[J

line 3:   execute 'nmap <silent> '.map.'Previous :<C-U>exe "'.a:cmd.'previous'.end[J

line 3: nmap <silent> <Plug>unimpairedAPrevious :<C-U>exe "previous ".(v:count ? v:count : "")<CR>[J

line 4:   execute 'nmap <silent> '.map.'Next     :<C-U>exe "'.a:cmd.'next'.end[J

line 4: nmap <silent> <Plug>unimpairedANext     :<C-U>exe "next ".(v:count ? v:count : "")<CR>[J

line 5:   execute 'nmap <silent> '.map.'First    :<C-U>exe "'.a:cmd.'first'.end[J

line 5: nmap <silent> <Plug>unimpairedAFirst    :<C-U>exe "first ".(v:count ? v:count : "")<CR>[J

line 6:   execute 'nmap <silent> '.map.'Last     :<C-U>exe "'.a:cmd.'last'.end[J

line 6: nmap <silent> <Plug>unimpairedALast     :<C-U>exe "last ".(v:count ? v:count : "")<CR>[J

line 7:   execute 'nmap <silent> ['.        a:map .' '.map.'Previous'[J

line 7: nmap <silent> [a <Plug>unimpairedAPrevious[J

line 8:   execute 'nmap <silent> ]'.        a:map .' '.map.'Next'[J

line 8: nmap <silent> ]a <Plug>unimpairedANext[J

line 9:   execute 'nmap <silent> ['.toupper(a:map).' '.map.'First'[J

line 9: nmap <silent> [A <Plug>unimpairedAFirst[J

line 10:   execute 'nmap <silent> ]'.toupper(a:map).' '.map.'Last'[J

line 10: nmap <silent> ]A <Plug>unimpairedALast[J

function <SNR>28_MapNextFamily returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-unimpaired/plugin/unimpaired.vim[J

line 29: call s:MapNextFamily('b','b')[J

calling function <SNR>28_MapNextFamily[J('b', 'b')

line 1:   let map = '<Plug>unimpaired'.toupper(a:map)[J

line 2:   let end = ' ".(v:count ? v:count : "")<CR>'[J

line 3:   execute 'nmap <silent> '.map.'Previous :<C-U>exe "'.a:cmd.'previous'.end[J

line 3: nmap <silent> <Plug>unimpairedBPrevious :<C-U>exe "bprevious ".(v:count ? v:count : "")<CR>[J

line 4:   execute 'nmap <silent> '.map.'Next     :<C-U>exe "'.a:cmd.'next'.end[J

line 4: nmap <silent> <Plug>unimpairedBNext     :<C-U>exe "bnext ".(v:count ? v:count : "")<CR>[J

line 5:   execute 'nmap <silent> '.map.'First    :<C-U>exe "'.a:cmd.'first'.end[J

line 5: nmap <silent> <Plug>unimpairedBFirst    :<C-U>exe "bfirst ".(v:count ? v:count : "")<CR>[J

line 6:   execute 'nmap <silent> '.map.'Last     :<C-U>exe "'.a:cmd.'last'.end[J

line 6: nmap <silent> <Plug>unimpairedBLast     :<C-U>exe "blast ".(v:count ? v:count : "")<CR>[J

line 7:   execute 'nmap <silent> ['.        a:map .' '.map.'Previous'[J

line 7: nmap <silent> [b <Plug>unimpairedBPrevious[J

line 8:   execute 'nmap <silent> ]'.        a:map .' '.map.'Next'[J

line 8: nmap <silent> ]b <Plug>unimpairedBNext[J

line 9:   execute 'nmap <silent> ['.toupper(a:map).' '.map.'First'[J

line 9: nmap <silent> [B <Plug>unimpairedBFirst[J

line 10:   execute 'nmap <silent> ]'.toupper(a:map).' '.map.'Last'[J

line 10: nmap <silent> ]B <Plug>unimpairedBLast[J

function <SNR>28_MapNextFamily returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-unimpaired/plugin/unimpaired.vim[J

line 30: call s:MapNextFamily('l','l')[J

calling function <SNR>28_MapNextFamily[J('l', 'l')

line 1:   let map = '<Plug>unimpaired'.toupper(a:map)[J

line 2:   let end = ' ".(v:count ? v:count : "")<CR>'[J

line 3:   execute 'nmap <silent> '.map.'Previous :<C-U>exe "'.a:cmd.'previous'.end[J

line 3: nmap <silent> <Plug>unimpairedLPrevious :<C-U>exe "lprevious ".(v:count ? v:count : "")<CR>[J

line 4:   execute 'nmap <silent> '.map.'Next     :<C-U>exe "'.a:cmd.'next'.end[J

line 4: nmap <silent> <Plug>unimpairedLNext     :<C-U>exe "lnext ".(v:count ? v:count : "")<CR>[J

line 5:   execute 'nmap <silent> '.map.'First    :<C-U>exe "'.a:cmd.'first'.end[J

line 5: nmap <silent> <Plug>unimpairedLFirst    :<C-U>exe "lfirst ".(v:count ? v:count : "")<CR>[J

line 6:   execute 'nmap <silent> '.map.'Last     :<C-U>exe "'.a:cmd.'last'.end[J

line 6: nmap <silent> <Plug>unimpairedLLast     :<C-U>exe "llast ".(v:count ? v:count : "")<CR>[J

line 7:   execute 'nmap <silent> ['.        a:map .' '.map.'Previous'[J

line 7: nmap <silent> [l <Plug>unimpairedLPrevious[J

line 8:   execute 'nmap <silent> ]'.        a:map .' '.map.'Next'[J

line 8: nmap <silent> ]l <Plug>unimpairedLNext[J

line 9:   execute 'nmap <silent> ['.toupper(a:map).' '.map.'First'[J

line 9: nmap <silent> [L <Plug>unimpairedLFirst[J

line 10:   execute 'nmap <silent> ]'.toupper(a:map).' '.map.'Last'[J

line 10: nmap <silent> ]L <Plug>unimpairedLLast[J

function <SNR>28_MapNextFamily returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-unimpaired/plugin/unimpaired.vim[J

line 31: call s:MapNextFamily('q','c')[J

calling function <SNR>28_MapNextFamily[J('q', 'c')

line 1:   let map = '<Plug>unimpaired'.toupper(a:map)[J

line 2:   let end = ' ".(v:count ? v:count : "")<CR>'[J

line 3:   execute 'nmap <silent> '.map.'Previous :<C-U>exe "'.a:cmd.'previous'.end[J

line 3: nmap <silent> <Plug>unimpairedQPrevious :<C-U>exe "cprevious ".(v:count ? v:count : "")<CR>[J

line 4:   execute 'nmap <silent> '.map.'Next     :<C-U>exe "'.a:cmd.'next'.end[J

line 4: nmap <silent> <Plug>unimpairedQNext     :<C-U>exe "cnext ".(v:count ? v:count : "")<CR>[J

line 5:   execute 'nmap <silent> '.map.'First    :<C-U>exe "'.a:cmd.'first'.end[J

line 5: nmap <silent> <Plug>unimpairedQFirst    :<C-U>exe "cfirst ".(v:count ? v:count : "")<CR>[J

line 6:   execute 'nmap <silent> '.map.'Last     :<C-U>exe "'.a:cmd.'last'.end[J

line 6: nmap <silent> <Plug>unimpairedQLast     :<C-U>exe "clast ".(v:count ? v:count : "")<CR>[J

line 7:   execute 'nmap <silent> ['.        a:map .' '.map.'Previous'[J

line 7: nmap <silent> [q <Plug>unimpairedQPrevious[J

line 8:   execute 'nmap <silent> ]'.        a:map .' '.map.'Next'[J

line 8: nmap <silent> ]q <Plug>unimpairedQNext[J

line 9:   execute 'nmap <silent> ['.toupper(a:map).' '.map.'First'[J

line 9: nmap <silent> [Q <Plug>unimpairedQFirst[J

line 10:   execute 'nmap <silent> ]'.toupper(a:map).' '.map.'Last'[J

line 10: nmap <silent> ]Q <Plug>unimpairedQLast[J

function <SNR>28_MapNextFamily returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-unimpaired/plugin/unimpaired.vim[J

line 32: [J

line 33: function! s:entries(path)[J

line 42: [J

line 43: function! s:FileByOffset(num)[J

line 71: [J

line 72: nnoremap <silent> <Plug>unimpairedONext     :<C-U>edit `=<SID>FileByOffset(v:count1)`<CR>[J

line 73: nnoremap <silent> <Plug>unimpairedOPrevious :<C-U>edit `=<SID>FileByOffset(-v:count1)`<CR>[J

line 74: [J

line 75: nmap ]o <Plug>unimpairedONext[J

line 76: nmap [o <Plug>unimpairedOPrevious[J

line 77: [J

line 78: " }}}1[J

line 79: " Line operations {{{1[J

line 80: [J

line 81: nnoremap <silent> <Plug>unimpairedBlankUp   :<C-U>put!=repeat(nr2char(10),v:count)<Bar>']+1<CR>[J

line 82: nnoremap <silent> <Plug>unimpairedBlankDown :<C-U>put =repeat(nr2char(10),v:count)<Bar>'[-1<CR>[J

line 83: [J

line 84: nmap [<Space> <Plug>unimpairedBlankUp[J

line 85: nmap ]<Space> <Plug>unimpairedBlankDown[J

line 86: [J

line 87: nnoremap <silent> <Plug>unimpairedMoveUp   :<C-U>exe 'norm m`'<Bar>exe 'move--'.v:count1<CR>``[J

line 88: nnoremap <silent> <Plug>unimpairedMoveDown :<C-U>exe 'norm m`'<Bar>exe 'move+'.v:count1<CR>``[J

line 89: xnoremap <silent> <Plug>unimpairedMoveUp   :<C-U>exe 'norm m`'<Bar>exe '''<,''>move--'.v:count1<CR>``[J

line 90: xnoremap <silent> <Plug>unimpairedMoveDown :<C-U>exe 'norm m`'<Bar>exe '''<,''>move''>+'.v:count1<CR>``[J

line 91: [J

line 92: nmap [e <Plug>unimpairedMoveUp[J

line 93: nmap ]e <Plug>unimpairedMoveDown[J

line 94: xmap [e <Plug>unimpairedMoveUp[J

line 95: xmap ]e <Plug>unimpairedMoveDown[J

line 96: [J

line 97: " }}}1[J

line 98: " Encoding and decoding {{{1[J

line 99: [J

line 100: function! s:StringEncode(str)[J

line 104: [J

line 105: function! s:StringDecode(str)[J

line 114: [J

line 115: function! s:UrlEncode(str)[J

line 118: [J

line 119: function! s:UrlDecode(str)[J

line 123: [J

line 124: " HTML entities {{{2[J

line 125: [J

line 189: let g:unimpaired_html_entities = { 'nbsp':     160, 'iexcl':    161, 'cent':     162, 'pound':    163, 'curren':   164, 'yen':      165, 'brvbar':   166, 'sect':     167, 'uml':      168, 'copy':     169, 'ordf':     170, 'laquo':    171, 'not':      172, 'shy':      173, 'reg':      174, 'macr':     175, 'deg':      176, 'plusmn':   177, 'sup2':     178, 'sup3':     179, 'acute':    180, 'micro':    181, 'para':     182, 'middot':   183, 'cedil':    184, 'sup1':     185, 'ordm':     186, 'raquo':    187, 'frac14':   188, 'frac12':   189, 'frac34':   190, 'iquest':   191, 'Agrave':   192, 'Aacute':   193, 'Acirc':    194, 'Atilde':   195, 'Auml':     196, 'Aring':    197, 'AElig':    198, 'Ccedil':   199, 'Egrave':   200, 'Eacute':   201, 'Ecirc':    202, 'Euml':     203, 'Igrave':   204, 'Iacute':   205, 'Icirc':    206, 'Iuml':     207, 'ETH':      208, 'Ntilde':   209, 'Ograve':   210, 'Oacute':   211, 'Ocirc':    212, 'Otilde':   213, 'Ouml':     214, 'times':    215, 'Oslash':   216, 'Ugrave': [J

line 190: [J

line 191: " }}}2[J

line 192: [J

line 193: function! s:XmlEncode(str)[J

line 201: [J

line 202: function! s:XmlEntityDecode(str)[J

line 213: [J

line 214: function! s:XmlDecode(str)[J

line 218: [J

line 219: function! s:Transform(algorithm,type)[J

line 244: [J

line 245: function! s:TransformOpfunc(type)[J

line 248: [J

line 249: function! s:TransformSetup(algorithm)[J

line 253: [J

line 254: function! s:MapTransform(algorithm, key)[J

line 262: [J

line 263: call s:MapTransform('StringEncode','[y')[J

calling function <SNR>28_MapTransform[J('StringEncode', '[y')

line 1:   exe 'nnoremap <silent> <Plug>unimpaired'    .a:algorithm.' :<C-U>call <SID>TransformSetup("'.a:algorithm.'")<CR>g@'[J

line 1: nnoremap <silent> <Plug>unimpairedStringEncode :<C-U>call <SID>TransformSetup("StringEncode")<CR>g@[J

line 2:   exe 'xnoremap <silent> <Plug>unimpaired'    .a:algorithm.' :<C-U>call <SID>Transform("'.a:algorithm.'",visualmode())<CR>'[J

line 2: xnoremap <silent> <Plug>unimpairedStringEncode :<C-U>call <SID>Transform("StringEncode",visualmode())<CR>[J

line 3:   exe 'nnoremap <silent> <Plug>unimpairedLine'.a:algorithm.' :<C-U>call <SID>Transform("'.a:algorithm.'",v:count1)<CR>'[J

line 3: nnoremap <silent> <Plug>unimpairedLineStringEncode :<C-U>call <SID>Transform("StringEncode",v:count1)<CR>[J

line 4:   exe 'nmap '.a:key.'  <Plug>unimpaired'.a:algorithm[J

line 4: nmap [y  <Plug>unimpairedStringEncode[J

line 5:   exe 'xmap '.a:key.'  <Plug>unimpaired'.a:algorithm[J

line 5: xmap [y  <Plug>unimpairedStringEncode[J

line 6:   exe 'nmap '.a:key.a:key[strlen(a:key)-1].' <Plug>unimpairedLine'.a:algorithm[J

line 6: nmap [yy <Plug>unimpairedLineStringEncode[J

function <SNR>28_MapTransform returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-unimpaired/plugin/unimpaired.vim[J

line 264: call s:MapTransform('StringDecode',']y')[J

calling function <SNR>28_MapTransform[J('StringDecode', ']y')

line 1:   exe 'nnoremap <silent> <Plug>unimpaired'    .a:algorithm.' :<C-U>call <SID>TransformSetup("'.a:algorithm.'")<CR>g@'[J

line 1: nnoremap <silent> <Plug>unimpairedStringDecode :<C-U>call <SID>TransformSetup("StringDecode")<CR>g@[J

line 2:   exe 'xnoremap <silent> <Plug>unimpaired'    .a:algorithm.' :<C-U>call <SID>Transform("'.a:algorithm.'",visualmode())<CR>'[J

line 2: xnoremap <silent> <Plug>unimpairedStringDecode :<C-U>call <SID>Transform("StringDecode",visualmode())<CR>[J

line 3:   exe 'nnoremap <silent> <Plug>unimpairedLine'.a:algorithm.' :<C-U>call <SID>Transform("'.a:algorithm.'",v:count1)<CR>'[J

line 3: nnoremap <silent> <Plug>unimpairedLineStringDecode :<C-U>call <SID>Transform("StringDecode",v:count1)<CR>[J

line 4:   exe 'nmap '.a:key.'  <Plug>unimpaired'.a:algorithm[J

line 4: nmap ]y  <Plug>unimpairedStringDecode[J

line 5:   exe 'xmap '.a:key.'  <Plug>unimpaired'.a:algorithm[J

line 5: xmap ]y  <Plug>unimpairedStringDecode[J

line 6:   exe 'nmap '.a:key.a:key[strlen(a:key)-1].' <Plug>unimpairedLine'.a:algorithm[J

line 6: nmap ]yy <Plug>unimpairedLineStringDecode[J

function <SNR>28_MapTransform returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-unimpaired/plugin/unimpaired.vim[J

line 265: call s:MapTransform('UrlEncode','[u')[J

calling function <SNR>28_MapTransform[J('UrlEncode', '[u')

line 1:   exe 'nnoremap <silent> <Plug>unimpaired'    .a:algorithm.' :<C-U>call <SID>TransformSetup("'.a:algorithm.'")<CR>g@'[J

line 1: nnoremap <silent> <Plug>unimpairedUrlEncode :<C-U>call <SID>TransformSetup("UrlEncode")<CR>g@[J

line 2:   exe 'xnoremap <silent> <Plug>unimpaired'    .a:algorithm.' :<C-U>call <SID>Transform("'.a:algorithm.'",visualmode())<CR>'[J

line 2: xnoremap <silent> <Plug>unimpairedUrlEncode :<C-U>call <SID>Transform("UrlEncode",visualmode())<CR>[J

line 3:   exe 'nnoremap <silent> <Plug>unimpairedLine'.a:algorithm.' :<C-U>call <SID>Transform("'.a:algorithm.'",v:count1)<CR>'[J

line 3: nnoremap <silent> <Plug>unimpairedLineUrlEncode :<C-U>call <SID>Transform("UrlEncode",v:count1)<CR>[J

line 4:   exe 'nmap '.a:key.'  <Plug>unimpaired'.a:algorithm[J

line 4: nmap [u  <Plug>unimpairedUrlEncode[J

line 5:   exe 'xmap '.a:key.'  <Plug>unimpaired'.a:algorithm[J

line 5: xmap [u  <Plug>unimpairedUrlEncode[J

line 6:   exe 'nmap '.a:key.a:key[strlen(a:key)-1].' <Plug>unimpairedLine'.a:algorithm[J

line 6: nmap [uu <Plug>unimpairedLineUrlEncode[J

function <SNR>28_MapTransform returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-unimpaired/plugin/unimpaired.vim[J

line 266: call s:MapTransform('UrlDecode',']u')[J

calling function <SNR>28_MapTransform[J('UrlDecode', ']u')

line 1:   exe 'nnoremap <silent> <Plug>unimpaired'    .a:algorithm.' :<C-U>call <SID>TransformSetup("'.a:algorithm.'")<CR>g@'[J

line 1: nnoremap <silent> <Plug>unimpairedUrlDecode :<C-U>call <SID>TransformSetup("UrlDecode")<CR>g@[J

line 2:   exe 'xnoremap <silent> <Plug>unimpaired'    .a:algorithm.' :<C-U>call <SID>Transform("'.a:algorithm.'",visualmode())<CR>'[J

line 2: xnoremap <silent> <Plug>unimpairedUrlDecode :<C-U>call <SID>Transform("UrlDecode",visualmode())<CR>[J

line 3:   exe 'nnoremap <silent> <Plug>unimpairedLine'.a:algorithm.' :<C-U>call <SID>Transform("'.a:algorithm.'",v:count1)<CR>'[J

line 3: nnoremap <silent> <Plug>unimpairedLineUrlDecode :<C-U>call <SID>Transform("UrlDecode",v:count1)<CR>[J

line 4:   exe 'nmap '.a:key.'  <Plug>unimpaired'.a:algorithm[J

line 4: nmap ]u  <Plug>unimpairedUrlDecode[J

line 5:   exe 'xmap '.a:key.'  <Plug>unimpaired'.a:algorithm[J

line 5: xmap ]u  <Plug>unimpairedUrlDecode[J

line 6:   exe 'nmap '.a:key.a:key[strlen(a:key)-1].' <Plug>unimpairedLine'.a:algorithm[J

line 6: nmap ]uu <Plug>unimpairedLineUrlDecode[J

function <SNR>28_MapTransform returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-unimpaired/plugin/unimpaired.vim[J

line 267: call s:MapTransform('XmlEncode','[x')[J

calling function <SNR>28_MapTransform[J('XmlEncode', '[x')

line 1:   exe 'nnoremap <silent> <Plug>unimpaired'    .a:algorithm.' :<C-U>call <SID>TransformSetup("'.a:algorithm.'")<CR>g@'[J

line 1: nnoremap <silent> <Plug>unimpairedXmlEncode :<C-U>call <SID>TransformSetup("XmlEncode")<CR>g@[J

line 2:   exe 'xnoremap <silent> <Plug>unimpaired'    .a:algorithm.' :<C-U>call <SID>Transform("'.a:algorithm.'",visualmode())<CR>'[J

line 2: xnoremap <silent> <Plug>unimpairedXmlEncode :<C-U>call <SID>Transform("XmlEncode",visualmode())<CR>[J

line 3:   exe 'nnoremap <silent> <Plug>unimpairedLine'.a:algorithm.' :<C-U>call <SID>Transform("'.a:algorithm.'",v:count1)<CR>'[J

line 3: nnoremap <silent> <Plug>unimpairedLineXmlEncode :<C-U>call <SID>Transform("XmlEncode",v:count1)<CR>[J

line 4:   exe 'nmap '.a:key.'  <Plug>unimpaired'.a:algorithm[J

line 4: nmap [x  <Plug>unimpairedXmlEncode[J

line 5:   exe 'xmap '.a:key.'  <Plug>unimpaired'.a:algorithm[J

line 5: xmap [x  <Plug>unimpairedXmlEncode[J

line 6:   exe 'nmap '.a:key.a:key[strlen(a:key)-1].' <Plug>unimpairedLine'.a:algorithm[J

line 6: nmap [xx <Plug>unimpairedLineXmlEncode[J

function <SNR>28_MapTransform returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-unimpaired/plugin/unimpaired.vim[J

line 268: call s:MapTransform('XmlDecode',']x')[J

calling function <SNR>28_MapTransform[J('XmlDecode', ']x')

line 1:   exe 'nnoremap <silent> <Plug>unimpaired'    .a:algorithm.' :<C-U>call <SID>TransformSetup("'.a:algorithm.'")<CR>g@'[J

line 1: nnoremap <silent> <Plug>unimpairedXmlDecode :<C-U>call <SID>TransformSetup("XmlDecode")<CR>g@[J

line 2:   exe 'xnoremap <silent> <Plug>unimpaired'    .a:algorithm.' :<C-U>call <SID>Transform("'.a:algorithm.'",visualmode())<CR>'[J

line 2: xnoremap <silent> <Plug>unimpairedXmlDecode :<C-U>call <SID>Transform("XmlDecode",visualmode())<CR>[J

line 3:   exe 'nnoremap <silent> <Plug>unimpairedLine'.a:algorithm.' :<C-U>call <SID>Transform("'.a:algorithm.'",v:count1)<CR>'[J

line 3: nnoremap <silent> <Plug>unimpairedLineXmlDecode :<C-U>call <SID>Transform("XmlDecode",v:count1)<CR>[J

line 4:   exe 'nmap '.a:key.'  <Plug>unimpaired'.a:algorithm[J

line 4: nmap ]x  <Plug>unimpairedXmlDecode[J

line 5:   exe 'xmap '.a:key.'  <Plug>unimpaired'.a:algorithm[J

line 5: xmap ]x  <Plug>unimpairedXmlDecode[J

line 6:   exe 'nmap '.a:key.a:key[strlen(a:key)-1].' <Plug>unimpairedLine'.a:algorithm[J

line 6: nmap ]xx <Plug>unimpairedLineXmlDecode[J

function <SNR>28_MapTransform returning #0[J

continuing in /Users/Eric/.config/vim/bundle/vim-unimpaired/plugin/unimpaired.vim[J

line 269: [J

line 270: " }}}1[J

line 271: [J

line 272: let &cpo = s:cpo_save[J

line 273: [J

line 274: " vim:set ft=vim ts=8 sw=2 sts=2:[J

finished sourcing /Users/Eric/.vim/bundle/vim-unimpaired/plugin/unimpaired.vim[J
Searching for "/usr/share/vim/vimfiles/plugin/**/*.vim"[J
Searching for "/usr/share/vim/vim72/plugin/**/*.vim"[J
sourcing "/usr/share/vim/vim72/plugin/getscriptPlugin.vim"[J
line 1: " ---------------------------------------------------------------------[J

line 2: " getscriptPlugin.vim[J

line 3: "  Author:^ICharles E. Campbell, Jr.[J

line 4: "  Date:^IJan 07, 2008[J

line 5: "  Installing:^I:help glvs-install[J

line 6: "  Usage:^I:help glvs[J

line 7: "[J

line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim[J

line 9: "[J

line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let[J

line 11: " all the peoples praise Him."[J

line 12: " ---------------------------------------------------------------------[J

line 13: " Initialization:^I{{{1[J

line 14: " if you're sourcing this file, surely you can't be[J

line 15: " expecting vim to be in its vi-compatible mode[J

line 16: if &cp || exists("g:loaded_getscriptPlugin")[J

line 17:  if &verbose[J

line 18:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"[J

line 19:  endif[J

line 20:  finish[J

line 21: endif[J

line 22: let g:loaded_getscriptPlugin = "v31"[J

line 23: let s:keepcpo                = &cpo[J

line 24: set cpo&vim[J

line 25: [J

line 26: " ---------------------------------------------------------------------[J

line 27: "  Public Interface: {{{1[J

line 28: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()[J

line 29: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()[J

line 30: silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()[J

line 31: [J

line 32: " ---------------------------------------------------------------------[J

line 33: " Restore Options: {{{1[J

line 34: let &cpo= s:keepcpo[J

line 35: unlet s:keepcpo[J

line 36: [J

line 37: " ---------------------------------------------------------------------[J

line 38: " vim: ts=8 sts=2 fdm=marker nowrap[J

finished sourcing /usr/share/vim/vim72/plugin/getscriptPlugin.vim[J
sourcing "/usr/share/vim/vim72/plugin/gzip.vim"[J
line 1: " Vim plugin for editing compressed files.[J

line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2005 Jul 26[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded[J

line 7: " - when 'compatible' is set[J

line 8: " - some autocommands are already taking care of compressed files[J

line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")[J

line 10:   finish[J

line 11: endif[J

line 12: let loaded_gzip = 1[J

line 13: [J

line 14: augroup gzip[J

line 15:   " Remove all gzip autocommands[J

line 16:   au![J

line 17: [J

line 18:   " Enable editing of gzipped files.[J

line 19:   " The functions are defined in autoload/gzip.vim.[J

line 20:   "[J

line 21:   " Set binary mode before reading the file.[J

line 22:   " Use "gzip -d", gunzip isn't always available.[J

line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z setlocal bin[J

line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")[J

line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")[J

line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")[J

line 27:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")[J

line 28:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")[J

line 29:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")[J

line 30:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")[J

line 31:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")[J

line 32:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")[J

line 33:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")[J

line 34:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")[J

line 35:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")[J

line 36: augroup END[J

finished sourcing /usr/share/vim/vim72/plugin/gzip.vim[J
sourcing "/usr/share/vim/vim72/plugin/matchparen.vim"[J
line 1: " Vim plugin for showing matching parens[J

line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2008 Feb 27[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded (or disabled)[J

line 7: " - when 'compatible' is set[J

line 8: " - the "CursorMoved" autocmd event is not availble.[J

line 9: if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")[J

line 10:   finish[J

line 11: endif[J

line 12: let g:loaded_matchparen = 1[J

line 13: [J

line 14: augroup matchparen[J

line 15:   " Replace all matchparen autocommands[J

line 16:   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()[J

line 17: augroup END[J

line 18: [J

line 19: " Skip the rest if it was already done.[J

line 20: if exists("*s:Highlight_Matching_Pair")[J

line 21:   finish[J

line 22: endif[J

line 23: [J

line 24: let cpo_save = &cpo[J

line 25: set cpo-=C[J

line 26: [J

line 27: " The function that is invoked (very often) to define a ":match" highlighting[J

line 28: " for any matching paren.[J

line 29: function! s:Highlight_Matching_Pair()[J

line 144: [J

line 145: " Define commands that will disable and enable the plugin.[J

line 147: command! NoMatchParen windo 3match none | unlet! g:loaded_matchparen | au! matchparen[J

line 148: command! DoMatchParen runtime plugin/matchparen.vim | windo doau CursorMoved[J

line 149: [J

line 150: let &cpo = cpo_save[J

finished sourcing /usr/share/vim/vim72/plugin/matchparen.vim[J
sourcing "/usr/share/vim/vim72/plugin/netrwPlugin.vim"[J
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network[J

line 2: "            PLUGIN SECTION[J

line 3: " Date:^I^IAug 01, 2008[J

line 4: " Maintainer:^ICharles E Campbell, Jr <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>[J

line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim[J

line 6: " Copyright:    Copyright (C) 1999-2008 Charles E. Campbell, Jr. {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like anything else that's free,[J

line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided[J

line 11: "               *as is* and comes with no warranty of any kind, either[J

line 12: "               expressed or implied. By using this plugin, you agree that[J

line 13: "               in no event will the copyright holder be liable for any damages[J

line 14: "               resulting from the use of this software.[J

line 15: "[J

line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1[J

line 17: "  (James 1:22 RSV)[J

line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-[J

line 19: [J

line 20: " ---------------------------------------------------------------------[J

line 21: " Load Once: {{{1[J

line 22: if &cp || exists("g:loaded_netrwPlugin")[J

line 23:  finish[J

line 24: endif[J

line 25: let g:loaded_netrwPlugin = "v132"[J

line 26: let s:keepcpo            = &cpo[J

line 27: if v:version < 700[J

line 28:  echohl WarningMsg | echo "***netrw*** you need vim version 7.0 for this version of netrw" | echohl None[J

line 28:  echo "***netrw*** you need vim version 7.0 for this version of netrw" | echohl None[J

line 28:  echohl None[J

line 29:  finish[J

line 30: endif[J

line 31: let s:keepcpo= &cpo[J

line 32: set cpo&vim[J

line 33: [J

line 34: " ---------------------------------------------------------------------[J

line 35: " Public Interface: {{{1[J

line 36: [J

line 37: " Local Browsing: {{{2[J

line 38: augroup FileExplorer[J

line 39:  au![J

line 40:  au BufEnter * silent! call s:LocalBrowse(expand("<amatch>"))[J

line 41:  if has("win32") || has("win95") || has("win64") || has("win16")[J

line 42:   au BufEnter .* silent! call s:LocalBrowse(expand("<amatch>"))[J

line 43:  endif[J

line 44: augroup END[J

line 45: [J

line 46: " Network Browsing Reading Writing: {{{2[J

line 47: augroup Network[J

line 48:  au![J

line 49:  if has("win32") || has("win95") || has("win64") || has("win16")[J

line 50:   au BufReadCmd  file://*^I^Iexe "silent doau BufReadPre ".fnameescape(netrw#RFC2396(expand("<amatch>")))|exe 'e '.fnameescape(substitute(netrw#RFC2396(expand("<amatch>")),'file://\(.*\)','\1',""))|exe "bwipe ".fnameescape(expand("<amatch>"))|exe "silent doau BufReadPost ".fnameescape(netrw#RFC2396(expand("<amatch>")))[J

line 51:  else[J

line 52:   au BufReadCmd  file://*^I^Iexe "silent doau BufReadPre ".fnameescape(netrw#RFC2396(expand("<amatch>")))|exe 'e '.fnameescape(substitute(netrw#RFC2396(expand("<amatch>")),'file://\(.*\)','\1',""))|exe "bwipe ".fnameescape(expand("<amatch>"))|exe "silent doau BufReadPost ".fnameescape(netrw#RFC2396(expand("<amatch>")))[J

line 53:   au BufReadCmd  file://localhost/*^Iexe "silent doau BufReadPre ".fnameescape(netrw#RFC2396(expand("<amatch>")))|exe 'e '.fnameescape(substitute(netrw#RFC2396(expand("<amatch>")),'file://localhost/\(.*\)','\1',""))|exe "bwipe ".fnameescape(substitute(expand("<amatch>"),'file://\(\k\+@\)\=','',''))|exe "silent doau BufReadPost ".fnameescape(netrw#RFC2396(expand("<amatch>")))[J

line 54:  endif[J

line 55:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "silent doau BufReadPre ".fnameescape(expand("<amatch>"))|exe '2Nread '.fnameescape(expand("<amatch>"))|exe "silent doau BufReadPost ".fnameescape(expand("<amatch>"))[J

line 56:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "silent doau FileReadPre ".fnameescape(expand("<amatch>"))|exe 'Nread '.fnameescape(expand("<amatch>"))|exe "silent doau FileReadPost ".fnameescape(expand("<amatch>"))[J

line 57:  au BufWriteCmd  ftp://*,rcp://*,scp://*,dav://*,davs://*,rsync://*,sftp://*^I^Iexe "silent doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "silent doau BufWritePost ".fnameescape(expand("<amatch>"))[J

line 58:  au FileWriteCmd ftp://*,rcp://*,scp://*,dav://*,davs://*,rsync://*,sftp://*^I^Iexe "silent doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "silent doau FileWritePost ".fnameescape(expand("<amatch>"))[J

line 59:  try[J

line 60:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))[J

line 61:  catch /^Vim\%((\a\+)\)\=:E216/[J

line 62:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))[J

line 63:  endtry[J

line 64: augroup END[J

line 65: [J

line 66: " Commands: :Nread, :Nwrite, :NetUserPass {{{2[J

line 67: com! -count=1 -nargs=*^INread^I^Icall netrw#NetrwSavePosn()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call netrw#NetrwRestorePosn()[J

line 68: com! -range=% -nargs=*^INwrite^I^Icall netrw#NetrwSavePosn()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call netrw#NetrwRestorePosn()[J

line 69: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)[J

line 70: com! -nargs=*^I        Nsource^I^Icall netrw#NetrwSavePosn()<bar>call netrw#NetSource(<f-args>)<bar>call netrw#NetrwRestorePosn()[J

line 71: [J

line 72: " Commands: :Explore, :Sexplore, Hexplore, Vexplore {{{2[J

line 73: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)[J

line 74: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)[J

line 75: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)[J

line 76: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)[J

line 77: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)[J

line 78: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)[J

line 79: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)[J

line 80: [J

line 81: " Commands: NetrwSettings {{{2[J

line 82: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()[J

line 83: com! -bang^INetrwClean^Icall netrw#NetrwClean(<bang>0)[J

line 84: [J

line 85: " Maps:[J

line 86: if !exists("g:netrw_nogx") && maparg('g','n') == ""[J

line 87:  if !hasmapto('<Plug>NetrwBrowseX')[J

line 88:   nmap <unique> gx <Plug>NetrwBrowseX[J

line 89:  endif[J

line 90:  nno <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cWORD>"),0)<cr>[J

line 91: endif[J

line 92: [J

line 93: " ---------------------------------------------------------------------[J

line 94: " LocalBrowse: {{{2[J

line 95: fun! s:LocalBrowse(dirname)[J

line 113: [J

line 114: " ---------------------------------------------------------------------[J

line 115: " NetrwStatusLine: {{{1[J

line 116: fun! NetrwStatusLine()[J

line 127: [J

line 128: " ------------------------------------------------------------------------[J

line 129: " NetUserPass: set username and password for subsequent ftp transfer {{{1[J

line 130: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password[J

line 131: "^I    :call NetUserPass("uid")^I^I-- will prompt for password[J

line 132: "^I    :call NetUserPass("uid","password") -- sets global userid and password[J

line 133: fun! NetUserPass(...)[J

line 157: [J

line 158: " ------------------------------------------------------------------------[J

line 159: " NetReadFixup: this sort of function is typically written by the user {{{1[J

line 160: "               to handle extra junk that their system's ftp dumps[J

line 161: "               into the transfer.  This function is provided as an[J

line 162: "               example and as a fix for a Windows 95 problem: in my[J

line 163: "               experience, win95's ftp always dumped four blank lines[J

line 164: "               at the end of the transfer.[J

line 165: if has("win95") && exists("g:netrw_win95ftp") && g:netrw_win95ftp[J

line 166:  fun! NetReadFixup(method, line1, line2)[J

line 174: endif[J

line 175: [J

line 176: " ------------------------------------------------------------------------[J

line 177: " Modelines And Restoration: {{{1[J

line 178: let &cpo= s:keepcpo[J

line 179: unlet s:keepcpo[J

line 180: " vim:ts=8 fdm=marker[J

finished sourcing /usr/share/vim/vim72/plugin/netrwPlugin.vim[J
sourcing "/usr/share/vim/vim72/plugin/rrhelper.vim"[J
line 1: " Vim plugin with helper function(s) for --remote-wait[J

line 2: " Maintainer: Flemming Madsen <fma@cci.dk>[J

line 3: " Last Change: 2008 May 29[J

line 4: [J

line 5: " Has this already been loaded?[J

line 6: if exists("loaded_rrhelper")[J

line 7:   finish[J

line 8: endif[J

line 9: let loaded_rrhelper = 1[J

line 10: [J

line 11: " Setup answers for a --remote-wait client who will assume[J

line 12: " a SetupRemoteReplies() function in the command server[J

line 13: [J

line 14: if has("clientserver")[J

line 15:   function SetupRemoteReplies()[J

line 42: [J

line 43:   function DoRemoteReply(id, cnt, group, file)[J

line 48: [J

line 49: endif[J

line 50: [J

line 51: [J

line 52: " vim: set sw=2 sts=2 :[J

finished sourcing /usr/share/vim/vim72/plugin/rrhelper.vim[J
sourcing "/usr/share/vim/vim72/plugin/spellfile.vim"[J
line 1: " Vim plugin for downloading spell files[J

line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2006 Feb 01[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded[J

line 7: " - when 'compatible' is set[J

line 8: " - some autocommands are already taking care of spell files[J

line 9: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")[J

line 10:   finish[J

line 11: endif[J

line 12: let loaded_spellfile_plugin = 1[J

line 13: [J

line 14: " The function is in the autoload directory.[J

line 15: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))[J

finished sourcing /usr/share/vim/vim72/plugin/spellfile.vim[J
sourcing "/usr/share/vim/vim72/plugin/tarPlugin.vim"[J
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles[J

line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>[J

line 3: " Modified by Charles E. Campbell, Jr.[J

line 4: " Distributed under the GNU General Public License.[J

line 5: "[J

line 6: " Updates are available from <http://michael.toren.net/code/>.  If you[J

line 7: " find this script useful, or have suggestions for improvements, please[J

line 8: " let me know.[J

line 9: " Also look there for further comments and documentation.[J

line 10: "[J

line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.[J

line 12: " ---------------------------------------------------------------------[J

line 13: "  Load Once: {{{1[J

line 14: if &cp || exists("g:loaded_tarPlugin")[J

line 15:  finish[J

line 16: endif[J

line 17: let g:loaded_tarPlugin = "v23"[J

line 18: let s:keepcpo          = &cpo[J

line 19: set cpo&vim[J

line 20: [J

line 21: " ---------------------------------------------------------------------[J

line 22: "  Public Interface: {{{1[J

line 23: augroup tar[J

line 24:   au![J

line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)[J

line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)[J

line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))[J

line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))[J

line 29: [J

line 30:   if has("unix")[J

line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)[J

line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)[J

line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))[J

line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))[J

line 35:   endif[J

line 36: [J

line 37:   au BufReadCmd   *.tar.gz^Icall tar#Browse(expand("<amatch>"))[J

line 38:   au BufReadCmd   *.tar^I^Icall tar#Browse(expand("<amatch>"))[J

line 39:   au BufReadCmd   *.lrp^I^Icall tar#Browse(expand("<amatch>"))[J

line 40:   au BufReadCmd   *.tar.bz2^Icall tar#Browse(expand("<amatch>"))[J

line 41:   au BufReadCmd   *.tar.Z^Icall tar#Browse(expand("<amatch>"))[J

line 42:   au BufReadCmd   *.tgz^I^Icall tar#Browse(expand("<amatch>"))[J

line 43: augroup END[J

line 44: [J

line 45: " ---------------------------------------------------------------------[J

line 46: " Restoration And Modelines: {{{1[J

line 47: " vim: fdm=marker[J

line 48: let &cpo= s:keepcpo[J

line 49: unlet s:keepcpo[J

finished sourcing /usr/share/vim/vim72/plugin/tarPlugin.vim[J
sourcing "/usr/share/vim/vim72/plugin/tohtml.vim"[J
line 1: " Vim plugin for converting a syntax highlighted file to HTML.[J

line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2003 Apr 06[J

line 4: [J

line 5: " Don't do this when:[J

line 6: " - when 'compatible' is set[J

line 7: " - this plugin was already loaded[J

line 8: " - user commands are not available.[J

line 9: if !&cp && !exists(":TOhtml") && has("user_commands")[J

line 10:   command -range=% TOhtml :call Convert2HTML(<line1>, <line2>)[J

line 11: [J

line 12:   func Convert2HTML(line1, line2)[J

line 26: [J

line 27: endif[J

finished sourcing /usr/share/vim/vim72/plugin/tohtml.vim[J
sourcing "/usr/share/vim/vim72/plugin/vimballPlugin.vim"[J
line 1: " vimballPlugin : construct a file containing both paths and files[J

line 2: " Author: Charles E. Campbell, Jr.[J

line 3: " Copyright: (c) 2004-2007 by Charles E. Campbell, Jr.[J

line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt[J

line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".[J

line 6: "            No warranty, express or implied.[J

line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***[J

line 8: "[J

line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who[J

line 10: "      judge. For in that which you judge another, you condemn yourself. For[J

line 11: "      you who judge practice the same things.[J

line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim[J

line 13: [J

line 14: " ---------------------------------------------------------------------[J

line 15: "  Load Once: {{{1[J

line 16: if &cp || exists("g:loaded_vimballPlugin")[J

line 17:  finish[J

line 18: endif[J

line 19: let g:loaded_vimballPlugin = "v29"[J

line 20: let s:keepcpo              = &cpo[J

line 21: set cpo&vim[J

line 22: [J

line 23: " ------------------------------------------------------------------------------[J

line 24: " Public Interface: {{{1[J

line 25: com! -ra   -complete=file -na=+ -bang MkVimball call vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)[J

line 26: com! -na=? -complete=dir  UseVimball  call vimball#Vimball(1,<f-args>)[J

line 27: com! -na=0                VimballList call vimball#Vimball(0)[J

line 28: com! -na=* -complete=dir  RmVimball   call vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()[J

line 29: au BufEnter  *.vba.gz,*.vba.bz2,*.vba.zip call vimball#Decompress(expand("<amatch>"))[J

line 30: au BufEnter  *.vba setlocal ff=unix noma bt=nofile fmr=[[[,]]] fdm=marker|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")[J

line 31: [J

line 32: " =====================================================================[J

line 33: " Restoration And Modelines: {{{1[J

line 34: " vim: fdm=marker[J

line 35: let &cpo= s:keepcpo[J

line 36: unlet s:keepcpo[J

finished sourcing /usr/share/vim/vim72/plugin/vimballPlugin.vim[J
sourcing "/usr/share/vim/vim72/plugin/zipPlugin.vim"[J
line 1: " zipPlugin.vim: Handles browsing zipfiles[J

line 2: "            PLUGIN PORTION[J

line 3: " Date:^I^I^IOct 05, 2007[J

line 4: " Maintainer:^ICharles E Campbell, Jr <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>[J

line 5: " License:^I^IVim License  (see vim's :help license)[J

line 6: " Copyright:    Copyright (C) 2005,2006 Charles E. Campbell, Jr. {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like anything else that's free,[J

line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty[J

line 11: "               of any kind, either expressed or implied. By using this[J

line 12: "               plugin, you agree that in no event will the copyright[J

line 13: "               holder be liable for any damages resulting from the use[J

line 14: "               of this software.[J

line 15: "[J

line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.[J

line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.[J

line 18: " ---------------------------------------------------------------------[J

line 19: " Load Once: {{{1[J

line 20: if &cp || exists("g:loaded_zipPlugin")[J

line 21:  finish[J

line 22: endif[J

line 23: let g:loaded_zipPlugin = "v22"[J

line 24: let s:keepcpo          = &cpo[J

line 25: set cpo&vim[J

line 26: [J

line 27: " ---------------------------------------------------------------------[J

line 28: " Public Interface: {{{1[J

line 29: augroup zip[J

line 30:  au![J

line 31:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)[J

line 32:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)[J

line 33:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))[J

line 34:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))[J

line 35: [J

line 36:  if has("unix")[J

line 37:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)[J

line 38:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)[J

line 39:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))[J

line 40:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))[J

line 41:  endif[J

line 42: [J

line 43:  au BufReadCmd   *.zip,*.jar,*.xpi,*.war,*.ear^I^Icall zip#Browse(expand("<amatch>"))[J

line 44: augroup END[J

line 45: [J

line 46: " ---------------------------------------------------------------------[J

line 47: "  Restoration And Modelines: {{{1[J

line 48: "  vim: fdm=marker[J

line 49: let &cpo= s:keepcpo[J

line 50: unlet s:keepcpo[J

finished sourcing /usr/share/vim/vim72/plugin/zipPlugin.vim[J
Searching for "/usr/share/vim/vimfiles/after/plugin/**/*.vim"[J
Searching for "/Users/Eric/.vim/bundle/snipmate/after/plugin/**/*.vim"[J
sourcing "/Users/Eric/.vim/bundle/snipmate/after/plugin/snipMate.vim"[J
line 1: " These are the mappings for snipMate.vim. Putting it here ensures that it[J

line 2: " will be mapped after other plugins such as supertab.vim.[J

line 3: if !exists('loaded_snips') || exists('s:did_snips_mappings')[J

line 4: ^Ifinish[J

line 5: endif[J

line 6: let s:did_snips_mappings = 1[J

line 7: [J

line 8: ino <silent> <tab> <c-r>=TriggerSnippet()<cr>[J

line 9: snor <silent> <tab> <esc>i<right><c-r>=TriggerSnippet()<cr>[J

line 10: ino <silent> <s-tab> <c-r>=BackwardsSnippet()<cr>[J

line 11: snor <silent> <s-tab> <esc>i<right><c-r>=BackwardsSnippet()<cr>[J

line 12: ino <silent> <c-r><tab> <c-r>=ShowAvailableSnips()<cr>[J

line 13: [J

line 14: " The default mappings for these are annoying & sometimes break snipMate.[J

line 15: " You can change them back if you want, I've put them here for convenience.[J

line 16: snor <bs> b<bs>[J

line 17: snor <right> <esc>a[J

line 18: snor <left> <esc>bi[J

line 19: snor ' b<bs>'[J

line 20: snor ` b<bs>`[J

line 21: snor % b<bs>%[J

line 22: snor U b<bs>U[J

line 23: snor ^ b<bs>^[J

line 24: snor \ b<bs>\[J

No mapping found[J
line 25: snor <c-x> b<bs><c-x>[J

line 26: [J

line 27: " By default load snippets in snippets_dir[J

line 28: if empty(snippets_dir)[J

line 29: ^Ifinish[J

line 30: endif[J

line 31: [J

line 32: call GetSnippets(snippets_dir, '_') " Get global snippets[J

calling function GetSnippets[J('/Users/Eric/.vim/bundle/snipmate/sni...ers/Eric/.vim/bundle/snipmate/snippets/', '_')

line 1: ^Ifor ft in split(a:filetypes, '\.')[J

line 2: ^I^Iif has_key(g:did_ft, ft) | continue | endif[J

line 2:  continue | endif[J

line 2:  endif[J

line 3: ^I^Icall s:DefineSnips(a:dir, ft, ft)[J

calling function GetSnippets..<SNR>19_DefineSnips[J('/Users/Eric/.vim/bundle/snipmate/sni...ers/Eric/.vim/bundle/snipmate/snippets/', '_', '_')

line 1: ^Ifor path in split(globpath(a:dir, a:aliasft.'/')."\n". globpath(a:dir, a:aliasft.'-*/'), "\n")[J

line 3: ^I^Icall ExtractSnips(path, a:realft)[J

line 4: ^Iendfor[J

line 5: ^Ifor path in split(globpath(a:dir, a:aliasft.'.snippets')."\n". globpath(a:dir, a:aliasft.'-*.snippets'), "\n")[J

line 7: ^I^Icall ExtractSnipsFile(path, a:realft)[J

calling function GetSnippets..<SNR>19_DefineSnips..ExtractSnipsFile[J('/Users/Eric/.vim/bundle/snipmate/sni...vim/bundle/snipmate/snippets/_.snippets', '_')

line 1: ^Iif !filereadable(a:file) | return | endif[J

line 1:  return | endif[J

line 1:  endif[J

line 2: ^Ilet text = readfile(a:file)[J

line 3: ^Ilet inSnip = 0[J

line 4: ^Ifor line in text + ["\n"][J

line 5: ^I^Iif inSnip && (line[0] == "\t" || line == '')[J

line 6: ^I^I^Ilet content .= strpart(line, 1)."\n"[J

line 7: ^I^I^Icontinue[J

line 8: ^I^Ielseif inSnip[J

line 9: ^I^I^Icall MakeSnip(a:ft, trigger, content[:-2], name)[J

line 10: ^I^I^Ilet inSnip = 0[J

line 11: ^I^Iendif[J

line 12: [J

line 13: ^I^Iif line[:6] == 'snippet'[J

line 14: ^I^I^Ilet inSnip = 1[J

line 15: ^I^I^Ilet trigger = strpart(line, 8)[J

line 16: ^I^I^Ilet name = ''[J

line 17: ^I^I^Ilet space = stridx(trigger, ' ') + 1[J

line 18: ^I^I^Iif space " Process multi snip[J

line 19: ^I^I^I^Ilet name = strpart(trigger, space)[J

line 20: ^I^I^I^Ilet trigger = strpart(trigger, 0, space - 1)[J

line 21: ^I^I^Iendif[J

line 22: ^I^I^Ilet content = ''[J

line 23: ^I^Iendif[J

line 24: ^Iendfor[J

line 4: ^Ifor line in text + ["\n"][J

line 5: ^I^Iif inSnip && (line[0] == "\t" || line == '')[J

line 6: ^I^I^Ilet content .= strpart(line, 1)."\n"[J

line 7: ^I^I^Icontinue[J

line 8: ^I^Ielseif inSnip[J

line 9: ^I^I^Icall MakeSnip(a:ft, trigger, content[:-2], name)[J

line 10: ^I^I^Ilet inSnip = 0[J

line 11: ^I^Iendif[J

line 12: [J

line 13: ^I^Iif line[:6] == 'snippet'[J

line 14: ^I^I^Ilet inSnip = 1[J

line 15: ^I^I^Ilet trigger = strpart(line, 8)[J

line 16: ^I^I^Ilet name = ''[J

line 17: ^I^I^Ilet space = stridx(trigger, ' ') + 1[J

line 18: ^I^I^Iif space " Process multi snip[J

line 19: ^I^I^I^Ilet name = strpart(trigger, space)[J

line 20: ^I^I^I^Ilet trigger = strpart(trigger, 0, space - 1)[J

line 21: ^I^I^Iendif[J

line 22: ^I^I^Ilet content = ''[J

line 23: ^I^Iendif[J

line 24: ^Iendfor[J

line 4: ^Ifor line in text + ["\n"][J

line 5: ^I^Iif inSnip && (line[0] == "\t" || line == '')[J

line 6: ^I^I^Ilet content .= strpart(line, 1)."\n"[J

line 7: ^I^I^Icontinue[J

line 8: ^I^Ielseif inSnip[J

line 9: ^I^I^Icall MakeSnip(a:ft, trigger, content[:-2], name)[J

line 10: ^I^I^Ilet inSnip = 0[J

line 11: ^I^Iendif[J

line 12: [J

line 13: ^I^Iif line[:6] == 'snippet'[J

line 14: ^I^I^Ilet inSnip = 1[J

line 15: ^I^I^Ilet trigger = strpart(line, 8)[J

line 16: ^I^I^Ilet name = ''[J

line 17: ^I^I^Ilet space = stridx(trigger, ' ') + 1[J

line 18: ^I^I^Iif space " Process multi snip[J

line 19: ^I^I^I^Ilet name = strpart(trigger, space)[J

line 20: ^I^I^I^Ilet trigger = strpart(trigger, 0, space - 1)[J

line 21: ^I^I^Iendif[J

line 22: ^I^I^Ilet content = ''[J

line 23: ^I^Iendif[J

line 24: ^Iendfor[J

line 4: ^Ifor line in text + ["\n"][J

line 5: ^I^Iif inSnip && (line[0] == "\t" || line == '')[J

line 6: ^I^I^Ilet content .= strpart(line, 1)."\n"[J

line 7: ^I^I^Icontinue[J

line 8: ^I^Ielseif inSnip[J

line 9: ^I^I^Icall MakeSnip(a:ft, trigger, content[:-2], name)[J

line 10: ^I^I^Ilet inSnip = 0[J

line 11: ^I^Iendif[J

line 12: [J

line 13: ^I^Iif line[:6] == 'snippet'[J

line 14: ^I^I^Ilet inSnip = 1[J

line 15: ^I^I^Ilet trigger = strpart(line, 8)[J

line 16: ^I^I^Ilet name = ''[J

line 17: ^I^I^Ilet space = stridx(trigger, ' ') + 1[J

line 18: ^I^I^Iif space " Process multi snip[J

line 19: ^I^I^I^Ilet name = strpart(trigger, space)[J

line 20: ^I^I^I^Ilet trigger = strpart(trigger, 0, space - 1)[J

line 21: ^I^I^Iendif[J

line 22: ^I^I^Ilet content = ''[J

line 23: ^I^Iendif[J

line 24: ^Iendfor[J

line 4: ^Ifor line in text + ["\n"][J

line 5: ^I^Iif inSnip && (line[0] == "\t" || line == '')[J

line 6: ^I^I^Ilet content .= strpart(line, 1)."\n"[J

line 7: ^I^I^Icontinue[J

line 4: ^Ifor line in text + ["\n"][J

line 5: ^I^Iif inSnip && (line[0] == "\t" || line == '')[J

line 6: ^I^I^Ilet content .= strpart(line, 1)."\n"[J

line 7: ^I^I^Icontinue[J

line 8: ^I^Ielseif inSnip[J

line 9: ^I^I^Icall MakeSnip(a:ft, trigger, content[:-2], name)[J

calling function GetSnippets..<SNR>19_DefineSnips..ExtractSnipsFile..MakeSnip[J('_', 'c)', '`&enc[:2] == "utf" ? "©" : "(c)"` Co...nips_author`}. All Rights Reserved.${2}', '')

line 1: ^Ilet multisnip = a:0 && a:1 != ''[J

line 2: ^Ilet var = multisnip ? 's:multi_snips' : 's:snippets'[J

line 3: ^Iif !has_key({var}, a:scope) | let {var}[a:scope] = {} | endif[J

line 3:  let {var}[a:scope] = {} | endif[J

line 3:  endif[J

line 4: ^Iif !has_key({var}[a:scope], a:trigger)[J

line 5: ^I^Ilet {var}[a:scope][a:trigger] = multisnip ? [[a:1, a:content]] : a:content[J

line 6: ^Ielseif multisnip | let {var}[a:scope][a:trigger] += [[a:1, a:content]][J

line 6:  let {var}[a:scope][a:trigger] += [[a:1, a:content]][J

line 7: ^Ielse[J

line 8: ^I^Iechom 'Warning in snipMate.vim: Snippet '.a:trigger.' is already defined.' .' See :h multi_snip for help on snippets with multiple matches.'[J

line 10: ^Iendif[J

function GetSnippets..<SNR>19_DefineSnips..ExtractSnipsFile..MakeSnip returning #0[J

continuing in function GetSnippets..<SNR>19_DefineSnips..ExtractSnipsFile[J

line 10: ^I^I^Ilet inSnip = 0[J

line 11: ^I^Iendif[J

line 12: [J

line 13: ^I^Iif line[:6] == 'snippet'[J

line 14: ^I^I^Ilet inSnip = 1[J

line 15: ^I^I^Ilet trigger = strpart(line, 8)[J

line 16: ^I^I^Ilet name = ''[J

line 17: ^I^I^Ilet space = stridx(trigger, ' ') + 1[J

line 18: ^I^I^Iif space " Process multi snip[J

line 19: ^I^I^I^Ilet name = strpart(trigger, space)[J

line 20: ^I^I^I^Ilet trigger = strpart(trigger, 0, space - 1)[J

line 21: ^I^I^Iendif[J

line 22: ^I^I^Ilet content = ''[J

line 23: ^I^Iendif[J

line 24: ^Iendfor[J

line 4: ^Ifor line in text + ["\n"][J

line 5: ^I^Iif inSnip && (line[0] == "\t" || line == '')[J

line 6: ^I^I^Ilet content .= strpart(line, 1)."\n"[J

line 7: ^I^I^Icontinue[J

line 4: ^Ifor line in text + ["\n"][J

line 5: ^I^Iif inSnip && (line[0] == "\t" || line == '')[J

line 6: ^I^I^Ilet content .= strpart(line, 1)."\n"[J

line 7: ^I^I^Icontinue[J

line 8: ^I^Ielseif inSnip[J

line 9: ^I^I^Icall MakeSnip(a:ft, trigger, content[:-2], name)[J

calling function GetSnippets..<SNR>19_DefineSnips..ExtractSnipsFile..MakeSnip[J('_', 'date', '`strftime("%Y-%m-%d")`', '')

line 1: ^Ilet multisnip = a:0 && a:1 != ''[J

line 2: ^Ilet var = multisnip ? 's:multi_snips' : 's:snippets'[J

line 3: ^Iif !has_key({var}, a:scope) | let {var}[a:scope] = {} | endif[J

line 3:  let {var}[a:scope] = {} | endif[J

line 3:  endif[J

line 4: ^Iif !has_key({var}[a:scope], a:trigger)[J

line 5: ^I^Ilet {var}[a:scope][a:trigger] = multisnip ? [[a:1, a:content]] : a:content[J

line 6: ^Ielseif multisnip | let {var}[a:scope][a:trigger] += [[a:1, a:content]][J

line 6:  let {var}[a:scope][a:trigger] += [[a:1, a:content]][J

line 7: ^Ielse[J

line 8: ^I^Iechom 'Warning in snipMate.vim: Snippet '.a:trigger.' is already defined.' .' See :h multi_snip for help on snippets with multiple matches.'[J

line 10: ^Iendif[J

function GetSnippets..<SNR>19_DefineSnips..ExtractSnipsFile..MakeSnip returning #0[J

continuing in function GetSnippets..<SNR>19_DefineSnips..ExtractSnipsFile[J

line 10: ^I^I^Ilet inSnip = 0[J

line 11: ^I^Iendif[J

line 12: [J

line 13: ^I^Iif line[:6] == 'snippet'[J

line 14: ^I^I^Ilet inSnip = 1[J

line 15: ^I^I^Ilet trigger = strpart(line, 8)[J

line 16: ^I^I^Ilet name = ''[J

line 17: ^I^I^Ilet space = stridx(trigger, ' ') + 1[J

line 18: ^I^I^Iif space " Process multi snip[J

line 19: ^I^I^I^Ilet name = strpart(trigger, space)[J

line 20: ^I^I^I^Ilet trigger = strpart(trigger, 0, space - 1)[J

line 21: ^I^I^Iendif[J

line 22: ^I^I^Ilet content = ''[J

line 23: ^I^Iendif[J

line 24: ^Iendfor[J

line 4: ^Ifor line in text + ["\n"][J

line 5: ^I^Iif inSnip && (line[0] == "\t" || line == '')[J

line 6: ^I^I^Ilet content .= strpart(line, 1)."\n"[J

line 7: ^I^I^Icontinue[J

line 8: ^I^Ielseif inSnip[J

line 9: ^I^I^Icall MakeSnip(a:ft, trigger, content[:-2], name)[J

line 10: ^I^I^Ilet inSnip = 0[J

line 11: ^I^Iendif[J

line 12: [J

line 13: ^I^Iif line[:6] == 'snippet'[J

line 14: ^I^I^Ilet inSnip = 1[J

line 15: ^I^I^Ilet trigger = strpart(line, 8)[J

line 16: ^I^I^Ilet name = ''[J

line 17: ^I^I^Ilet space = stridx(trigger, ' ') + 1[J

line 18: ^I^I^Iif space " Process multi snip[J

line 19: ^I^I^I^Ilet name = strpart(trigger, space)[J

line 20: ^I^I^I^Ilet trigger = strpart(trigger, 0, space - 1)[J

line 21: ^I^I^Iendif[J

line 22: ^I^I^Ilet content = ''[J

line 23: ^I^Iendif[J

line 24: ^Iendfor[J

function GetSnippets..<SNR>19_DefineSnips..ExtractSnipsFile returning #0[J

continuing in function GetSnippets..<SNR>19_DefineSnips[J

line 8: ^Iendfor[J

line 5: ^Ifor path in split(globpath(a:dir, a:aliasft.'.snippets')."\n". globpath(a:dir, a:aliasft.'-*.snippets'), "\n")[J

line 7: ^I^Icall ExtractSnipsFile(path, a:realft)[J

line 8: ^Iendfor[J

function GetSnippets..<SNR>19_DefineSnips returning #0[J

continuing in function GetSnippets[J

line 4: ^I^Iif ft == 'objc' || ft == 'cpp' || ft == 'cs'[J

line 5: ^I^I^Icall s:DefineSnips(a:dir, 'c', ft)[J

line 6: ^I^Ielseif ft == 'xhtml'[J

line 7: ^I^I^Icall s:DefineSnips(a:dir, 'html', 'xhtml')[J

line 8: ^I^Iendif[J

line 9: ^I^Ilet g:did_ft[ft] = 1[J

line 10: ^Iendfor[J

line 1: ^Ifor ft in split(a:filetypes, '\.')[J

line 2: ^I^Iif has_key(g:did_ft, ft) | continue | endif[J

line 2:  continue | endif[J

line 2:  endif[J

line 3: ^I^Icall s:DefineSnips(a:dir, ft, ft)[J

line 4: ^I^Iif ft == 'objc' || ft == 'cpp' || ft == 'cs'[J

line 5: ^I^I^Icall s:DefineSnips(a:dir, 'c', ft)[J

line 6: ^I^Ielseif ft == 'xhtml'[J

line 7: ^I^I^Icall s:DefineSnips(a:dir, 'html', 'xhtml')[J

line 8: ^I^Iendif[J

line 9: ^I^Ilet g:did_ft[ft] = 1[J

line 10: ^Iendfor[J

function GetSnippets returning #0[J

continuing in /Users/Eric/.config/vim/bundle/snipmate/after/plugin/snipMate.vim[J

line 33: [J

line 34: au FileType * if &ft != 'help' | call GetSnippets(snippets_dir, &ft) | endif[J

line 35: " vim:noet:sw=4:ts=4:ft=vim[J

finished sourcing /Users/Eric/.vim/bundle/snipmate/after/plugin/snipMate.vim[J
Searching for "/Users/Eric/.vim/after/plugin/**/*.vim"[J
Reading viminfo file "/Users/Eric/.viminfo" info oldfiles[J
Press ENTER or type command to continue7[?47h[?1h=[1;20r[m[H[2J[19;1HExecuting BufWinEnter Auto commands for "*"
autocommand if s:diff_window_count() == 1 && &diff && getbufvar(+expand('<abuf>'), 'git_dir') !=# '' | call s:diff_off(
[19;120H)[20;1H | endif
line 0: if s:diff_window_count() == 1 && &diff && getbufvar(+expand('<abuf>'), 'git_dir') !=# '' | call s:diff_off() | 
[19;120He[20;1Hndif
calling function <SNR>22_diff_window_count()
line 1:   let c = 0
line 2:   for nr in range(1,winnr('$'))
line 3:     let c += getwinvar(nr,'&diff')
line 4:   endfor
line 2:   for nr in range(1,winnr('$'))
line 3:     let c += getwinvar(nr,'&diff')
line 4:   endfor
line 5:   return c
function <SNR>22_diff_window_count returning #0
continuing in BufWinEnter Auto commands for "*"
line 0:  call s:diff_off() | endif
line 0:  endif
Executing BufEnter Auto commands for "*"
-- More --[20;1H[K[20;1Hautocommand :call s:SetUpForNewFiletype(&filetype, 0)
-- More --[20;1H[K[20;1Hline 0: :call s:SetUpForNewFiletype(&filetype, 0)
-- More --[20;1H[K[20;1Hcalling function <SNR>17_SetUpForNewFiletype('', 0)
-- More --[20;1H[K[20;1Hline 1:     let b:NERDSexyComMarker = ''
-- More --[20;1H[K[20;1Hline 2: 
-- More --[20;1H[K[20;1Hline 3:     if has_key(s:delimiterMap, a:filetype)
-- More --[20;1H[K[20;1Hline 4:         let b:NERDCommenterDelims = s:delimiterMap[a:filetype]
-- More --[20;1H[K[20;1Hline 5:         for i in ['left', 'leftAlt', 'right', 'rightAlt']
-- More --[20;1H[K[20;1Hline 6:             if !has_key(b:NERDCommenterDelims, i)
-- More --[20;1H[K[20;1Hline 7:                 let b:NERDCommenterDelims[i] = ''
-- More --[20;1H[K[20;1Hline 8:             endif
-- More --[20;1H[K[20;1Hline 9:         endfor
-- More --[20;1H[K[20;1Hline 10:     else
-- More --[20;1H[K[20;1Hline 11:         let b:NERDCommenterDelims = s:CreateDelimMapFromCms()
-- More --[20;1H[K[20;1Hcalling function <SNR>17_SetUpForNewFiletype..<SNR>17_CreateDelimMapFromCms()
-- More --[20;1H[K[20;1Hline 1:     return { 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''), 'right': substitute(&commentst
[19;120Hr[20;1H-- More --[20;1H[K[20;1Hing, '.*%s\s*\(.*\)', '\1', 'g'), 'leftAlt': '', 'rightAlt': '' }
-- More --[20;1H[K[20;1Hfunction <SNR>17_SetUpForNewFiletype..<SNR>17_CreateDelimMapFromCms returning {'right': '*/', 'rightAlt': '', 'left...h
[19;120Ht[20;1H-- More --[20;1H[K[20;1HAlt': '', 'leftAlt': '', 'left': '/*'}
-- More ---- More -- SPACE/d/j: screen/page/line down, b/u/k: up, q: quit [20;1H[K[20;1Hcontinuing in function <SNR>17_SetUpForNewFiletype
line 12:     endif
line 13: 
function <SNR>17_SetUpForNewFiletype returning #0
continuing in BufEnter Auto commands for "*"
Executing BufEnter Auto commands for "*"
autocommand call s:checkForBrowse(expand("<amatch>"))
line 0: call s:checkForBrowse(expand("<amatch>"))
calling function <SNR>18_checkForBrowse('')
line 1:     if a:dir != '' && isdirectory(a:dir)
line 2:         call s:initNerdTreeInPlace(a:dir)
line 3:     endif
function <SNR>18_checkForBrowse returning #0
continuing in BufEnter Auto commands for "*"
Executing BufEnter Auto commands for "*"
autocommand if exists("b:rails_root")|silent doau User BufEnterRails|endif
line 0: if exists("b:rails_root")|silent doau User BufEnterRails|endif
line 0: silent doau User BufEnterRails|endif
line 0: endif
-- More --[20;1H[K[20;1HExecuting BufEnter Auto commands for "*"
autocommand silent! call s:LocalBrowse(expand("<amatch>"))
line 0: silent! call s:LocalBrowse(expand("<amatch>"))
Executing VimEnter Auto commands for "*"
Press ENTER or type command to continue
autocommand call s:Bookmark.CacheBookmarks(0)
Press ENTER or type command to continue
line 0: call s:Bookmark.CacheBookmarks(0)
calling function 7(0)
line 1:     if filereadable(g:NERDTreeBookmarksFile)
line 2:         let g:NERDTreeBookmarks = []
line 3:         let g:NERDTreeInvalidBookmarks = []
line 4:         let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)
line 5:         let invalidBookmarksFound = 0
line 6:         for i in bookmarkStrings
line 7: 
line 8:             "ignore blank lines
line 9:             if i != ''
line 10: 
line 11:                 let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')
line 12:                 let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')
line 13: 
line 14:                 try
line 15:                     let bookmark = s:Bookmark.New(name, s:Path.New(path))
line 16:                     call add(g:NERDTreeBookmarks, bookmark)
line 17:                 catch /^NERDTree.InvalidArgumentsError/
-- More --[20;1H[K[20;1Hline 18:                     call add(g:NERDTreeInvalidBookmarks, i)
line 19:                     let invalidBookmarksFound += 1
line 20:                 endtry
line 21:             endif
line 22:         endfor
line 23:         if invalidBookmarksFound
line 24:             call s:Bookmark.Write()
line 25:             if !a:silent
line 26:                 call s:echo(invalidBookmarksFound . " invalid bookmarks were read. See :help NERDTreeInvalidBo
[19;120Ho[20;1Hkmarks for info.")
line 27:             endif
line 28:         endif
line 29:         call s:Bookmark.Sort()
line 30:     endif
function 7 returning #0
continuing in VimEnter Auto commands for "*"
autocommand runtime! nerdtree_plugin/**/*.vim
Press ENTER or type command to continue
line 0: runtime! nerdtree_plugin/**/*.vim
Searching for "nerdtree_plugin/**/*.vim" in "/Users/Eric/.vim,/Users/Eric/.vim/bundle/align,/Users/Eric/.vim/bundle/com
[19;120Hm[20;1Hand-t,/Users/Eric/.vim/bundle/gist,/Users/Eric/.vim/bundle/nerdcommenter,/Users/Eric/.vim/bundle/nerdtree,/Users/Eric/.
[19;120Hv[20;1Him/bundle/snipmate,/Users/Eric/.vim/bundle/vim-abolish,/Users/Eric/.vim/bundle/vim-cucumber,/Users/Eric/.vim/bundle/vim
[19;120H-[20;1Hendwise,/Users/Eric/.vim/bundle/vim-fugitive,/Users/Eric/.vim/bundle/vim-git,/Users/Eric/.vim/bundle/vim-markdown-previ
[19;120He[20;1Hw,/Users/Eric/.vim/bundle/vim-pastie,/Users/Eric/.vim/bundle/vim-rails,/Users/Eric/.vim/bundle/vim-repeat,/Users/Eric/.
[19;120Hv[20;1Him/bundle/vim-rspec,/Users/Eric/.vim/bundle/vim-surround,/Users/Eric/.vim/bundle/vim-unimpaired,/usr/share/vim/vimfiles
[19;120H,[20;1H/usr/share/vim/vim72,/usr/share/vim/vimfiles/after,/Users/Eric/.vim/bundle/snipmate/after,/Users/Eric/.vim/after"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/align/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/command-t/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/gist/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/nerdcommenter/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/nerdtree/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/snipmate/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/vim-abolish/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/vim-cucumber/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/vim-endwise/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/vim-fugitive/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/vim-git/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/vim-markdown-preview/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/vim-pastie/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/vim-rails/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/vim-repeat/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/vim-rspec/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/vim-surround/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/vim-unimpaired/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/usr/share/vim/vimfiles/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/usr/share/vim/vim72/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/usr/share/vim/vimfiles/after/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/bundle/snipmate/after/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Searching for "/Users/Eric/.vim/after/nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
not found in 'runtimepath': "nerdtree_plugin/**/*.vim"
Press ENTER or type command to continue
Executing VimEnter Auto commands for "*"
Press ENTER or type command to continue
autocommand silent! autocmd! FileExplorer
Press ENTER or type command to continue
line 0: silent! autocmd! FileExplorer
autocommand call s:checkForBrowse(expand("<amatch>"))
Press ENTER or type command to continue
line 0: call s:checkForBrowse(expand("<amatch>"))
calling function <SNR>18_checkForBrowse('')
line 1:     if a:dir != '' && isdirectory(a:dir)
line 2:         call s:initNerdTreeInPlace(a:dir)
line 3:     endif
function <SNR>18_checkForBrowse returning #0
continuing in VimEnter Auto commands for "*"
Executing VimEnter Auto commands for "*"
Press ENTER or type command to continue
autocommand call s:compatibility_check()
Press ENTER or type command to continue
line 0: call s:compatibility_check()
calling function <SNR>22_compatibility_check()
line 1:   if exists('b:git_dir') && exists('*GitBranchInfoCheckGitDir') && !exists('g:fugitive_did_compatibility_warnin
[19;120Hg[20;1H')
line 2:     let g:fugitive_did_compatibility_warning = 1
line 3:     call s:warn("See http://github.com/tpope/vim-fugitive/issues#issue/1 for why you should remove git-branch-i
[19;120Hn[20;1Hfo.vim")
line 4:   endif
function <SNR>22_compatibility_check returning #0
continuing in VimEnter Auto commands for "*"
Executing VimEnter Auto commands for "*"
Press ENTER or type command to continue
autocommand if expand('<amatch>')==''|call s:Detect(getcwd())|endif
Press ENTER or type command to continue
line 0: if expand('<amatch>')==''|call s:Detect(getcwd())|endif
line 0: call s:Detect(getcwd())|endif
calling function <SNR>22_Detect('/Users/Eric/.config/vim/colors')
line 1:   if exists('b:git_dir') && b:git_dir ==# ''
line 2:     unlet b:git_dir
line 3:   endif
line 4:   if !exists('b:git_dir')
line 5:     let dir = s:ExtractGitDir(a:path)
calling function <SNR>22_Detect..<SNR>22_ExtractGitDir('/Users/Eric/.config/vim/colors')
line 1:   let path = s:shellslash(a:path)
calling function <SNR>22_Detect..<SNR>22_ExtractGitDir..<SNR>22_shellslash('/Users/Eric/.config/vim/colors')
line 1:   if exists('+shellslash') && !&shellslash
line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function <SNR>22_Detect..<SNR>22_ExtractGitDir..<SNR>22_shellslash returning '/Users/Eric/.config/vim/colors'
continuing in function <SNR>22_Detect..<SNR>22_ExtractGitDir
line 2:   if path =~? '^fugitive://.*//'
line 3:     return matchstr(path,'fugitive://\zs.\{-\}\ze//')
-- More --[20;1H[K[20;1Hline 4:   endif
line 5:   let fn = fnamemodify(path,':s?[\/]$??')
line 6:   let ofn = ""
line 7:   let nfn = fn
line 8:   while fn != ofn
line 9:     if isdirectory(fn . '/.git')
line 10:       return s:sub(simplify(fnamemodify(fn . '/.git',':p')),'\W$','')
line 11:     elseif fn =~ '\.git$' && filereadable(fn . '/HEAD')
line 12:       return s:sub(simplify(fnamemodify(fn,':p')),'\W$','')
line 13:     endif
line 14:     let ofn = fn
line 15:     let fn = fnamemodify(ofn,':h')
line 16:   endwhile
line 8:   while fn != ofn
line 9:     if isdirectory(fn . '/.git')
line 10:       return s:sub(simplify(fnamemodify(fn . '/.git',':p')),'\W$','')
calling function <SNR>22_Detect..<SNR>22_ExtractGitDir..<SNR>22_sub('/Users/Eric/.config/vim/.git/', '\W$', '')
line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function <SNR>22_Detect..<SNR>22_ExtractGitDir..<SNR>22_sub returning '/Users/Eric/.config/vim/.git'
-- More --[20;1H[K[20;1Hcontinuing in function <SNR>22_Detect..<SNR>22_ExtractGitDir
function <SNR>22_Detect..<SNR>22_ExtractGitDir returning '/Users/Eric/.config/vim/.git'
continuing in function <SNR>22_Detect
line 6:     if dir != ''
line 7:       let b:git_dir = dir
line 8:     endif
line 9:   endif
line 10:   if exists('b:git_dir')
line 11:     silent doautocmd User Fugitive
line 12:     cnoremap <expr> <buffer> <C-R><C-G> fugitive#buffer().rev()
line 13:     let buffer = fugitive#buffer()
calling function <SNR>22_Detect..fugitive#buffer()
line 1:   return s:buffer(a:0 ? a:1 : '%')
calling function <SNR>22_Detect..fugitive#buffer..<SNR>22_buffer('%')
line 1:   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
line 2:   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
line 3:   if buffer.getvar('git_dir') !=# ''
calling function <SNR>22_Detect..fugitive#buffer..<SNR>22_buffer..<SNR>22_buffer_getvar('git_dir')
line 1:   return getbufvar(self['#'],a:var)
-- More --[20;1H[K[20;1Hfunction <SNR>22_Detect..fugitive#buffer..<SNR>22_buffer..<SNR>22_buffer_getvar returning '/Users/Eric/.config/vim/.git
[19;120H'[20;1H
continuing in function <SNR>22_Detect..fugitive#buffer..<SNR>22_buffer
line 4:     return buffer
function <SNR>22_Detect..fugitive#buffer..<SNR>22_buffer returning {'containing_commit': function('<SNR>...'name': func
[19;120Ht[20;1Hion('<SNR>22_buffer_name')}
continuing in function <SNR>22_Detect..fugitive#buffer
function <SNR>22_Detect..fugitive#buffer returning {'containing_commit': function('<SNR>...'name': function('<SNR>22_bu
[19;120Hf[20;1Hfer_name')}
continuing in function <SNR>22_Detect
line 14:     if expand('%:p') =~# '//'
line 15:       call buffer.setvar('&path',s:sub(buffer.getvar('&path'),'^\.%(,|$)',''))
line 16:     endif
line 17:     if b:git_dir !~# ',' && stridx(buffer.getvar('&tags'),b:git_dir.'/tags') == -1
calling function <SNR>22_Detect..<SNR>22_buffer_getvar('&tags')
line 1:   return getbufvar(self['#'],a:var)
function <SNR>22_Detect..<SNR>22_buffer_getvar returning './tags,tags'
continuing in function <SNR>22_Detect
line 18:       call buffer.setvar('&tags',buffer.getvar('&tags').','.b:git_dir.'/tags')
-- More --[20;1H[K[20;1Hcalling function <SNR>22_Detect..<SNR>22_buffer_getvar('&tags')
line 1:   return getbufvar(self['#'],a:var)
function <SNR>22_Detect..<SNR>22_buffer_getvar returning './tags,tags'
continuing in function <SNR>22_Detect
calling function <SNR>22_Detect..<SNR>22_buffer_setvar('&tags', './tags,tags,/Users/Eric/.config/vim/...,tags,/Users/Er
[19;120Hi[20;1Hc/.config/vim/.git/tags')
line 1:   return setbufvar(self['#'],a:var,a:value)
function <SNR>22_Detect..<SNR>22_buffer_setvar returning #0
continuing in function <SNR>22_Detect
line 19:     endif
line 20:   endif
function <SNR>22_Detect returning #0
continuing in VimEnter Auto commands for "*"
line 0: endif
Executing VimEnter Auto commands for "*"
Press ENTER or type command to continue
autocommand if expand("<amatch>") == "" && !exists("b:rails_root") | call s:Detect(getcwd()) | endif | if exists("b:rai
[19;120Hl[20;1Hs_root") | silent doau User BufEnterRails | endif
Press ENTER or type command to continue
line 0: if expand("<amatch>") == "" && !exists("b:rails_root") | call s:Detect(getcwd()) | endif | if exists("b:rails_r
[19;120Ho[20;1Hot") | silent doau User BufEnterRails | endif
line 0:  call s:Detect(getcwd()) | endif | if exists("b:rails_root") | silent doau User BufEnterRails | endif
calling function <SNR>25_Detect('/Users/Eric/.config/vim/colors')
line 1:   let fn = substitute(fnamemodify(a:filename,":p"),'\c^file://','','')
line 2:   let sep = matchstr(fn,'^[^\\/]\{3,\}\zs[\\/]')
line 3:   if sep != ""
line 4:     let fn = getcwd().sep.fn
line 5:   endif
line 6:   if fn =~ '[\/]config[\/]environment\.rb$'
line 7:     return s:BufInit(strpart(fn,0,strlen(fn)-22))
line 8:   endif
line 9:   if isdirectory(fn)
line 10:     let fn = fnamemodify(fn,':s?[\/]$??')
line 11:   else
line 12:     let fn = fnamemodify(fn,':s?\(.*\)[\/][^\/]*$?\1?')
line 13:   endif
line 14:   let ofn = ""
line 15:   let nfn = fn
-- More --[20;1H[K[20;1Hline 16:   while nfn != ofn && nfn != ""
line 17:     if exists("s:_".s:escvar(nfn))
calling function <SNR>25_Detect..<SNR>25_escvar('/Users/Eric/.config/vim/colors')
line 1:   let r = fnamemodify(a:r,':~')
line 2:   let r = substitute(r,'\W','\="_".char2nr(submatch(0))."_"','g')
line 3:   let r = substitute(r,'^\d','_&','')
line 4:   return r
function <SNR>25_Detect..<SNR>25_escvar returning '_126__47__46_config_47_vim_47_colors...
continuing in function <SNR>25_Detect
line 18:       return s:BufInit(nfn)
line 19:     endif
line 20:     let ofn = nfn
line 21:     let nfn = fnamemodify(nfn,':h')
line 22:   endwhile
line 16:   while nfn != ofn && nfn != ""
line 17:     if exists("s:_".s:escvar(nfn))
calling function <SNR>25_Detect..<SNR>25_escvar('/Users/Eric/.config/vim')
line 1:   let r = fnamemodify(a:r,':~')
line 2:   let r = substitute(r,'\W','\="_".char2nr(submatch(0))."_"','g')
-- More --[20;1H[K[20;1Hline 3:   let r = substitute(r,'^\d','_&','')
line 4:   return r
function <SNR>25_Detect..<SNR>25_escvar returning '_126__47__46_config_47_vim'
continuing in function <SNR>25_Detect
line 18:       return s:BufInit(nfn)
line 19:     endif
line 20:     let ofn = nfn
line 21:     let nfn = fnamemodify(nfn,':h')
line 22:   endwhile
line 16:   while nfn != ofn && nfn != ""
line 17:     if exists("s:_".s:escvar(nfn))
calling function <SNR>25_Detect..<SNR>25_escvar('/Users/Eric/.config')
line 1:   let r = fnamemodify(a:r,':~')
line 2:   let r = substitute(r,'\W','\="_".char2nr(submatch(0))."_"','g')
line 3:   let r = substitute(r,'^\d','_&','')
line 4:   return r
function <SNR>25_Detect..<SNR>25_escvar returning '_126__47__46_config'
continuing in function <SNR>25_Detect
line 18:       return s:BufInit(nfn)
-- More --[20;1H[K[20;1Hline 19:     endif
line 20:     let ofn = nfn
line 21:     let nfn = fnamemodify(nfn,':h')
line 22:   endwhile
line 16:   while nfn != ofn && nfn != ""
line 17:     if exists("s:_".s:escvar(nfn))
calling function <SNR>25_Detect..<SNR>25_escvar('/Users/Eric')
line 1:   let r = fnamemodify(a:r,':~')
line 2:   let r = substitute(r,'\W','\="_".char2nr(submatch(0))."_"','g')
line 3:   let r = substitute(r,'^\d','_&','')
line 4:   return r
function <SNR>25_Detect..<SNR>25_escvar returning '_126__47_'
continuing in function <SNR>25_Detect
line 18:       return s:BufInit(nfn)
line 19:     endif
line 20:     let ofn = nfn
line 21:     let nfn = fnamemodify(nfn,':h')
line 22:   endwhile
line 16:   while nfn != ofn && nfn != ""
-- More --[20;1H[K[20;1Hline 17:     if exists("s:_".s:escvar(nfn))
calling function <SNR>25_Detect..<SNR>25_escvar('/Users')
line 1:   let r = fnamemodify(a:r,':~')
line 2:   let r = substitute(r,'\W','\="_".char2nr(submatch(0))."_"','g')
line 3:   let r = substitute(r,'^\d','_&','')
line 4:   return r
function <SNR>25_Detect..<SNR>25_escvar returning '_47_Users'
continuing in function <SNR>25_Detect
line 18:       return s:BufInit(nfn)
line 19:     endif
line 20:     let ofn = nfn
line 21:     let nfn = fnamemodify(nfn,':h')
line 22:   endwhile
line 16:   while nfn != ofn && nfn != ""
line 17:     if exists("s:_".s:escvar(nfn))
calling function <SNR>25_Detect..<SNR>25_escvar('/')
line 1:   let r = fnamemodify(a:r,':~')
line 2:   let r = substitute(r,'\W','\="_".char2nr(submatch(0))."_"','g')
line 3:   let r = substitute(r,'^\d','_&','')
-- More --[20;1H[K[20;1Hline 4:   return r
function <SNR>25_Detect..<SNR>25_escvar returning '_47_'
continuing in function <SNR>25_Detect
line 18:       return s:BufInit(nfn)
line 19:     endif
line 20:     let ofn = nfn
line 21:     let nfn = fnamemodify(nfn,':h')
line 22:   endwhile
line 16:   while nfn != ofn && nfn != ""
line 17:     if exists("s:_".s:escvar(nfn))
line 18:       return s:BufInit(nfn)
line 19:     endif
line 20:     let ofn = nfn
line 21:     let nfn = fnamemodify(nfn,':h')
line 22:   endwhile
line 23:   let ofn = ""
line 24:   while fn != ofn
line 25:     if filereadable(fn . "/config/environment.rb")
line 26:       return s:BufInit(fn)
-- More --[20;1H[K[20;1Hline 27:     endif
line 28:     let ofn = fn
line 29:     let fn = fnamemodify(ofn,':s?\(.*\)[\/]\(app\|config\|db\|doc\|features\|lib\|log\|public\|script\|spec\|s
[19;120Ht[20;1Hories\|test\|tmp\|vendor\)\($\|[\/].*$\)?\1?')
line 30:   endwhile
line 24:   while fn != ofn
line 25:     if filereadable(fn . "/config/environment.rb")
line 26:       return s:BufInit(fn)
line 27:     endif
line 28:     let ofn = fn
line 29:     let fn = fnamemodify(ofn,':s?\(.*\)[\/]\(app\|config\|db\|doc\|features\|lib\|log\|public\|script\|spec\|s
[19;120Ht[20;1Hories\|test\|tmp\|vendor\)\($\|[\/].*$\)?\1?')
line 30:   endwhile
line 31:   return 0
function <SNR>25_Detect returning #0
continuing in VimEnter Auto commands for "*"
line 0:  endif | if exists("b:rails_root") | silent doau User BufEnterRails | endif
line 0:  if exists("b:rails_root") | silent doau User BufEnterRails | endif
line 0:  silent doau User BufEnterRails | endif
-- More --[20;1H[K[20;1Hline 0:  endif
Executing VimEnter Auto commands for "*"
Press ENTER or type command to continue
autocommand call s:abolish_setup()
Press ENTER or type command to continue
line 0: call s:abolish_setup()
calling function <SNR>25_abolish_setup()
line 1:   if exists('g:Abolish') && has_key(g:Abolish,'Coercions')
line 2:     if !has_key(g:Abolish.Coercions,'l')
line 3:       let g:Abolish.Coercions.l = s:function('s:abolish_l')
calling function <SNR>25_abolish_setup..<SNR>25_function('s:abolish_l')
line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>25_abolish_setup..<SNR>25_function returning function('<SNR>25_abolish_l')
continuing in function <SNR>25_abolish_setup
line 4:     endif
line 5:     if !has_key(g:Abolish.Coercions,'t')
line 6:       let g:Abolish.Coercions.t = s:function('s:abolish_t')
calling function <SNR>25_abolish_setup..<SNR>25_function('s:abolish_t')
line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>25_abolish_setup..<SNR>25_function returning function('<SNR>25_abolish_t')
continuing in function <SNR>25_abolish_setup
line 7:     endif
line 8:   endif
function <SNR>25_abolish_setup returning #0
-- More --[20;1H[K[20;1Hcontinuing in VimEnter Auto commands for "*"
Executing VimEnter Auto commands for "*"
Press ENTER or type command to continue
autocommand call s:ProjectMenu()
Press ENTER or type command to continue
line 0: call s:ProjectMenu()
calling function <SNR>25_ProjectMenu()
line 1:   if exists("g:rails_did_menus") && g:rails_history_size > 0
line 2:     if !exists("g:RAILS_HISTORY")
line 3:       let g:RAILS_HISTORY = ""
line 4:     endif
line 5:     let history = g:RAILS_HISTORY
line 6:     let menu = s:gsub(g:rails_installed_menu,'\&','')
line 7:     silent! exe "aunmenu <script> ".menu.".Projects"
line 8:     let dots = s:gsub(menu,'[^.]','')
line 9:     exe 'anoremenu <script> <silent> '.(exists("$CREAM") ? '87' : '').dots.'.100 '.menu.'.Pro&jects.&New\.\.\.\
[19;120H^[20;1HI:Rails :call <SID>menuprompt("Rails","New application path and additional arguments: ")<CR>'
line 10:     exe 'anoremenu <script> '.menu.'.Pro&jects.-FSep- :'
line 11:     while history =~ '\n'
line 12:       let proj = matchstr(history,'^.\{-\}\ze\n')
line 13:       let history = s:sub(history,'^.{-}\n','')
line 14:       exe 'anoremenu <script> '.menu.'.Pro&jects.'.s:gsub(proj,'[.\\ ]','\\&').' :e '.s:gsub(proj."/".g:rails_
[19;120Hd[20;1Hefault_file,'[ !%#]','\\&')."<CR>"
line 15:     endwhile
-- More --[20;1H[K[20;1Hline 16:   endif
function <SNR>25_ProjectMenu returning #0
continuing in VimEnter Auto commands for "*"
Press ENTER or type command to continueExecuting CursorMoved Auto commands for "*"
Press ENTER or type command to continue
autocommand call s:Highlight_Matching_Pair()
Press ENTER or type command to continue
line 0: call s:Highlight_Matching_Pair()
calling function <SNR>31_Highlight_Matching_Pair()
line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     3match none
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
-- More --[20;1H[K[20;1Hline 18:   let c = getline(c_lnum)[c_col - 1]
line 19:   let plist = split(&matchpairs, '.\zs[:,]')
line 20:   let i = index(plist, c)
line 21:   if i < 0
line 22:     " not found, in Insert mode try character before the cursor
line 23:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 24:       let before = 1
line 25:       let c = getline(c_lnum)[c_col - 2]
line 26:       let i = index(plist, c)
line 27:     endif
line 28:     if i < 0
line 29:       " not found, nothing to do
line 30:       return
function <SNR>31_Highlight_Matching_Pair returning #0
continuing in CursorMoved Auto commands for "*"
[m[H[2J[1;1H[33m  1 [m
[1m[34m~                                                                                                                       [3;1H~                                                                                                                       [4;1H~                                                                                                                       [5;1H~                                                                                                                       [6;1H~                                                                                                                       [7;1H~                                                                                                                       [8;1H~                                                                                                                       [9;1H~                                                                                                                       [10;1H~                                                                                                                       [11;1H~                                                                                                                       [12;1H~                                                                                                                       [13;1H~                                                                                                                       [14;1H~                                                                                                                       [15;1H~                                                                                                                       [16;1H~                                                                                                                       [17;1H~                                                                                                                       [m[18;1H[1m[7m[No Name]                                                                                             0,0-1          All[m[4;52HVIM - Vi IMproved[6;53Hversion 7.2.108[7;49Hby Bram Moolenaar et al.[8;39HVim is open source and freely distributable[10;46HBecome a registered Vim user![11;38Htype  :help register[34m<Enter>[m   for information [13;38Htype  :q[34m<Enter>[m               to exit         [14;38Htype  :help[34m<Enter>[m  or  [34m<F1>[m  for on-line help[15;38Htype  :help version7[34m<Enter>[m   for version info[1;5H[19;1H:q
[19;1HExecuting BufWinLeave Auto commands for "*"
autocommand execute getwinvar(+winnr(), 'fugitive_restore')
line 0: execute getwinvar(+winnr(), 'fugitive_restore')
line 0: 
Executing BufWinLeave Auto commands for "*"
autocommand if s:diff_window_count() == 2 && &diff && getbufvar(+expand('<abuf>'), 'git_dir') !=# '' | execute 'windo c
[19;120Ha[20;1Hll s:diff_off()' | endif
line 0: if s:diff_window_count() == 2 && &diff && getbufvar(+expand('<abuf>'), 'git_dir') !=# '' | execute 'windo call 
[19;120Hs[20;1H:diff_off()' | endif
calling function <SNR>22_diff_window_count()
line 1:   let c = 0
line 2:   for nr in range(1,winnr('$'))
line 3:     let c += getwinvar(nr,'&diff')
line 4:   endfor
line 2:   for nr in range(1,winnr('$'))
line 3:     let c += getwinvar(nr,'&diff')
line 4:   endfor
line 5:   return c
function <SNR>22_diff_window_count returning #0
[32m-- More --[m[20;1H[K[20;1Hcontinuing in BufWinLeave Auto commands for "*"
line 0:  execute 'windo call s:diff_off()' | endif
line 0:  endif
Writing viminfo file "/Users/Eric/.viminfo"[?1l>[2J[?47l8
